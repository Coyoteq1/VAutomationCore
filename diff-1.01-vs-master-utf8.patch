diff --git a/Bluelock/Commands/Core/ZoneCommands.cs b/Bluelock/Commands/Core/ZoneCommands.cs
index 91c50ac..c4d0dad 100644
--- a/Bluelock/Commands/Core/ZoneCommands.cs
+++ b/Bluelock/Commands/Core/ZoneCommands.cs
@@ -34,8 +34,8 @@ namespace VAuto.Zone.Commands
             var rootDir = System.IO.Path.Combine(Paths.ConfigPath, "Bluelock");
             Directory.CreateDirectory(rootDir);
 
-            var rootPath = System.IO.Path.Combine(rootDir, "Bluelock.zones.json");
-            var legacyPath = System.IO.Path.Combine(rootDir, "config", "Bluelock.zones.json");
+            var rootPath = System.IO.Path.Combine(rootDir, "VAuto.Zones.json");
+            var legacyPath = System.IO.Path.Combine(rootDir, "config", "VAuto.Zones.json");
             try
             {
                 if (!File.Exists(rootPath) && File.Exists(legacyPath))
@@ -732,7 +732,7 @@ namespace VAuto.Zone.Commands
                 var json = File.ReadAllText(ZonesFile);
                 using var doc = JsonDocument.Parse(json);
 
-                // Primary schema: Bluelock.zones.json (capitalized "zones")
+                // Primary schema: VAuto.Zones.json (capitalized "Zones")
                 if (doc.RootElement.TryGetProperty("Zones", out var zonesEl) && zonesEl.ValueKind == JsonValueKind.Array)
                 {
                     foreach (var zoneEl in zonesEl.EnumerateArray())
diff --git a/Bluelock/Core/Arena/ArenaLifecycleManager.cs b/Bluelock/Core/Arena/ArenaLifecycleManager.cs
new file mode 100644
index 0000000..0bd67d0
--- /dev/null
+++ b/Bluelock/Core/Arena/ArenaLifecycleManager.cs
@@ -0,0 +1,114 @@
+using System;
+using System.Collections.Generic;
+using Unity.Entities;
+using Unity.Mathematics;
+using VAutomationCore.Models;
+using VAuto.Zone.Services;
+
+namespace VAuto.Zone.Core.Arena
+{
+    /// <summary>
+    /// Manages arena lifecycle events and transitions.
+    /// </summary>
+    public class ArenaLifecycleManager
+    {
+        private readonly Dictionary<Entity, PlayerZoneState> _playerStates = new Dictionary<Entity, PlayerZoneState>();
+
+        /// <summary>
+        /// Handles player entering an arena zone.
+        /// </summary>
+        public void OnPlayerEnterArena(Entity character, string zoneId, float3 position)
+        {
+            try
+            {
+                var state = new PlayerZoneState
+                {
+                    CurrentZoneId = zoneId,
+                    WasInZone = true,
+                    EnteredAt = DateTime.UtcNow
+                };
+                _playerStates[character] = state;
+
+                ZoneCore.LogDebug($"Player entered arena zone {zoneId}");
+                ZoneEventBridge.PublishPlayerEntered(character, zoneId);
+            }
+            catch (Exception ex)
+            {
+                ZoneCore.LogException($"Failed to handle player enter arena", ex);
+            }
+        }
+
+        /// <summary>
+        /// Handles player exiting an arena zone.
+        /// </summary>
+        public void OnPlayerExitArena(Entity character, string zoneId)
+        {
+            try
+            {
+                if (_playerStates.TryGetValue(character, out var state))
+                {
+                    state.PreviousZoneId = state.CurrentZoneId;
+                    state.CurrentZoneId = string.Empty;
+                    state.ExitedAt = DateTime.UtcNow;
+                }
+
+                ZoneCore.LogDebug($"Player exited arena zone {zoneId}");
+                ZoneEventBridge.PublishPlayerExited(character, zoneId);
+            }
+            catch (Exception ex)
+            {
+                ZoneCore.LogException($"Failed to handle player exit arena", ex);
+            }
+        }
+
+        /// <summary>
+        /// Gets the current zone state for a player.
+        /// </summary>
+        public PlayerZoneState GetPlayerState(Entity character)
+        {
+            return _playerStates.TryGetValue(character, out var state) ? state : null;
+        }
+
+        /// <summary>
+        /// Gets all players currently in arena zones.
+        /// </summary>
+        public List<Entity> GetPlayersInArenas()
+        {
+            var players = new List<Entity>();
+            foreach (var kvp in _playerStates)
+            {
+                if (kvp.Value.WasInZone)
+                {
+                    players.Add(kvp.Key);
+                }
+            }
+            return players;
+        }
+
+        /// <summary>
+        /// Processes the arena lifecycle tick.
+        /// </summary>
+        public void Tick()
+        {
+            // Implementation placeholder
+        }
+
+        /// <summary>
+        /// Initializes the lifecycle manager.
+        /// </summary>
+        public void Initialize()
+        {
+            ZoneCore.LogInfo("ArenaLifecycleManager initialized");
+            ZoneEventBridge.Initialize();
+        }
+
+        /// <summary>
+        /// Shuts down the lifecycle manager.
+        /// </summary>
+        public void Shutdown()
+        {
+            _playerStates.Clear();
+            ZoneCore.LogInfo("ArenaLifecycleManager shutdown");
+        }
+    }
+}
diff --git a/Bluelock/Core/LifecycleCore.cs b/Bluelock/Core/LifecycleCore.cs
new file mode 100644
index 0000000..3d858d0
--- /dev/null
+++ b/Bluelock/Core/LifecycleCore.cs
@@ -0,0 +1,179 @@
+using System;
+using System.Collections.Generic;
+using BepInEx.Logging;
+using Unity.Collections;
+using Unity.Entities;
+using Unity.Mathematics;
+using VAuto.Zone.Core;
+
+namespace VAuto.Zone.Core.Lifecycle
+{
+    /// <summary>
+    /// Core lifecycle models used across all lifecycle services.
+    /// </summary>
+    public class LifecycleModels
+    {
+        /// <summary>
+        /// Represents a lifecycle stage with its actions.
+        /// </summary>
+        public class LifecycleStage
+        {
+            public string Name { get; set; }
+            public string Description { get; set; }
+            public List<LifecycleAction> Actions { get; set; } = new List<LifecycleAction>();
+        }
+
+        /// <summary>
+        /// Represents a single lifecycle action.
+        /// </summary>
+        public class LifecycleAction
+        {
+            public string Type { get; set; }
+            public string ConfigId { get; set; }
+            public string Message { get; set; }
+            public string BuffId { get; set; }
+            public string EventPrefab { get; set; }
+            public float3? Position { get; set; }
+            public string StoreKey { get; set; }
+            public string Prefix { get; set; }
+            public bool ShouldSaveState { get; set; }
+            public bool ShouldRestoreState { get; set; }
+            public bool ShouldClearBuffs { get; set; }
+            public bool ShouldResetCooldowns { get; set; }
+            public bool ShouldTeleport { get; set; }
+        }
+
+        /// <summary>
+        /// Context data passed to lifecycle actions.
+        /// </summary>
+        public class LifecycleContext
+        {
+            public Entity UserEntity { get; set; }
+            public Entity CharacterEntity { get; set; }
+            public string ZoneId { get; set; }
+            public Dictionary<string, object> StoredData { get; set; } = new Dictionary<string, object>();
+            public float3 Position { get; set; }
+        }
+    }
+
+    /// <summary>
+    /// Base interface for lifecycle action handlers.
+    /// </summary>
+    public interface ILifecycleActionHandler
+    {
+        bool Execute(LifecycleModels.LifecycleAction action, LifecycleModels.LifecycleContext context);
+    }
+
+    /// <summary>
+    /// Result enum for spellbook granting operations.
+    /// </summary>
+    public enum GrantResult
+    {
+        Success,
+        InventoryFull,
+        AlreadyOwned,
+        Failed
+    }
+
+    /// <summary>
+    /// Result enum for VBlood unlock operations.
+    /// </summary>
+    public enum UnlockResult
+    {
+        Success,
+        AlreadyUnlocked,
+        Failed,
+        ConditionsNotMet
+    }
+
+    /// <summary>
+    /// Zone definition for ECS-based tracking.
+    /// </summary>
+    public struct ZoneDefinition
+    {
+        public Entity ZoneEntity;
+        public float3 Center;
+        public float Radius;
+        public string ZoneId;
+        public bool IsLifecycleZone;
+    }
+
+    /// <summary>
+    /// Player zone state for event bridge.
+    /// </summary>
+    public class PlayerZoneState
+    {
+        public string CurrentZoneId { get; set; }
+        public string PreviousZoneId { get; set; }
+        public bool WasInZone { get; set; }
+        public DateTime? EnteredAt { get; set; }
+        public DateTime? ExitedAt { get; set; }
+    }
+}
+
+/// <summary>
+/// Core static class for VAutoZone Lifecycle providing access to game systems and lifecycle patterns.
+/// Consolidates functionality from Vlifecycle patterns for unified lifecycle management.
+/// </summary>
+public static class LifecycleCore
+{
+    private static bool _isInitialized;
+    private static ManualLogSource _log;
+    
+    public static ManualLogSource Log => _log ??= ZoneCore.Log;
+    public static EntityManager EntityManager => ZoneCore.EntityManager;
+    public static World Server => ZoneCore.Server;
+    
+    /// <summary>
+    /// Indicates whether LifecycleCore has been initialized.
+    /// </summary>
+    public static bool IsInitialized => _isInitialized;
+
+    /// <summary>
+    /// Initialize the lifecycle core system.
+    /// </summary>
+    public static void Initialize()
+    {
+        if (_isInitialized) return;
+        _isInitialized = true;
+        Log.LogInfo("[LifecycleCore] Initialized");
+    }
+
+    /// <summary>
+    /// Shutdown the lifecycle core system.
+    /// </summary>
+    public static void Shutdown()
+    {
+        _isInitialized = false;
+        Log.LogInfo("[LifecycleCore] Shutdown");
+    }
+
+    #region Logging Extensions
+
+    public static void LogInfo(string message) => Log.LogInfo($"[LifecycleCore] {message}");
+    public static void LogWarning(string message) => Log.LogWarning($"[LifecycleCore] {message}");
+    public static void LogError(string message) => Log.LogError($"[LifecycleCore] {message}");
+    public static void LogDebug(string message) => Log.LogDebug($"[LifecycleCore] {message}");
+
+    #endregion
+
+    #region Entity Utilities
+
+    public static float3 GetPosition(Entity entity)
+    {
+        return ZoneCore.GetPosition(entity);
+    }
+
+    public static void SetPosition(Entity entity, float3 position)
+    {
+        ZoneCore.SetPosition(entity, position);
+    }
+
+    public static Entity GetCharacterFromUser(Entity user)
+    {
+        // Placeholder - would need game-specific implementation
+        return Entity.Null;
+    }
+
+    #endregion
+}
diff --git a/Bluelock/Core/PrefabResolver.cs b/Bluelock/Core/PrefabResolver.cs
index 09328ca..9d6b0ba 100644
--- a/Bluelock/Core/PrefabResolver.cs
+++ b/Bluelock/Core/PrefabResolver.cs
@@ -23,8 +23,8 @@ namespace VAuto.Zone.Core
         private static readonly Dictionary<string, PrefabGUID> ByName = new(StringComparer.OrdinalIgnoreCase);
         private static readonly Dictionary<string, PrefabGUID> ByAlias = new(StringComparer.OrdinalIgnoreCase);
 
-        private static string PrefabsRefPath => Path.Combine(Paths.ConfigPath, "Bluelock", "Bluelock.prefabs.json");
-        private static string AbilityPrefabsPath => Path.Combine(Paths.ConfigPath, "Bluelock", "Bluelock.ability_prefabs.json");
+        private static string PrefabsRefPath => Path.Combine(Paths.ConfigPath, "Bluelock", "Prefabsref.json");
+        private static string AbilityPrefabsPath => Path.Combine(Paths.ConfigPath, "Bluelock", "ability_prefabs.json");
 
         public static string PrefabsRefConfigPath => PrefabsRefPath;
         public static string AbilityAliasConfigPath => AbilityPrefabsPath;
diff --git a/Bluelock/Models/TemplateSnapshot.cs b/Bluelock/Models/TemplateSnapshot.cs
index eb8dc1a..053630e 100644
--- a/Bluelock/Models/TemplateSnapshot.cs
+++ b/Bluelock/Models/TemplateSnapshot.cs
@@ -6,7 +6,7 @@ namespace VAuto.Zone.Models
 {
     public sealed class TemplateSnapshot
     {
-        [JsonPropertyName("Z1")]
+        [JsonPropertyName("name")]
         public string Name { get; set; } = string.Empty;
 
         [JsonPropertyName("entities")]
@@ -18,7 +18,7 @@ namespace VAuto.Zone.Models
         [JsonPropertyName("prefabName")]
         public string PrefabName { get; set; } = string.Empty;
 
-        [JsonPropertyName("prefab _Guid")]
+        [JsonPropertyName("prefabGuid")]
         public int PrefabGuid { get; set; }
 
         [JsonPropertyName("offset")]
diff --git a/Bluelock/Models/ZoneDefinition.cs b/Bluelock/Models/ZoneDefinition.cs
index 361d961..da73fe3 100644
--- a/Bluelock/Models/ZoneDefinition.cs
+++ b/Bluelock/Models/ZoneDefinition.cs
@@ -1,4 +1,3 @@
-#nullable enable
 using System;
 using System.Collections.Generic;
 using System.Text.Json.Serialization;
@@ -11,15 +10,6 @@ namespace VAuto.Zone.Models
     /// </summary>
     public class ZoneDefinition
     {
-        /// <summary>
-        /// Supported zone shape types.
-        /// </summary>
-        public static class ShapeConstants
-        {
-            public const string Circle = "Circle";
-            public const string Rectangle = "Rectangle";
-        }
-
         /// <summary>
         /// Unique identifier for the zone.
         /// </summary>
@@ -28,7 +18,7 @@ namespace VAuto.Zone.Models
         /// <summary>
         /// Optional tags used to drive behavior (e.g. "sandbox").
         /// </summary>
-        public List<string> Tags { get; set; } = new();
+        public List<string> Tags { get; set; } = new List<string>();
 
         /// <summary>
         /// Display name for the zone.
@@ -36,9 +26,9 @@ namespace VAuto.Zone.Models
         public string DisplayName { get; set; } = string.Empty;
 
         /// <summary>
-        /// Shape of the zone. Supported: Circle (default), Rectangle.
+        /// Shape of the zone (e.g., "Circle").
         /// </summary>
-        public string Shape { get; set; } = ShapeConstants.Circle;
+        public string Shape { get; set; } = "Circle";
 
         /// <summary>
         /// Center X coordinate of the zone.
@@ -55,12 +45,6 @@ namespace VAuto.Zone.Models
         /// </summary>
         public float CenterZ { get; set; }
 
-        /// <summary>
-        /// Gets the center position as a float3 vector.
-        /// </summary>
-        [JsonIgnore]
-        public float3 Center => new float3(CenterX, CenterY, CenterZ);
-
         /// <summary>
         /// Radius of the zone (for circular zones).
         /// </summary>
@@ -89,19 +73,12 @@ namespace VAuto.Zone.Models
         /// <summary>
         /// Kit ID to apply when entering this zone (legacy name).
         /// </summary>
-        public string? KitToApplyId { get; set; }
+        public string KitToApplyId { get; set; }
 
         /// <summary>
         /// Kit ID to apply when entering this zone (preferred).
         /// </summary>
-        public string? KitId { get; set; }
-
-        /// <summary>
-        /// Gets the effective kit ID, preferring the new property over legacy.
-        /// Returns null if neither is set.
-        /// </summary>
-        [JsonIgnore]
-        public string? EffectiveKitId => KitId ?? KitToApplyId;
+        public string KitId { get; set; }
 
         /// <summary>
         /// Optional ability preset slots for this zone (T, C, R, SPACE).
@@ -115,228 +92,110 @@ namespace VAuto.Zone.Models
         /// </summary>
         public bool? SandboxUnlockEnabled { get; set; }
 
-        // ====== BACKWARD COMPATIBILITY PROPERTIES ======
-        // These preserve JSON config compatibility with older versions.
-        // They are mapped to the new nested config classes.
-
-        /// <summary>
-        /// Glow effect color in hex format (e.g., "#FF0000"). Use <see cref="Glow.EffectColorHex"/> instead.
-        /// </summary>
-        [JsonPropertyName("GlowEffectColorHex")]
-        public string? GlowEffectColorHex
-        {
-            get => Glow.EffectColorHex;
-            set => Glow.EffectColorHex = value;
-        }
-
-        /// <summary>
-        /// Prefab ID for the glow effect. Use <see cref="Glow.PrefabId"/> instead.
-        /// </summary>
-        [JsonPropertyName("GlowPrefabId")]
-        public int GlowPrefabId
-        {
-            get => Glow.PrefabId;
-            set => Glow.PrefabId = value;
-        }
-
-        /// <summary>
-        /// Prefab name for the glow effect. Use <see cref="Glow.Prefab"/> instead.
-        /// </summary>
-        [JsonPropertyName("GlowPrefab")]
-        public string? GlowPrefab
-        {
-            get => Glow.Prefab;
-            set => Glow.Prefab = value;
-        }
-
         /// <summary>
-        /// Prefab ID for the border glow effect. Use <see cref="Glow.BorderPrefabId"/> instead.
+        /// Glow effect color in hex format (e.g., "#FF0000").
         /// </summary>
-        [JsonPropertyName("BorderGlowPrefabId")]
-        public int BorderGlowPrefabId
-        {
-            get => Glow.BorderPrefabId;
-            set => Glow.BorderPrefabId = value;
-        }
+        public string GlowEffectColorHex { get; set; }
 
         /// <summary>
-        /// Prefab name for the border glow effect. Use <see cref="Glow.BorderPrefab"/> instead.
+        /// Prefab ID for the glow effect.
         /// </summary>
-        [JsonPropertyName("BorderGlowPrefab")]
-        public string? BorderGlowPrefab
-        {
-            get => Glow.BorderPrefab;
-            set => Glow.BorderPrefab = value;
-        }
+        public int GlowPrefabId { get; set; }
 
         /// <summary>
-        /// Height at which to spawn glow effects. Use <see cref="Glow.SpawnHeight"/> instead.
+        /// Prefab name for the glow effect.
         /// </summary>
-        [JsonPropertyName("GlowSpawnHeight")]
-        public float GlowSpawnHeight
-        {
-            get => Glow.SpawnHeight;
-            set => Glow.SpawnHeight = value;
-        }
+        public string GlowPrefab { get; set; }
 
         /// <summary>
-        /// Whether to automatically apply glow with zone. Use <see cref="Glow.AutoGlowWithZone"/> instead.
+        /// Prefab ID for the border glow effect.
         /// </summary>
-        [JsonPropertyName("AutoGlowWithZone")]
-        public bool AutoGlowWithZone
-        {
-            get => Glow.AutoGlowWithZone;
-            set => Glow.AutoGlowWithZone = value;
-        }
+        public int BorderGlowPrefabId { get; set; }
 
         /// <summary>
-        /// Optional prefab name for the glow tile grid. Use <see cref="GlowTile.Prefab"/> instead.
+        /// Prefab name for the border glow effect.
         /// </summary>
-        [JsonPropertyName("GlowTilePrefab")]
-        public string? GlowTilePrefab
-        {
-            get => GlowTile.Prefab;
-            set => GlowTile.Prefab = value ?? string.Empty;
-        }
+        public string BorderGlowPrefab { get; set; }
 
         /// <summary>
-        /// Optional prefab GUID hash for the glow tile grid. Use <see cref="GlowTile.PrefabId"/> instead.
+        /// Height at which to spawn glow effects.
         /// </summary>
-        [JsonPropertyName("GlowTilePrefabId")]
-        public int GlowTilePrefabId
-        {
-            get => GlowTile.PrefabId;
-            set => GlowTile.PrefabId = value;
-        }
+        public float GlowSpawnHeight { get; set; }
 
         /// <summary>
-        /// Spacing in meters between glow tiles. Use <see cref="GlowTile.Spacing"/> instead.
+        /// Whether to automatically apply glow with zone.
         /// </summary>
-        [JsonPropertyName("GlowTileSpacing")]
-        public float GlowTileSpacing
-        {
-            get => GlowTile.Spacing;
-            set => GlowTile.Spacing = value;
-        }
+        public bool AutoGlowWithZone { get; set; }
 
         /// <summary>
-        /// Height offset for glow tiles. Use <see cref="GlowTile.HeightOffset"/> instead.
+        /// Optional prefab name for the glow tile grid (per-zone override).
         /// </summary>
-        [JsonPropertyName("GlowTileHeightOffset")]
-        public float GlowTileHeightOffset
-        {
-            get => GlowTile.HeightOffset;
-            set => GlowTile.HeightOffset = value;
-        }
+        public string GlowTilePrefab { get; set; } = string.Empty;
 
         /// <summary>
-        /// Rotation offset for glow tiles. Use <see cref="GlowTile.RotationDegrees"/> instead.
+        /// Optional prefab GUID hash for the glow tile grid (numeric fallback).
         /// </summary>
-        [JsonPropertyName("GlowTileRotationDegrees")]
-        public float GlowTileRotationDegrees
-        {
-            get => GlowTile.RotationDegrees;
-            set => GlowTile.RotationDegrees = value;
-        }
+        public int GlowTilePrefabId { get; set; }
 
         /// <summary>
-        /// Whether glow tiles are enabled. Use <see cref="GlowTile.Enabled"/> instead.
+        /// Spacing in meters between glow tiles along the zone border/grid.
         /// </summary>
-        [JsonPropertyName("GlowTileEnabled")]
-        public bool GlowTileEnabled
-        {
-            get => GlowTile.Enabled;
-            set => GlowTile.Enabled = value;
-        }
+        public float GlowTileSpacing { get; set; } = 3f;
 
         /// <summary>
-        /// Auto spawn glow tiles on enter. Use <see cref="GlowTile.AutoSpawnOnEnter"/> instead.
+        /// Height offset applied to glow tiles above the zone center/terrain.
         /// </summary>
-        [JsonPropertyName("GlowTileAutoSpawnOnEnter")]
-        public bool GlowTileAutoSpawnOnEnter
-        {
-            get => GlowTile.AutoSpawnOnEnter;
-            set => GlowTile.AutoSpawnOnEnter = value;
-        }
+        public float GlowTileHeightOffset { get; set; } = 0.3f;
 
         /// <summary>
-        /// Auto spawn glow tiles on reset. Use <see cref="GlowTile.AutoSpawnOnReset"/> instead.
+        /// Rotation offset in degrees applied when distributing glow tiles.
         /// </summary>
-        [JsonPropertyName("GlowTileAutoSpawnOnReset")]
-        public bool GlowTileAutoSpawnOnReset
-        {
-            get => GlowTile.AutoSpawnOnReset;
-            set => GlowTile.AutoSpawnOnReset = value;
-        }
+        public float GlowTileRotationDegrees { get; set; }
 
         /// <summary>
-        /// Whether to teleport on enter. Use <see cref="Teleport.Enabled"/> instead.
+        /// Whether glow tiles should spawn for this zone.
         /// </summary>
-        [JsonPropertyName("TeleportOnEnter")]
-        public bool TeleportOnEnter
-        {
-            get => Teleport.Enabled;
-            set => Teleport.Enabled = value;
-        }
+        public bool GlowTileEnabled { get; set; } = true;
 
         /// <summary>
-        /// X coordinate for teleport. Use <see cref="Teleport.X"/> instead.
+        /// Should glow tiles auto spawn when the zone is activated (first player enters).
         /// </summary>
-        [JsonPropertyName("TeleportX")]
-        public float TeleportX
-        {
-            get => Teleport.X;
-            set => Teleport.X = value;
-        }
+        public bool GlowTileAutoSpawnOnEnter { get; set; } = true;
 
         /// <summary>
-        /// Y coordinate for teleport. Use <see name="Teleport.Y"/> instead.
+        /// Should glow tiles automatically clear/reset when the zone becomes empty.
         /// </summary>
-        [JsonPropertyName("TeleportY")]
-        public float TeleportY
-        {
-            get => Teleport.Y;
-            set => Teleport.Y = value;
-        }
+        public bool GlowTileAutoSpawnOnReset { get; set; } = true;
 
         /// <summary>
-        /// Z coordinate for teleport. Use <see name="Teleport.Z"/> instead.
+        /// Message to display when entering the zone.
         /// </summary>
-        [JsonPropertyName("TeleportZ")]
-        public float TeleportZ
-        {
-            get => Teleport.Z;
-            set => Teleport.Z = value;
-        }
-
-        // ====== NEW NESTED CONFIG CLASSES ======
+        public string EnterMessage { get; set; }
 
         /// <summary>
-        /// Glow effect configuration for this zone.
+        /// Message to display when exiting the zone.
         /// </summary>
-        public GlowConfig Glow { get; set; } = new();
+        public string ExitMessage { get; set; }
 
         /// <summary>
-        /// Glow tile configuration for this zone.
+        /// Whether to teleport player on zone enter.
         /// </summary>
-        public GlowTileConfig GlowTile { get; set; } = new();
+        public bool TeleportOnEnter { get; set; }
 
         /// <summary>
-        /// Teleport configuration for this zone.
+        /// X coordinate for teleport destination.
         /// </summary>
-        public TeleportConfig Teleport { get; set; } = new();
-
-        // ====== REMAINING PROPERTIES ======
+        public float TeleportX { get; set; }
 
         /// <summary>
-        /// Message to display when entering the zone.
+        /// Y coordinate for teleport destination.
         /// </summary>
-        public string? EnterMessage { get; set; }
+        public float TeleportY { get; set; }
 
         /// <summary>
-        /// Message to display when exiting the zone.
+        /// Z coordinate for teleport destination.
         /// </summary>
-        public string? ExitMessage { get; set; }
+        public float TeleportZ { get; set; }
 
         /// <summary>
         /// Whether to return player to original position on zone exit.
@@ -346,30 +205,24 @@ namespace VAuto.Zone.Models
         /// <summary>
         /// Border spawning configuration (authoritative for zone borders).
         /// </summary>
-        public ZoneBorderConfig? Border { get; set; }
+        public ZoneBorderConfig Border { get; set; }
 
         /// <summary>
         /// List of schematic IDs granted in this zone.
         /// </summary>
-        public List<string> Schematics { get; set; } = new();
+        public List<string> Schematics { get; set; } = new List<string>();
 
         /// <summary>
         /// Legacy template list for backward compatibility.
         /// </summary>
         [JsonPropertyName("templateList")]
-        public List<string> LegacyTemplates { get; set; } = new();
+        public List<string> LegacyTemplates { get; set; } = new List<string>();
 
         /// <summary>
         /// Typed template map for the zone (e.g. arenaTM, trapTM, bossTM).
         /// </summary>
         [JsonPropertyName("templates")]
-        public Dictionary<string, string> Templates { get; set; } = new(StringComparer.OrdinalIgnoreCase);
-
-        /// <summary>
-        /// When true, template runtime entities are tracked per dedicated instance key (for example clan instance).
-        /// </summary>
-        [JsonPropertyName("dedicated")]
-        public bool Dedicated { get; set; }
+        public Dictionary<string, string> Templates { get; set; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// Character name of the zone holder (for arena damage immunity).
@@ -385,197 +238,19 @@ namespace VAuto.Zone.Models
         public bool IsArenaZone { get; set; }
 
         /// <summary>
-        /// Check if a position is inside this zone based on the current shape.
+        /// Check if a position is inside this zone.
         /// </summary>
-        /// <param name="x">X coordinate to check.</param>
-        /// <param name="z">Z coordinate to check.</param>
-        /// <returns>True if the position is inside the zone, false otherwise.</returns>
         public bool IsInside(float x, float z)
         {
-            return Shape.ToUpperInvariant() switch
-            {
-                "CIRCLE" => IsInsideCircle(x, z),
-                "RECTANGLE" => IsInsideRectangle(x, z),
-                _ => IsInsideCircle(x, z) // Default to circle for unknown shapes
-            };
-        }
-
-        /// <summary>
-        /// Validates the zone configuration and returns any validation errors.
-        /// </summary>
-        /// <returns>List of validation error messages, or empty if valid.</returns>
-        public List<string> Validate()
-        {
-            var errors = new List<string>();
-
-            if (string.IsNullOrWhiteSpace(Id))
+            if (Shape.Equals("Circle", StringComparison.OrdinalIgnoreCase))
             {
-                errors.Add("Zone Id is required.");
+                var dx = x - CenterX;
+                var dz = z - CenterZ;
+                return (dx * dx + dz * dz) <= (Radius * Radius);
             }
-
-            var isCircle = Shape.Equals(ShapeConstants.Circle, StringComparison.OrdinalIgnoreCase);
-            var isRectangle = Shape.Equals(ShapeConstants.Rectangle, StringComparison.OrdinalIgnoreCase);
-
-            if (!isCircle && !isRectangle)
-            {
-                errors.Add($"Invalid shape '{Shape}'. Supported shapes: {ShapeConstants.Circle}, {ShapeConstants.Rectangle}");
-            }
-
-            if (isCircle && Radius <= 0)
-            {
-                errors.Add($"Circular zone '{Id}' must have a positive radius.");
-            }
-
-            if (isRectangle)
-            {
-                if (MinX >= MaxX)
-                {
-                    errors.Add($"Rectangular zone '{Id}' must have MinX less than MaxX.");
-                }
-                if (MinZ >= MaxZ)
-                {
-                    errors.Add($"Rectangular zone '{Id}' must have MinZ less than MaxZ.");
-                }
-            }
-
-            return errors;
+            // Default to circle for unknown shapes
+            var dist = math.distance(new float2(x, z), new float2(CenterX, CenterZ));
+            return dist <= Radius;
         }
-
-        private bool IsInsideCircle(float x, float z)
-        {
-            var dx = x - CenterX;
-            var dz = z - CenterZ;
-            return (dx * dx + dz * dz) <= (Radius * Radius);
-        }
-
-        private bool IsInsideRectangle(float x, float z)
-        {
-            return x >= MinX && x <= MaxX && z >= MinZ && z <= MaxZ;
-        }
-    }
-
-    /// <summary>
-    /// Configuration for zone glow effects.
-    /// </summary>
-    public class GlowConfig
-    {
-        /// <summary>
-        /// Glow effect color in hex format (e.g., "#FF0000").
-        /// </summary>
-        public string? EffectColorHex { get; set; }
-
-        /// <summary>
-        /// Prefab ID for the glow effect.
-        /// </summary>
-        public int PrefabId { get; set; }
-
-        /// <summary>
-        /// Prefab name for the glow effect.
-        /// </summary>
-        public string? Prefab { get; set; }
-
-        /// <summary>
-        /// Prefab ID for the border glow effect.
-        /// </summary>
-        public int BorderPrefabId { get; set; }
-
-        /// <summary>
-        /// Prefab name for the border glow effect.
-        /// </summary>
-        public string? BorderPrefab { get; set; }
-
-        /// <summary>
-        /// Height at which to spawn glow effects.
-        /// </summary>
-        public float SpawnHeight { get; set; }
-
-        /// <summary>
-        /// Whether to automatically apply glow with zone.
-        /// </summary>
-        public bool AutoGlowWithZone { get; set; }
-    }
-
-    /// <summary>
-    /// Configuration for zone glow tiles.
-    /// </summary>
-    public class GlowTileConfig
-    {
-        /// <summary>
-        /// Optional prefab name for the glow tile grid (per-zone override).
-        /// </summary>
-        public string Prefab { get; set; } = string.Empty;
-
-        /// <summary>
-        /// Optional prefab GUID hash for the glow tile grid (numeric fallback).
-        /// </summary>
-        public int PrefabId { get; set; }
-
-        /// <summary>
-        /// Spacing in meters between glow tiles along the zone border/grid.
-        /// </summary>
-        public float Spacing { get; set; } = 3f;
-
-        /// <summary>
-        /// Height offset applied to glow tiles above the zone center/terrain.
-        /// </summary>
-        public float HeightOffset { get; set; } = 0.3f;
-
-        /// <summary>
-        /// Rotation offset in degrees applied when distributing glow tiles.
-        /// </summary>
-        public float RotationDegrees { get; set; }
-
-        /// <summary>
-        /// Whether glow tiles should spawn for this zone.
-        /// </summary>
-        public bool Enabled { get; set; } = true;
-
-        /// <summary>
-        /// Should glow tiles auto spawn when the zone is activated (first player enters).
-        /// </summary>
-        public bool AutoSpawnOnEnter { get; set; } = true;
-
-        /// <summary>
-        /// Should glow tiles automatically clear/reset when the zone becomes empty.
-        /// </summary>
-        public bool AutoSpawnOnReset { get; set; } = true;
-    }
-
-    /// <summary>
-    /// Configuration for zone teleportation.
-    /// </summary>
-    public class TeleportConfig
-    {
-        /// <summary>
-        /// Whether to teleport player on zone enter.
-        /// </summary>
-        public bool Enabled { get; set; }
-
-        /// <summary>
-        /// X coordinate for teleport destination.
-        /// </summary>
-        public float X { get; set; }
-
-        /// <summary>
-        /// Y coordinate for teleport destination.
-        /// </summary>
-        public float Y { get; set; }
-
-        /// <summary>
-        /// Z coordinate for teleport destination.
-        /// </summary>
-        public float Z { get; set; }
-
-        /// <summary>
-        /// Gets the teleport destination as a float3 vector.
-        /// </summary>
-        [JsonIgnore]
-        public float3 Destination => new float3(X, Y, Z);
-
-        /// <summary>
-        /// Gets whether a valid teleport destination is configured.
-        /// </summary>
-        [JsonIgnore]
-        public bool HasDestination => X != 0 || Y != 0 || Z != 0;
     }
 }
diff --git a/Bluelock/Patches/DropInventorySystemPatch.cs b/Bluelock/Patches/DropInventorySystemPatch.cs
new file mode 100644
index 0000000..0197a00
--- /dev/null
+++ b/Bluelock/Patches/DropInventorySystemPatch.cs
@@ -0,0 +1,74 @@
+using System;
+using System.Runtime.InteropServices;
+using HarmonyLib;
+using ProjectM;
+using ProjectM.Shared;
+using Stunlock.Core;
+using Unity.Entities;
+using Unity.Transforms;
+using VAuto.Zone.Core;
+using VAuto.Zone.Services;
+
+namespace VAuto.Zone.ArenaPatches
+{
+    [HarmonyPatch(typeof(DropInventorySystem), nameof(DropInventorySystem.DropItem))]
+    internal static class DropInventorySystemPatch
+    {
+        [HarmonyPrefix]
+        private static bool Prefix(
+            DropInventorySystem __instance,
+            EntityCommandBuffer commandBuffer,
+            [In] ref Translation translation,
+            PrefabGUID itemHash,
+            int amount,
+            Entity itemEntity,
+            Il2CppSystem.Nullable_Unboxed<float> customDropArc,
+            Il2CppSystem.Nullable_Unboxed<float> minRange,
+            Il2CppSystem.Nullable_Unboxed<float> maxRange)
+        {
+            try
+            {
+                var em = ZoneCore.EntityManager;
+                if (em == default || itemEntity == Entity.Null || !em.Exists(itemEntity))
+                {
+                    return true;
+                }
+
+                if (!em.HasComponent<EntityOwner>(itemEntity))
+                {
+                    return true;
+                }
+
+                var owner = em.GetComponentData<EntityOwner>(itemEntity).Owner;
+                if (owner == Entity.Null || !em.Exists(owner))
+                {
+                    return true;
+                }
+
+                var now = System.DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() / 1000d;
+                if (ArenaDeathTracker.TryGetRecentArenaDeath(owner, now, out _))
+                {
+                    // Cancel vanilla drop for arena-caused deaths.
+                    return false;
+                }
+
+                // Cancel vanilla drop for any player currently inside a configured zone.
+                var zoneState = VAutomationCore.Services.ZoneEventBridge.GetPlayerZoneState(owner);
+                if (zoneState != null && !string.IsNullOrWhiteSpace(zoneState.CurrentZoneId))
+                {
+                    var zone = ZoneConfigService.GetZoneById(zoneState.CurrentZoneId);
+                    if (zone != null)
+                    {
+                        return false;
+                    }
+                }
+            }
+            catch (System.Exception ex)
+            {
+                ZoneCore.LogWarning($"[ArenaLoot] Drop hook failed: {ex.Message}");
+            }
+
+            return true;
+        }
+    }
+}
diff --git a/Bluelock/Plugin.cs b/Bluelock/Plugin.cs
index 2f35c28..b606dde 100644
--- a/Bluelock/Plugin.cs
+++ b/Bluelock/Plugin.cs
@@ -26,24 +26,23 @@ using VAuto.Zone.Core;
 using VAuto.Zone.Core.Components;
 using VAuto.Zone.Models;
 using VAutomationCore.Core;
+using VAutomationCore.Core.Arena;
 using VAutomationCore.Core.Config;
 using VAutomationCore.Core.Lifecycle;
 using VAutomationCore.Core.Services;
 using VAutomationCore.Core.Logging;
-using VAuto.Zone.Services.Lifecycle;
-using VLifecycle;
 
 namespace VAuto.Zone
 {
     [BepInPlugin("gg.coyote.BlueLock", "BlueLock", "1.0.0")]
     [BepInDependency("gg.coyote.VAutomationCore", "1.0.0")]
     [BepInDependency("gg.deca.VampireCommandFramework", "0.10.4")]
-    [BepInDependency("gg.coyote.Circleborn", "1.0.1")]
+    [BepInDependency("gg.coyote.lifecycle", "1.0.0")]
     [BepInProcess("VRisingServer.exe")]
-    public class Plugin : BasePlugin 
+    public class Plugin : BasePlugin
     {
         #region Logging
-        private static readonly ManualLogSource _staticLog = BepInEx.Logging.Logger.CreateLogSource("_Hormony");
+        private static readonly ManualLogSource _staticLog = BepInEx.Logging.Logger.CreateLogSource("BlueLock");
         public static ManualLogSource Logger => _staticLog;
         public static CoreLogger CoreLog { get; private set; }
         #endregion
@@ -128,6 +127,7 @@ namespace VAuto.Zone
         private static readonly bool TempDisableAbilityUiDuringZoneTransitions = true;
         private static readonly Dictionary<ulong, float3> _zoneReturnPositions = new();
         private static readonly Dictionary<ulong, PendingZoneTeleport> _pendingZoneEnterTeleports = new();
+        private static readonly Dictionary<string, Dictionary<string, List<Entity>>> _zoneTemplateEntities = new(StringComparer.OrdinalIgnoreCase);
         private static readonly PluginZoneLifecycleStepRegistry _zoneLifecycleStepRegistry = new();
 
         private struct PendingZoneTeleport
@@ -200,12 +200,12 @@ namespace VAuto.Zone
         {
             public IReadOnlyList<IZoneEnterStep> GetEnterSteps()
             {
-                return BuildEnterSteps(ArenaEnterLifecycleActions);
+                return BuildEnterSteps(DefaultEnterLifecycleActions);
             }
 
             public IReadOnlyList<IZoneExitStep> GetExitSteps()
             {
-                return BuildExitSteps(ArenaExitLifecycleActions);
+                return BuildExitSteps(DefaultExitLifecycleActions);
             }
 
             public IReadOnlyList<IZoneEnterStep> BuildEnterSteps(IEnumerable<string> actionTokens)
@@ -240,14 +240,6 @@ namespace VAuto.Zone
             public DateTime FirstSeenUtc { get; set; }
         }
 
-        private enum ZoneFlowProfile
-        {
-            Template,
-            Arena,
-            Boss,
-            Pvp
-        }
-
         private const double DefaultZoneEnterTransitionConfirmSeconds = 0.35d;
         private const double DefaultZoneExitTransitionConfirmSeconds = 0.75d;
         private const double DefaultZoneTransitionCooldownSeconds = 1.25d;
@@ -261,65 +253,33 @@ namespace VAuto.Zone
         private const int RebuildRequestCooldownSeconds = 5;
         private static readonly string[] LifecycleAssemblyNames = { "Cycleborn", "Vlifecycle" };
         private static readonly Dictionary<string, Type> LifecycleTypeCache = new(StringComparer.Ordinal);
-        private static readonly string[] TemplateEnterLifecycleActions =
-        {
-            "snapshot_save",
-            "apply_templates",
-            "apply_abilities"
-        };
-        private static readonly string[] TemplateExitLifecycleActions =
-        {
-            "restore_abilities",
-            "snapshot_restore"
-        };
-        private static readonly string[] ArenaEnterLifecycleActions =
-        {
-            "capture_return_position",
-            "snapshot_save",
-            "apply_kit",
-            "teleport_enter",
-            "apply_templates",
-            "apply_abilities"
-        };
-        private static readonly string[] ArenaExitLifecycleActions =
-        {
-            "restore_kit_snapshot",
-            "restore_abilities",
-            "teleport_return",
-            "snapshot_restore"
-        };
-        private static readonly string[] BossEnterLifecycleActions =
+        private static readonly string[] DefaultEnterLifecycleActions =
         {
             "capture_return_position",
             "snapshot_save",
+            "zone_enter_message",
             "apply_kit",
             "teleport_enter",
             "apply_templates",
             "apply_abilities",
-            "boss_enter"
+            "glow_spawn",
+            "boss_enter",
+            "integration_events_enter",
+            "announce_enter"
         };
-        private static readonly string[] BossExitLifecycleActions =
+        private static readonly string[] DefaultExitLifecycleActions =
         {
-            "boss_exit",
+            "zone_exit_message",
             "restore_kit_snapshot",
             "restore_abilities",
+            "boss_exit",
             "teleport_return",
-            "snapshot_restore"
-        };
-        private static readonly string[] PvpEnterLifecycleActions =
-        {
-            "snapshot_save",
-            "apply_kit",
-            "apply_templates",
-            "apply_abilities"
-        };
-        private static readonly string[] PvpExitLifecycleActions =
-        {
-            "restore_abilities",
-            "snapshot_restore"
+            "glow_reset",
+            "integration_events_exit"
         };
         private static volatile bool _pendingZoneBorderRebuild;
         private static float _lastZoneDetectionUpdateTime;
+        private static ArenaLifecycleManager _arenaLifecycleManager;
         private static EntityQuery _autoZonePlayerQuery;
         private static bool _autoZonePlayerQueryInitialized;
 
@@ -333,9 +293,9 @@ namespace VAuto.Zone
             try
             {
                 // Initialize configuration paths under the Bluelock root config folder
-                _configPath = ResolveBluelockConfigPath("Bluelock.lifecycle.json");
-                _zonesConfigPath = ResolveBluelockConfigPath("Bluelock.zones.json");
-                _kitsConfigPath = ResolveBluelockConfigPath("Bluelock.kits.json");
+                _configPath = ResolveBluelockConfigPath("VAuto.ZoneLifecycle.json");
+                _zonesConfigPath = ResolveBluelockConfigPath("VAuto.Zones.json");
+                _kitsConfigPath = ResolveBluelockConfigPath("VAuto.Kits.json");
 
                 // Bind CFG configuration
                 BindConfiguration();
@@ -360,21 +320,23 @@ namespace VAuto.Zone
                 ConfigureSandboxProgressionBridge();
 
                 _harmony = new Harmony("gg.coyote.BlueLock");
-                // Load VAutomationCore assembly and patch all types with Harmony annotations
+                _harmony.PatchAll(typeof(Patches));
+                // Patch additional arena loot suppression
                 try
                 {
-                    var coreAssembly = Assembly.Load("VAutomationCore");
-                    _harmony.PatchAll(coreAssembly);
-                    Logger.LogInfo("[BlueLock] Core patches applied successfully");
-                }
-                catch (Exception ex)
-                {
-                    Logger.LogWarning($"[BlueLock] Failed to load/patch VAutomationCore: {ex.Message}");
+                    var arenaPatchesType = typeof(Plugin).Assembly.GetType("VAuto.Zone.ArenaPatches.DropInventorySystemPatch");
+                    if (arenaPatchesType != null)
+                    {
+                        _harmony.PatchAll(arenaPatchesType);
+                    }
                 }
+                catch { }
                 
                 // Initialize CoreLogger and services
                 CoreLog = new CoreLogger("BlueLock");
+                _arenaLifecycleManager = new ArenaLifecycleManager(CoreLog);
                 VAutomationCore.Services.ZoneEventBridge.Initialize();
+                _arenaLifecycleManager.Initialize();
                 
                 // Initialize all services using ServiceInitializer
                 var servicesInitialized = ServiceInitializer.InitializeAll(CoreLog);
@@ -397,27 +359,19 @@ namespace VAuto.Zone
                     ZoneConfigService.Initialize();
                     Logger.LogInfo("ZoneConfigService initialized");
 
-                    // Initialize GlowZoneEntryService for loading scan files
-                    GlowZoneEntryService.Initialize();
-                    Logger.LogInfo("GlowZoneEntryService initialized");
-
                     // Initialize Zone boss spawner service
                     ZoneBossSpawnerService.Initialize();
                     Logger.LogInfo("ZoneBossSpawnerService initialized");
 
-                    // Initialize ability zone enter/exit binding service
-                    ConfigureAbilityZoneService();
-                    AbilityZoneService.Initialize();
-                    Logger.LogInfo("AbilityZoneService initialized");
+                    // Initialize ability UI enter/exit binding service
+                    ConfigureAbilityUi();
+                    AbilityUi.Initialize();
+                    Logger.LogInfo("AbilityUi initialized");
                     ZonePlayerTagService.Initialize(
                         msg => Logger.LogInfo($"[ZonePlayerTagService] {msg}"),
                         msg => Logger.LogWarning($"[ZonePlayerTagService] {msg}"));
                     Logger.LogInfo("ZonePlayerTagService initialized");
 
-                    // Initialize domain adapter registration into CycleBorn lifecycle registry.
-                    BluelockLifecycleAdapters.Initialize();
-                    Logger.LogInfo("BluelockLifecycleAdapters initialized");
-
                     // Queue border build to run on server update thread when world is ready.
                     ZoneGlowBorderService.QueueRebuild("startup");
                 }
@@ -466,14 +420,14 @@ namespace VAuto.Zone
             Logger.LogInfo("[BlueLock]   Command Roots: zone, arena, enter, exit");
         }
 
-        private static void ConfigureAbilityZoneService()
+        private static void ConfigureAbilityUi()
         {
-            AbilityZoneService.GetEntityManager = () => UnifiedCore.EntityManager;
-            AbilityZoneService.GetSteamId = ResolvePlatformId;
-            AbilityZoneService.ResolveAbilityGuid = ResolveAbilityGuid;
-            AbilityZoneService.LogInfo = message => Logger.LogInfo($"[AbilityZoneService] {message}");
-            AbilityZoneService.LogWarn = message => Logger.LogWarning($"[AbilityZoneService] {message}");
-            AbilityZoneService.LogError = message => Logger.LogError($"[AbilityZoneService] {message}");
+            AbilityUi.GetEntityManager = () => UnifiedCore.EntityManager;
+            AbilityUi.GetSteamId = ResolvePlatformId;
+            AbilityUi.ResolveAbilityGuid = ResolveAbilityGuid;
+            AbilityUi.LogInfo = message => Logger.LogInfo($"[AbilityUi] {message}");
+            AbilityUi.LogWarn = message => Logger.LogWarning($"[AbilityUi] {message}");
+            AbilityUi.LogError = message => Logger.LogError($"[AbilityUi] {message}");
         }
 
         private static PrefabGUID? ResolveAbilityGuid(string raw)
@@ -667,7 +621,7 @@ namespace VAuto.Zone
             _lastKitsConfigCheck = !KitService.IsLegacyKitsDisabled && File.Exists(KitsConfigPathValue)
                 ? File.GetLastWriteTime(KitsConfigPathValue)
                 : DateTime.MinValue;
-            _lastAbilityConfigCheck = File.Exists(AbilityZoneService.ConfigPath) ? File.GetLastWriteTime(AbilityZoneService.ConfigPath) : DateTime.MinValue;
+            _lastAbilityConfigCheck = File.Exists(AbilityUi.ConfigPath) ? File.GetLastWriteTime(AbilityUi.ConfigPath) : DateTime.MinValue;
             _lastPrefabsRefCheck = File.Exists(PrefabResolver.PrefabsRefConfigPath) ? File.GetLastWriteTime(PrefabResolver.PrefabsRefConfigPath) : DateTime.MinValue;
             _lastAbilityAliasCheck = File.Exists(PrefabResolver.AbilityAliasConfigPath) ? File.GetLastWriteTime(PrefabResolver.AbilityAliasConfigPath) : DateTime.MinValue;
             _hotReloadTimer = new System.Timers.Timer(5000);
@@ -720,13 +674,13 @@ namespace VAuto.Zone
                     }
                 }
 
-                if (File.Exists(AbilityZoneService.ConfigPath))
+                if (File.Exists(AbilityUi.ConfigPath))
                 {
-                    var abilityLastModified = File.GetLastWriteTime(AbilityZoneService.ConfigPath);
+                    var abilityLastModified = File.GetLastWriteTime(AbilityUi.ConfigPath);
                     if (abilityLastModified > _lastAbilityConfigCheck)
                     {
                         _lastAbilityConfigCheck = abilityLastModified;
-                        AbilityZoneService.Reload();
+                        AbilityUi.Reload();
                         Logger.LogInfo("[BlueLock] Ability zone config hot-reloaded");
                     }
                 }
@@ -760,7 +714,7 @@ namespace VAuto.Zone
                     {
                         _lastAbilityAliasCheck = abilityAliasLast;
                         PrefabResolver.Reload();
-                        AbilityZoneService.Reload();
+                        AbilityUi.Reload();
                         Logger.LogInfo("[BlueLock] Ability alias catalog hot-reloaded.");
                     }
                 }
@@ -962,7 +916,13 @@ namespace VAuto.Zone
         {
             _hotReloadTimer?.Dispose();
             _hotReloadTimer = null;
-            // Legacy arena lifecycle manager removed; lifecycle orchestration is externalized.
+            try
+            {
+                _arenaLifecycleManager?.Shutdown();
+            }
+            catch
+            {
+            }
             try
             {
                 _autoZonePlayerQuery.Dispose();
@@ -1682,7 +1642,7 @@ namespace VAuto.Zone
                     _lastCommittedZoneTransitions.Remove(stale);
                     _playerZoneLocks.Remove(stale);
                     KitService.ClearPlayerTrackingForEntity(stale, em);
-                    AbilityZoneService.ClearStateForDisconnectedPlayer(stale, em);
+                    AbilityUi.ClearStateForDisconnectedPlayer(stale, em);
                     VAutomationCore.Services.ZoneEventBridge.RemovePlayerZoneState(stale);
                 }
             }
@@ -2235,26 +2195,6 @@ namespace VAuto.Zone
                     return;
                 }
 
-                var zone = ZoneConfigService.GetZoneById(zoneId);
-
-                if (zone != null && zone.Dedicated)
-                {
-                    var dedicatedResults = ZoneTemplateService.SpawnAllZoneTemplates(zoneId, em, player);
-                    foreach (var dedicatedResult in dedicatedResults)
-                    {
-                        if (!dedicatedResult.Success)
-                        {
-                            Logger.LogWarning($"[BlueLock] Zone '{zoneId}' template '{dedicatedResult.TemplateType}' failed: {dedicatedResult.Error}");
-                        }
-                        else
-                        {
-                            Logger.LogInfo($"[BlueLock] Zone '{zoneId}' applied dedicated template '{dedicatedResult.TemplateType}'");
-                        }
-                    }
-
-                    return;
-                }
-
                 foreach (var template in templates)
                 {
                     var isSchematic = ZoneSchematicLoader.TryGetSchematicPath(template) != null ||
@@ -2277,6 +2217,7 @@ namespace VAuto.Zone
                         // Template placement can trigger spawn-chain side effects; skip InitializeNewSpawnChainSystem once to reduce racey transitions.
                         // This mirrors common KindredSchematics mitigation patterns.
                         Patches.SkipInitializeNewSpawnChainOnce = true;
+                        var zone = ZoneConfigService.GetZoneById(zoneId);
                         var origin = zone != null
                             ? new float3(zone.CenterX, zone.CenterY, zone.CenterZ)
                             : float3.zero;
@@ -2460,19 +2401,13 @@ namespace VAuto.Zone
 
         private static IReadOnlyList<string> ResolveLifecycleActionsForZone(string zoneId, bool isEnter)
         {
-            var defaults = ResolveZoneFlowDefaults(zoneId, isEnter);
+            var defaults = isEnter ? DefaultEnterLifecycleActions : DefaultExitLifecycleActions;
             if (_jsonConfig == null || !_jsonConfig.Enabled || _jsonConfig.Mappings == null || _jsonConfig.Mappings.Count == 0)
             {
                 return defaults;
             }
 
-            if (!TryGetLifecycleMappingForZone(zoneId, out var mapping, out var matchedWildcard))
-            {
-                return defaults;
-            }
-
-            // Wildcard mapping is treated as legacy fallback. Canonical zone-flow defaults are authoritative.
-            if (matchedWildcard)
+            if (!TryGetLifecycleMappingForZone(zoneId, out var mapping))
             {
                 return defaults;
             }
@@ -2506,84 +2441,9 @@ namespace VAuto.Zone
             return resolved.Count > 0 ? resolved : defaults;
         }
 
-        private static IReadOnlyList<string> ResolveZoneFlowDefaults(string zoneId, bool isEnter)
-        {
-            var profile = ResolveZoneFlowProfile(zoneId);
-            return profile switch
-            {
-                ZoneFlowProfile.Template => isEnter ? TemplateEnterLifecycleActions : TemplateExitLifecycleActions,
-                ZoneFlowProfile.Boss => isEnter ? BossEnterLifecycleActions : BossExitLifecycleActions,
-                ZoneFlowProfile.Pvp => isEnter ? PvpEnterLifecycleActions : PvpExitLifecycleActions,
-                _ => isEnter ? ArenaEnterLifecycleActions : ArenaExitLifecycleActions
-            };
-        }
-
-        private static ZoneFlowProfile ResolveZoneFlowProfile(string zoneId)
-        {
-            if (string.IsNullOrWhiteSpace(zoneId))
-            {
-                return ZoneFlowProfile.Arena;
-            }
-
-            var zone = ZoneConfigService.GetZoneById(zoneId);
-            if (zone != null)
-            {
-                if (HasZoneTag(zone, "pvp") || HasZoneTag(zone, "arena_pvp") || IsPvpZone(zoneId))
-                {
-                    return ZoneFlowProfile.Pvp;
-                }
-
-                if (HasZoneTag(zone, "boss") || zoneId.IndexOf("boss", StringComparison.OrdinalIgnoreCase) >= 0)
-                {
-                    return ZoneFlowProfile.Boss;
-                }
-
-                if (HasZoneTag(zone, "template") || HasZoneTag(zone, "template_zone"))
-                {
-                    return ZoneFlowProfile.Template;
-                }
-
-                if (zone.IsArenaZone || HasZoneTag(zone, "arena"))
-                {
-                    return ZoneFlowProfile.Arena;
-                }
-            }
-
-            if (IsPvpZone(zoneId))
-            {
-                return ZoneFlowProfile.Pvp;
-            }
-
-            if (zoneId.IndexOf("boss", StringComparison.OrdinalIgnoreCase) >= 0)
-            {
-                return ZoneFlowProfile.Boss;
-            }
-
-            return ZoneFlowProfile.Arena;
-        }
-
-        private static bool HasZoneTag(ZoneDefinition zone, string tag)
-        {
-            if (zone?.Tags == null || string.IsNullOrWhiteSpace(tag))
-            {
-                return false;
-            }
-
-            foreach (var entry in zone.Tags)
-            {
-                if (string.Equals(entry, tag, StringComparison.OrdinalIgnoreCase))
-                {
-                    return true;
-                }
-            }
-
-            return false;
-        }
-
-        private static bool TryGetLifecycleMappingForZone(string zoneId, out ZoneMapping mapping, out bool matchedWildcard)
+        private static bool TryGetLifecycleMappingForZone(string zoneId, out ZoneMapping mapping)
         {
             mapping = null;
-            matchedWildcard = false;
             if (_jsonConfig?.Mappings == null)
             {
                 return false;
@@ -2596,7 +2456,6 @@ namespace VAuto.Zone
 
             if (_jsonConfig.Mappings.TryGetValue("*", out mapping))
             {
-                matchedWildcard = true;
                 return true;
             }
 
@@ -2634,8 +2493,6 @@ namespace VAuto.Zone
             return token switch
             {
                 "restore" => "restore_kit_snapshot",
-                "restore_snapshot" => "snapshot_restore",
-                "snapshot" => "snapshot_restore",
                 "message" => "zone_exit_message",
                 "abilities" => "restore_abilities",
                 "ability" => "restore_abilities",
@@ -2681,12 +2538,12 @@ namespace VAuto.Zone
                 case "apply_abilities":
                     if (TempDisableAbilityUiDuringZoneTransitions)
                     {
-                        TryRunZoneEnterStep("AbilityZoneService.OnZoneEnter(Skipped)", () =>
-                            Logger.LogInfo("[BlueLock] AbilityZoneService.OnZoneEnter skipped (temporary transition safeguard)."));
+                        TryRunZoneEnterStep("AbilityUi.OnZoneEnter(Skipped)", () =>
+                            Logger.LogInfo("[BlueLock] AbilityUi.OnZoneEnter skipped (temporary transition safeguard)."));
                     }
                     else
                     {
-                        TryRunZoneEnterStep("AbilityZoneService.OnZoneEnter", () => AbilityZoneService.OnZoneEnter(player, zoneId));
+                        TryRunZoneEnterStep("AbilityUi.OnZoneEnter", () => AbilityUi.OnZoneEnter(player, zoneId));
                     }
                     break;
                 case "glow_spawn":
@@ -2749,8 +2606,10 @@ namespace VAuto.Zone
                     });
                     break;
                 case "integration_events_enter":
+                    TryRunZoneEnterStep("LifecycleManager.OnPlayerEntered", () => _arenaLifecycleManager?.OnPlayerEntered(player, zoneId));
                     if (IntegrationLifecycleEnabledValue)
                     {
+                        TryRunZoneEnterStep("LifecycleManager.OnPlayerEnter", () => TryInvokeLifecycleManager("OnPlayerEnter", player, zoneId));
                         TryRunZoneEnterStep("CoreLifecycle.PlayerEnter", () => TryTriggerCoreLifecycleEvent(GameActionService.EventPlayerEnter, player, zoneId, em));
                     }
                     if (IsSandboxZone(zoneId))
@@ -2763,10 +2622,7 @@ namespace VAuto.Zone
                     TryRunZoneEnterStep("TryInvokeAnnouncementZoneEnter", () => TryInvokeAnnouncementZoneEnter(player, zoneId, em));
                     break;
                 default:
-                    if (!TryExecuteRegisteredDomainEnter(action, player, zoneId, em))
-                    {
-                        Logger.LogWarning($"[BlueLock] Unknown enter lifecycle action '{action}' for zone '{zoneId}'.");
-                    }
+                    Logger.LogWarning($"[BlueLock] Unknown enter lifecycle action '{action}' for zone '{zoneId}'.");
                     break;
             }
         }
@@ -2787,23 +2643,14 @@ namespace VAuto.Zone
                 case "restore_abilities":
                     if (TempDisableAbilityUiDuringZoneTransitions)
                     {
-                        TryRunZoneExitStep("AbilityZoneService.OnZoneExit(Skipped)", () =>
-                            Logger.LogInfo("[BlueLock] AbilityZoneService.OnZoneExit skipped (temporary transition safeguard)."));
+                        TryRunZoneExitStep("AbilityUi.OnZoneExit(Skipped)", () =>
+                            Logger.LogInfo("[BlueLock] AbilityUi.OnZoneExit skipped (temporary transition safeguard)."));
                     }
                     else
                     {
-                        TryRunZoneExitStep("AbilityZoneService.OnZoneExit", () => AbilityZoneService.OnZoneExit(player, zoneId));
+                        TryRunZoneExitStep("AbilityUi.OnZoneExit", () => AbilityUi.OnZoneExit(player, zoneId));
                     }
                     break;
-                case "snapshot_restore":
-                    TryRunZoneExitStep("PlayerSnapshotService.RestoreSnapshot", () =>
-                    {
-                        if (!PlayerSnapshotService.RestoreSnapshot(player, out var snapshotError))
-                        {
-                            Logger.LogDebug($"[BlueLock] Snapshot restore skipped/failed on exit for zone '{zoneId}': {snapshotError}");
-                        }
-                    });
-                    break;
                 case "boss_exit":
                     TryRunZoneExitStep("ZoneBossSpawnerService.HandlePlayerExit", () => ZoneBossSpawnerService.HandlePlayerExit(player, zoneId));
                     break;
@@ -2829,8 +2676,10 @@ namespace VAuto.Zone
                     });
                     break;
                 case "integration_events_exit":
+                    TryRunZoneExitStep("LifecycleManager.OnPlayerExited", () => _arenaLifecycleManager?.OnPlayerExited(player, zoneId));
                     if (IntegrationLifecycleEnabledValue)
                     {
+                        TryRunZoneExitStep("LifecycleManager.OnPlayerExit", () => TryInvokeLifecycleManager("OnPlayerExit", player, zoneId));
                         TryRunZoneExitStep("CoreLifecycle.PlayerExit", () => TryTriggerCoreLifecycleEvent(GameActionService.EventPlayerExit, player, zoneId, em));
                     }
                     if (IsSandboxZone(zoneId))
@@ -2842,62 +2691,11 @@ namespace VAuto.Zone
                     // Reserved for explicit exit announcements (not currently implemented in AnnouncementService).
                     break;
                 default:
-                    if (!TryExecuteRegisteredDomainExit(action, player, zoneId, em))
-                    {
-                        Logger.LogWarning($"[BlueLock] Unknown exit lifecycle action '{action}' for zone '{zoneId}'.");
-                    }
+                    Logger.LogWarning($"[BlueLock] Unknown exit lifecycle action '{action}' for zone '{zoneId}'.");
                     break;
             }
         }
 
-        private static bool TryExecuteRegisteredDomainEnter(string action, Entity player, string zoneId, EntityManager em)
-        {
-            try
-            {
-                var ctx = new LifecycleContext
-                {
-                    Player = player,
-                    Character = player,
-                    ZoneId = zoneId ?? string.Empty,
-                    PlatformId = ResolvePlatformId(player, em),
-                    Data = new Dictionary<string, object>
-                    {
-                        ["EntityManager"] = em
-                    }
-                };
-                return LifecycleRegistry.Instance.ExecuteEnter(action, ctx);
-            }
-            catch (Exception ex)
-            {
-                Logger.LogWarning($"[BlueLock] Domain enter registry dispatch failed for '{action}': {ex.Message}");
-                return false;
-            }
-        }
-
-        private static bool TryExecuteRegisteredDomainExit(string action, Entity player, string zoneId, EntityManager em)
-        {
-            try
-            {
-                var ctx = new LifecycleContext
-                {
-                    Player = player,
-                    Character = player,
-                    ZoneId = zoneId ?? string.Empty,
-                    PlatformId = ResolvePlatformId(player, em),
-                    Data = new Dictionary<string, object>
-                    {
-                        ["EntityManager"] = em
-                    }
-                };
-                return LifecycleRegistry.Instance.ExecuteExit(action, ctx);
-            }
-            catch (Exception ex)
-            {
-                Logger.LogWarning($"[BlueLock] Domain exit registry dispatch failed for '{action}': {ex.Message}");
-                return false;
-            }
-        }
-
         private static void SendZoneExitSystemMessage(Entity player, string zoneId, EntityManager em)
         {
             try
@@ -2929,6 +2727,95 @@ namespace VAuto.Zone
             }
         }
 
+        private static void TryInvokeLifecycleManager(string methodName, Entity characterEntity, string zoneId)
+        {
+            try
+            {
+                var em = UnifiedCore.EntityManager;
+                if (!em.Exists(characterEntity) || !em.HasComponent<PlayerCharacter>(characterEntity))
+                {
+                    return;
+                }
+
+                var userEntity = em.GetComponentData<PlayerCharacter>(characterEntity).UserEntity;
+                if (userEntity == Entity.Null)
+                {
+                    return;
+                }
+
+                var position = GetEntityPosition(em, characterEntity);
+
+                var lifecycleType = ResolveLifecycleType("VAuto.Core.Lifecycle.ArenaLifecycleManager");
+                if (lifecycleType == null)
+                {
+                    Logger.LogDebug($"[BlueLock] Lifecycle manager type not found for method '{methodName}'. Checked assemblies: {string.Join(", ", LifecycleAssemblyNames)}");
+                    return;
+                }
+
+                var instanceProp = lifecycleType.GetProperty("Instance", BindingFlags.Public | BindingFlags.Static);
+                if (instanceProp == null)
+                {
+                    Logger.LogWarning($"[BlueLock] Lifecycle type '{lifecycleType.Name}' has no Instance property");
+                    return;
+                }
+
+                var lifecycleInstance = instanceProp.GetValue(null);
+                if (lifecycleInstance == null)
+                {
+                    Logger.LogWarning($"[BlueLock] Lifecycle Instance property returned null");
+                    return;
+                }
+
+                if (!TryInvokeLifecycleMethod(lifecycleType, lifecycleInstance, methodName, userEntity, characterEntity, zoneId, position))
+                {
+                    Logger.LogWarning($"[BlueLock] Lifecycle method '{methodName}' not found or failed on type '{lifecycleType.Name}'");
+                }
+            }
+            catch (Exception ex)
+            {
+                Logger.LogWarning($"[BlueLock] Lifecycle reflection invoke failed ({methodName}): {ex.Message}");
+            }
+        }
+
+        private static bool TryInvokeLifecycleMethod(Type lifecycleType, object lifecycleInstance, string methodName, Entity userEntity, Entity characterEntity, string zoneId, float3 position)
+        {
+            var candidates = new[]
+            {
+                new object[] { userEntity, characterEntity, zoneId, position },
+                new object[] { userEntity, characterEntity, zoneId },
+                new object[] { characterEntity, zoneId, position },
+                new object[] { characterEntity, zoneId }
+            };
+
+            foreach (var args in candidates)
+            {
+                var argTypes = args.Select(a => a.GetType()).ToArray();
+                var method = lifecycleType.GetMethod(
+                    methodName,
+                    BindingFlags.Public | BindingFlags.Instance,
+                    null,
+                    argTypes,
+                    null);
+
+                if (method == null)
+                {
+                    continue;
+                }
+
+                try
+                {
+                    method.Invoke(lifecycleInstance, args);
+                    return true;
+                }
+                catch (Exception ex)
+                {
+                    Logger.LogDebug($"[BlueLock] Lifecycle method '{methodName}' invoke failed for signature ({string.Join(", ", argTypes.Select(t => t.Name))}): {ex.Message}");
+                }
+            }
+
+            return false;
+        }
+
         private static float3 GetEntityPosition(EntityManager em, Entity entity)
         {
             try
@@ -3295,12 +3182,12 @@ namespace VAuto.Zone
                 // Post-unlock ability apply: execute after DebugEventBridge unlock pipeline.
                 if (TempDisableAbilityUiDuringZoneTransitions)
                 {
-                    TryRunZoneEnterStep("AbilityZoneService.TryApplyPresetForPlayer(Skipped)", () =>
-                        Logger.LogInfo("[BlueLock] AbilityZoneService.TryApplyPresetForPlayer skipped (temporary transition safeguard)."));
+                    TryRunZoneEnterStep("AbilityUi.TryApplyPresetForPlayer(Skipped)", () =>
+                        Logger.LogInfo("[BlueLock] AbilityUi.TryApplyPresetForPlayer skipped (temporary transition safeguard)."));
                 }
                 else
                 {
-                    TryRunZoneEnterStep("AbilityZoneService.TryApplyPresetForPlayer", () => AbilityZoneService.TryApplyPresetForPlayer(characterEntity));
+                    TryRunZoneEnterStep("AbilityUi.TryApplyPresetForPlayer", () => AbilityUi.TryApplyPresetForPlayer(characterEntity));
                 }
             }
             catch (Exception ex)
@@ -4031,7 +3918,7 @@ namespace VAuto.Zone
                         }
 
                         var abilityGroup = em.GetComponentData<PrefabGUID>(started.AbilityGroup);
-                        if (AbilityZoneService.CheckAbilityUsage(started.Character, abilityGroup))
+                        if (AbilityUi.CheckAbilityUsage(started.Character, abilityGroup))
                         {
                             em.RemoveComponent<AbilityCastStartedEvent>(entity);
                         }
@@ -4055,7 +3942,7 @@ namespace VAuto.Zone
         public static void ServerBootstrap_OnUpdate_Postfix()
         {
             Plugin.ProcessAutoZoneDetection();
-            AbilityZoneService.ProcessPendingSlotApplies();
+            AbilityUi.ProcessPendingSlotApplies();
             Plugin.ProcessPendingZoneTeleports();
         }
 
diff --git a/Bluelock/Services/AbilityUi.cs b/Bluelock/Services/AbilityUi.cs
new file mode 100644
index 0000000..5e0ee46
--- /dev/null
+++ b/Bluelock/Services/AbilityUi.cs
@@ -0,0 +1,1173 @@
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text.Json;
+using BepInEx;
+using ProjectM;
+using Stunlock.Core;
+using Unity.Entities;
+using VAuto.Zone.Models;
+using VAuto.Zone.Core;
+using VAutomationCore.Core.Config;
+
+namespace VAuto.Zone.Services
+{
+    /// <summary>
+    /// Ability UI / slot control service.
+    /// Implements the methods referenced by Plugin.cs:
+    /// - Initialize()
+    /// - OnZoneEnter()
+    /// - OnZoneExit()
+    /// - CheckAbilityUsage()
+    ///
+    /// Hotbar: 4 slots mapped to keys:
+    /// 0=T, 1=C, 2=R, 3=SPACE
+    /// </summary>
+    public static class AbilityUi
+    {
+        public const int SlotCount = 4;
+
+        public static readonly PrefabGUID SlotBuff = new PrefabGUID(-480024072); // Admin_Invulnerable_Buff
+
+        /// <summary>4-slot index mapping: T=0, C=1, R=2, Space=3.</summary>
+        public enum SlotIndex : int
+        {
+            T = 0,
+            C = 1,
+            R = 2,
+            Space = 3
+        }
+
+        // -----------------------------
+        // Injectable hooks (wire in Plugin.cs)
+        // -----------------------------
+
+        /// <summary>Provide the server EntityManager (authoritative).</summary>
+        public static Func<EntityManager>? GetEntityManager { get; set; }
+
+        /// <summary>Resolve SteamId for a player entity.</summary>
+        public static Func<Entity, ulong>? GetSteamId { get; set; }
+
+        /// <summary>
+        /// Resolve a string identifier to a PrefabGUID.
+        /// Allows JSON to specify either numeric GuidHash or prefab name (if you implement lookup).
+        /// Default implementation accepts numeric strings only.
+        /// </summary>
+        public static Func<string, PrefabGUID?>? ResolveAbilityGuid { get; set; }
+
+        /// <summary>Logger hooks; if unset will no-op.</summary>
+        public static Action<string>? LogInfo { get; set; }
+        public static Action<string>? LogWarn { get; set; }
+        public static Action<string>? LogError { get; set; }
+
+        // -----------------------------
+        // Internal state
+        // -----------------------------
+
+        private static bool _initialized;
+
+        // ZoneId -> config
+        private static readonly Dictionary<string, ZoneAbilityConfig> _zoneConfigs = new(StringComparer.OrdinalIgnoreCase);
+        private static readonly Dictionary<string, string> _abilityAliases = new(StringComparer.OrdinalIgnoreCase);
+        private static ZoneAbilityConfig _defaultConfig = ZoneAbilityConfig.Default("*");
+        private static bool _hasDefaultConfig;
+
+        // SteamId -> player state while in a lifecycle zone
+        private static readonly Dictionary<ulong, PlayerAbilityState> _playerStates = new();
+        private sealed class PendingSlotApply
+        {
+            public Entity Player { get; set; }
+            public PrefabGUID[] Slots { get; set; } = Array.Empty<PrefabGUID>();
+            public string ZoneId { get; set; } = string.Empty;
+            public bool MergeWithCurrent { get; set; }
+            public DateTime ExpiresUtc { get; set; }
+        }
+
+        // SteamId -> pending slot apply (when player entity isn't ready yet).
+        private static readonly Dictionary<ulong, PendingSlotApply> _pendingSlotApplies = new();
+        private static readonly Dictionary<ulong, DateTime> _lastDeferredSlotWarnUtc = new();
+        private static readonly Dictionary<int, ulong> _playerIndexToSteamId = new();
+        private const int DeferredSlotWarnCooldownSeconds = 10;
+
+        /// <summary>Where the zone ability configuration lives.</summary>
+        private static readonly string _configPath = ResolveAbilityConfigPath();
+        private static readonly string _abilityPrefabConfigPath = ResolveAbilityPrefabConfigPath();
+        public static string ConfigPath => _configPath;
+
+        private static string ResolveAbilityConfigPath()
+        {
+            var rootDir = Path.Combine(Paths.ConfigPath, "Bluelock");
+            Directory.CreateDirectory(rootDir);
+
+            var rootPath = Path.Combine(rootDir, "ability_zones.json");
+            var legacyPath = Path.Combine(rootDir, "config", "ability_zones.json");
+            try
+            {
+                if (!File.Exists(rootPath) && File.Exists(legacyPath))
+                {
+                    File.Copy(legacyPath, rootPath, overwrite: false);
+                }
+            }
+            catch
+            {
+                // Best-effort migration.
+            }
+
+            return rootPath;
+        }
+
+        private static string ResolveAbilityPrefabConfigPath()
+        {
+            var rootDir = Path.Combine(Paths.ConfigPath, "Bluelock");
+            Directory.CreateDirectory(rootDir);
+
+            var rootPath = Path.Combine(rootDir, "ability_prefabs.json");
+            var legacyPath = Path.Combine(rootDir, "config", "ability_prefabs.json");
+            try
+            {
+                if (!File.Exists(rootPath) && File.Exists(legacyPath))
+                {
+                    File.Copy(legacyPath, rootPath, overwrite: false);
+                }
+            }
+            catch
+            {
+                // Best-effort migration.
+            }
+
+            return rootPath;
+        }
+
+        // -----------------------------
+        // Public API required by Plugin.cs
+        // -----------------------------
+
+        /// <summary>
+        /// Must be called once during plugin startup.
+        /// Loads zone configs and sets default hooks.
+        /// </summary>
+        public static void Initialize()
+        {
+            if (_initialized) return;
+
+            try
+            {
+                // Default hooks (safe no-op/fallbacks)
+                LogInfo ??= _ => { };
+                LogWarn ??= _ => { };
+                LogError ??= _ => { };
+
+                if (ResolveAbilityGuid == null)
+                {
+                    ResolveAbilityGuid = (s) =>
+                    {
+                        s = NormalizeAbilityToken(s);
+                        if (string.IsNullOrWhiteSpace(s)) return null;
+
+                        if (PrefabResolver.TryResolve(s, out var guid))
+                            return guid;
+
+                        return null;
+                    };
+                }
+
+                // EntityManager and SteamId resolver must be injected; keep soft-fail behavior.
+                if (GetEntityManager == null)
+                    LogWarn("[Initialize] GetEntityManager not set. AbilityUi will be inert until wired.");
+                if (GetSteamId == null)
+                    LogWarn("[Initialize] GetSteamId not set. AbilityUi will be inert until wired.");
+
+                LoadAbilityPrefabAliases();
+                LoadZoneConfigs();
+                _initialized = true;
+
+                LogInfo($"Initialized. Loaded {_zoneConfigs.Count} zone config(s). SlotCount={SlotCount} (T,C,R,SPACE).");
+            }
+            catch (Exception ex)
+            {
+                LogError($"[AbilityUi] Failed to initialize: {ex.Message}");
+                // Still mark as initialized to prevent repeated attempts
+                _initialized = true;
+            }
+        }
+
+        /// <summary>
+        /// Reload ability-zone configuration from disk.
+        /// </summary>
+        public static void Reload()
+        {
+            if (!_initialized)
+            {
+                Initialize();
+                return;
+            }
+
+            LoadAbilityPrefabAliases();
+            LoadZoneConfigs();
+            LogInfo?.Invoke($"Reloaded. Loaded {_zoneConfigs.Count} zone config(s).");
+        }
+
+        /// <summary>
+        /// Called when a player enters a zone (from zone tracking / lifecycle handler).
+        /// Applies preset slots, restrictions, and optional cooldown reset.
+        /// </summary>
+        public static void OnZoneEnter(Entity playerEntity, string zoneId)
+        {
+            try
+            {
+                if (!_initialized) Initialize();
+
+                if (!TryGetCore(playerEntity, out _, out var steamId, out var err))
+                {
+                    LogWarn?.Invoke($"[OnZoneEnter] {err}");
+                    return;
+                }
+
+                if (!TryGetZoneConfig(zoneId, out var cfg))
+                {
+                    // Not configured: clear state and do nothing.
+                    _playerStates.Remove(steamId);
+                    LogInfo?.Invoke($"[OnZoneEnter] Zone '{zoneId}' has no config; no ability changes applied.");
+                    return;
+                }
+
+                var state = GetOrCreateState(steamId);
+                state.SteamId = steamId;
+                state.CurrentZoneId = zoneId;
+                state.ZoneEnterTime = DateTime.UtcNow;
+                _playerIndexToSteamId[playerEntity.Index] = steamId;
+                var hotbarSnapshot = GetPlayerAbilitySlots(playerEntity, out _);
+
+                if (cfg.SaveAndRestoreSlots)
+                    state.SavedSlots = hotbarSnapshot;
+
+                if (cfg.SaveAndRestoreCooldowns)
+                {
+                    // Save only active hotbar cooldowns, not the entire ability pool.
+                    var trackedSlots = hotbarSnapshot.Length == SlotCount ? hotbarSnapshot : null;
+                    state.SavedCooldowns = GetPlayerCooldowns(playerEntity, trackedSlots);
+                }
+
+                // Do not apply presets during enter; ability buffers may not yet be initialized.
+                // Queue a post-unlock apply and let ProcessPendingSlotApplies handle fallback retries.
+                if (cfg.PresetSlots != null && cfg.PresetSlots.Length > 0)
+                    QueuePendingSlotApply(steamId, playerEntity, zoneId, cfg.PresetSlots, mergeWithCurrent: true, "Awaiting post-unlock ability buffers");
+
+                LogInfo?.Invoke($"[OnZoneEnter] Player {steamId} entered zone '{zoneId}'.");
+            }
+            catch (Exception ex)
+            {
+                LogError?.Invoke($"[OnZoneEnter] Unhandled error: {ex}");
+            }
+        }
+
+        /// <summary>
+        /// Called when a player exits a zone.
+        /// Restores saved slots/cooldowns if configured and optionally resets cooldowns.
+        /// </summary>
+        public static void OnZoneExit(Entity playerEntity, string zoneId)
+        {
+            try
+            {
+                if (!_initialized) Initialize();
+
+                if (!TryGetCore(playerEntity, out _, out var steamId, out var err))
+                {
+                    LogWarn?.Invoke($"[OnZoneExit] {err}");
+                    return;
+                }
+
+                if (!TryGetZoneConfig(zoneId, out var cfg))
+                {
+                    _playerStates.Remove(steamId);
+                    LogInfo?.Invoke($"[OnZoneExit] Zone '{zoneId}' had no config; cleared player state.");
+                    return;
+                }
+
+                if (_playerStates.TryGetValue(steamId, out var state))
+                {
+                    if (cfg.SaveAndRestoreSlots && state.SavedSlots != null && state.SavedSlots.Length > 0)
+                    {
+                        ApplySlots(playerEntity, state.SavedSlots, out var restoreErr);
+                        if (!string.IsNullOrWhiteSpace(restoreErr))
+                            LogWarn?.Invoke($"[OnZoneExit] Restore slots failed: {restoreErr}");
+                    }
+
+                    if (cfg.SaveAndRestoreCooldowns && state.SavedCooldowns != null && state.SavedCooldowns.Count > 0)
+                        ApplyCooldowns(playerEntity, state.SavedCooldowns);
+
+                    if (cfg.ResetCooldownsOnExit)
+                        ResetAbilityCooldowns(playerEntity);
+
+                    _playerStates.Remove(steamId);
+                }
+
+                // Keep pending applies across transient enter/exit churn.
+                // Pending state is cleared on successful apply, timeout, or disconnect cleanup.
+                _playerIndexToSteamId.Remove(playerEntity.Index);
+
+                LogInfo?.Invoke($"[OnZoneExit] Player {steamId} exited zone '{zoneId}'.");
+            }
+            catch (Exception ex)
+            {
+                LogError?.Invoke($"[OnZoneExit] Unhandled error: {ex}");
+            }
+        }
+
+        public static void TryApplyPresetForPlayer(Entity playerEntity)
+        {
+            try
+            {
+                if (!_initialized) Initialize();
+
+                if (!TryGetCore(playerEntity, out var em, out var steamId, out _))
+                    return;
+
+                if (!_playerStates.TryGetValue(steamId, out var state))
+                    return;
+
+                if (string.IsNullOrWhiteSpace(state.CurrentZoneId) ||
+                    !TryGetZoneConfig(state.CurrentZoneId, out var cfg) ||
+                    cfg.PresetSlots == null ||
+                    cfg.PresetSlots.Length == 0)
+                {
+                    return;
+                }
+
+                if (!em.HasComponent<ProjectM.AbilitySlotBuffer>(playerEntity))
+                {
+                    QueuePendingSlotApply(steamId, playerEntity, state.CurrentZoneId, cfg.PresetSlots, mergeWithCurrent: true, "AbilitySlotBuffer not ready after unlock");
+                    return;
+                }
+
+                var current = GetPlayerAbilitySlots(playerEntity, out _);
+                if (current.Length != SlotCount)
+                    return;
+
+                for (int i = 0; i < cfg.PresetSlots.Length && i < SlotCount; i++)
+                    current[i] = cfg.PresetSlots[i];
+
+                if (ApplySlots(playerEntity, current, out var applyErr) && string.IsNullOrWhiteSpace(applyErr))
+                {
+                    if (cfg.ResetCooldownsOnEnter)
+                        ResetAbilityCooldowns(playerEntity);
+
+                    _pendingSlotApplies.Remove(steamId);
+                    _lastDeferredSlotWarnUtc.Remove(steamId);
+                    LogInfo?.Invoke($"[TryApplyPresetForPlayer] Applied preset slots for {steamId} in zone '{state.CurrentZoneId}'.");
+                }
+                else if (!string.IsNullOrWhiteSpace(applyErr))
+                {
+                    QueuePendingSlotApply(steamId, playerEntity, state.CurrentZoneId, cfg.PresetSlots, mergeWithCurrent: true, applyErr);
+                }
+            }
+            catch (Exception ex)
+            {
+                LogError?.Invoke($"[TryApplyPresetForPlayer] Unhandled error: {ex}");
+            }
+        }
+
+        public static void ClearStateForDisconnectedPlayer(Entity playerEntity, EntityManager em = default)
+        {
+            if (!_initialized)
+            {
+                return;
+            }
+
+            var steamId = 0UL;
+            if (playerEntity != Entity.Null && _playerIndexToSteamId.TryGetValue(playerEntity.Index, out var tracked))
+            {
+                steamId = tracked;
+            }
+            else if (GetSteamId != null)
+            {
+                try
+                {
+                    steamId = GetSteamId(playerEntity);
+                }
+                catch
+                {
+                    steamId = 0;
+                }
+            }
+
+            if (steamId == 0)
+            {
+                return;
+            }
+
+            _playerStates.Remove(steamId);
+            _pendingSlotApplies.Remove(steamId);
+            _lastDeferredSlotWarnUtc.Remove(steamId);
+            _playerIndexToSteamId.Remove(playerEntity.Index);
+            LogInfo?.Invoke($"[ClearStateForDisconnectedPlayer] Cleared ability state for {steamId}.");
+        }
+
+        /// <summary>
+        /// Call every server tick to apply any deferred slot writes (player entity not ready at enter time).
+        /// </summary>
+        public static void ProcessPendingSlotApplies()
+        {
+            if (!_initialized) return;
+            if (_pendingSlotApplies.Count == 0) return;
+            if (GetEntityManager == null) return;
+
+            var em = GetEntityManager();
+            if (em == default) return;
+
+            var now = DateTime.UtcNow;
+            var remove = new List<ulong>();
+
+            foreach (var kv in _pendingSlotApplies)
+            {
+                var steamId = kv.Key;
+                var pending = kv.Value;
+
+                if (pending == null || pending.ExpiresUtc <= now)
+                {
+                    if (pending != null && pending.ExpiresUtc <= now)
+                    {
+                        LogWarn?.Invoke($"[ProcessPendingSlotApplies] Deferred preset slots timed out for {steamId}; ability slots never became readable.");
+                    }
+
+                    remove.Add(steamId);
+                    continue;
+                }
+
+                if (!em.Exists(pending.Player))
+                {
+                    remove.Add(steamId);
+                    continue;
+                }
+
+                if (!_playerStates.TryGetValue(steamId, out var activeState) ||
+                    string.IsNullOrWhiteSpace(activeState.CurrentZoneId) ||
+                    (!string.IsNullOrWhiteSpace(pending.ZoneId) &&
+                     !string.Equals(activeState.CurrentZoneId, pending.ZoneId, StringComparison.OrdinalIgnoreCase)))
+                {
+                    remove.Add(steamId);
+                    continue;
+                }
+
+                if (pending.Slots == null || pending.Slots.Length == 0)
+                {
+                    remove.Add(steamId);
+                    continue;
+                }
+
+                PrefabGUID[] targetSlots;
+                if (pending.MergeWithCurrent || pending.Slots.Length != SlotCount)
+                {
+                    var current = GetPlayerAbilitySlots(pending.Player, out _);
+                    if (current.Length != SlotCount)
+                    {
+                        continue;
+                    }
+
+                    for (var i = 0; i < pending.Slots.Length && i < SlotCount; i++)
+                    {
+                        current[i] = pending.Slots[i];
+                    }
+
+                    targetSlots = current;
+                }
+                else
+                {
+                    targetSlots = pending.Slots;
+                }
+
+                if (!em.HasComponent(pending.Player, ComponentType.ReadOnly<ProjectM.AbilitySlotBuffer>()))
+                    continue;
+
+                if (ApplySlots(pending.Player, targetSlots, out var err) && string.IsNullOrWhiteSpace(err))
+                {
+                    if (TryGetZoneConfig(activeState.CurrentZoneId, out var cfg) && cfg.ResetCooldownsOnEnter)
+                        ResetAbilityCooldowns(pending.Player);
+
+                    LogInfo?.Invoke($"[ProcessPendingSlotApplies] Applied deferred slots for {steamId}.");
+                    remove.Add(steamId);
+                }
+            }
+
+            for (int i = 0; i < remove.Count; i++)
+            {
+                var steamId = remove[i];
+                _pendingSlotApplies.Remove(steamId);
+                _lastDeferredSlotWarnUtc.Remove(steamId);
+            }
+        }
+
+        private static void QueuePendingSlotApply(ulong steamId, Entity playerEntity, string zoneId, PrefabGUID[] slots, bool mergeWithCurrent, string reason)
+        {
+            // Only keep one pending apply per player.
+            _pendingSlotApplies[steamId] = new PendingSlotApply
+            {
+                Player = playerEntity,
+                Slots = slots,
+                ZoneId = zoneId ?? string.Empty,
+                MergeWithCurrent = mergeWithCurrent,
+                ExpiresUtc = DateTime.UtcNow.AddSeconds(45)
+            };
+
+            var now = DateTime.UtcNow;
+            if (!_lastDeferredSlotWarnUtc.TryGetValue(steamId, out var lastWarnUtc) ||
+                (now - lastWarnUtc).TotalSeconds >= DeferredSlotWarnCooldownSeconds)
+            {
+                _lastDeferredSlotWarnUtc[steamId] = now;
+                LogWarn?.Invoke($"[OnZoneEnter] Deferring preset slots for {steamId}: {reason}");
+            }
+            else
+            {
+                LogInfo?.Invoke($"[OnZoneEnter] Preset slot apply still pending for {steamId}.");
+            }
+        }
+
+        /// <summary>
+        /// Called when the plugin intercepts an ability cast attempt.
+        /// Return true to BLOCK the cast, false to allow.
+        /// </summary>
+        public static bool CheckAbilityUsage(Entity playerEntity, PrefabGUID abilityGuid)
+        {
+            if (!_initialized) Initialize();
+
+            var steamId = GetSteamId?.Invoke(playerEntity) ?? 0;
+            if (steamId == 0) return false;
+
+            if (!_playerStates.TryGetValue(steamId, out var state)) return false;
+            if (string.IsNullOrWhiteSpace(state.CurrentZoneId)) return false;
+
+            if (!TryGetZoneConfig(state.CurrentZoneId, out var cfg))
+            {
+                return false;
+            }
+
+            if (!cfg.IsAbilityAllowed(abilityGuid))
+            {
+                LogInfo?.Invoke($"[CheckAbilityUsage] Blocked ability {abilityGuid.GuidHash} for {steamId} in zone '{state.CurrentZoneId}'.");
+                return true;
+            }
+
+            return false;
+        }
+
+        // -----------------------------
+        // Slot management helpers
+        // -----------------------------
+
+        /// <summary>
+        /// Updates one of the 4 hotbar slots. Optionally resets cooldown for that ability.
+        /// </summary>
+        public static bool UpdateAbilityOnSlot(Entity playerEntity, int slotIndex, PrefabGUID abilityGuid, bool resetCooldown, out string error)
+        {
+            error = string.Empty;
+
+            if (slotIndex < 0 || slotIndex >= SlotCount)
+            {
+                error = $"slotIndex {slotIndex} out of range [0..{SlotCount - 1}] (T,C,R,SPACE).";
+                return false;
+            }
+
+            var slots = GetPlayerAbilitySlots(playerEntity, out var readErr);
+            if (slots.Length != SlotCount)
+            {
+                error = $"Unable to read player ability slots: {readErr}";
+                return false;
+            }
+
+            slots[slotIndex] = abilityGuid;
+
+            if (!ApplySlots(playerEntity, slots, out var applyErr))
+            {
+                error = applyErr;
+                return false;
+            }
+
+            if (resetCooldown)
+                ResetAbilityCooldowns(playerEntity, abilityGuid);
+
+            return true;
+        }
+
+        /// <summary>Returns exactly 4 slots (T,C,R,SPACE). Returns empty array on error.</summary>
+        public static PrefabGUID[] GetPlayerAbilitySlots(Entity playerEntity, out string error)
+        {
+            error = string.Empty;
+
+            if (GetEntityManager == null)
+            {
+                error = "GetEntityManager not set.";
+                return Array.Empty<PrefabGUID>();
+            }
+
+            var em = GetEntityManager();
+            if (em == default || !em.Exists(playerEntity))
+            {
+                error = "EntityManager unavailable or player entity missing.";
+                return Array.Empty<PrefabGUID>();
+            }
+
+            try
+            {
+                if (!em.HasComponent<ProjectM.AbilitySlotBuffer>(playerEntity))
+                {
+                    error = "AbilitySlotBuffer missing on player.";
+                    return Array.Empty<PrefabGUID>();
+                }
+
+                var buf = em.GetBuffer<ProjectM.AbilitySlotBuffer>(playerEntity);
+                var slots = new PrefabGUID[SlotCount];
+
+                for (int i = 0; i < SlotCount; i++)
+                    slots[i] = i < buf.Length ? buf[i].Ability : default;
+
+                return slots;
+            }
+            catch (Exception ex) when (ex is TypeInitializationException || ex is NullReferenceException)
+            {
+                error = $"AbilitySlotBuffer unavailable: {ex.GetType().Name}";
+                return Array.Empty<PrefabGUID>();
+            }
+        }
+
+        private static bool ApplySlots(Entity playerEntity, PrefabGUID[] slots, out string error)
+        {
+            error = string.Empty;
+
+            if (slots == null || slots.Length != SlotCount)
+            {
+                error = $"Expected {SlotCount} slots, got {slots?.Length ?? 0}.";
+                return false;
+            }
+
+            if (GetEntityManager == null)
+            {
+                error = "GetEntityManager not set.";
+                return false;
+            }
+
+            var em = GetEntityManager();
+            if (em == default || !em.Exists(playerEntity))
+            {
+                error = "EntityManager unavailable or player entity missing.";
+                return false;
+            }
+
+            try
+            {
+                if (!em.HasComponent<ProjectM.AbilitySlotBuffer>(playerEntity))
+                {
+                    error = "AbilitySlotBuffer missing on player.";
+                    return false;
+                }
+
+                var buf = em.GetBuffer<ProjectM.AbilitySlotBuffer>(playerEntity);
+
+                // Ensure at least 4 entries, write first 4, then trim.
+                for (int i = 0; i < SlotCount; i++)
+                {
+                    var entry = new ProjectM.AbilitySlotBuffer { Ability = slots[i] };
+                    if (i < buf.Length) buf[i] = entry;
+                    else buf.Add(entry);
+                }
+
+                while (buf.Length > SlotCount)
+                    buf.RemoveAt(buf.Length - 1);
+
+                return true;
+            }
+            catch (Exception ex) when (ex is TypeInitializationException || ex is NullReferenceException)
+            {
+                error = $"AbilitySlotBuffer unavailable: {ex.GetType().Name}";
+                return false;
+            }
+        }
+
+        // -----------------------------
+        // Cooldown management (best-effort)
+        // -----------------------------
+
+        /// <summary>Reset all cooldowns for player, or only a specific ability if provided.</summary>
+        public static void ResetAbilityCooldowns(Entity playerEntity, PrefabGUID? ability = null)
+        {
+            if (GetEntityManager == null) return;
+
+            var em = GetEntityManager();
+            if (em == default || !em.Exists(playerEntity)) return;
+
+            try
+            {
+                if (!em.HasComponent<ProjectM.AbilityCooldownBuffer>(playerEntity)) return;
+
+                var buf = em.GetBuffer<ProjectM.AbilityCooldownBuffer>(playerEntity);
+                for (int i = 0; i < buf.Length; i++)
+                {
+                    var cd = buf[i];
+                    if (ability.HasValue && cd.Ability.GuidHash != ability.Value.GuidHash)
+                        continue;
+
+                    cd.RemainingSeconds = 0f;
+                    buf[i] = cd;
+                }
+            }
+            catch
+            {
+                // best-effort; ignore
+            }
+        }
+
+        private static Dictionary<PrefabGUID, float> GetPlayerCooldowns(Entity playerEntity, PrefabGUID[] trackedSlots)
+        {
+            var result = new Dictionary<PrefabGUID, float>();
+            if (GetEntityManager == null) return result;
+
+            var em = GetEntityManager();
+            if (em == default || !em.Exists(playerEntity)) return result;
+
+            try
+            {
+                if (!em.HasComponent<ProjectM.AbilityCooldownBuffer>(playerEntity)) return result;
+
+                var tracked = new HashSet<int>();
+                if (trackedSlots != null)
+                {
+                    for (int i = 0; i < trackedSlots.Length; i++)
+                    {
+                        if (trackedSlots[i].GuidHash != 0)
+                        {
+                            tracked.Add(trackedSlots[i].GuidHash);
+                        }
+                    }
+                }
+
+                var restrictToTracked = tracked.Count > 0;
+
+                var buf = em.GetBuffer<ProjectM.AbilityCooldownBuffer>(playerEntity);
+                for (int i = 0; i < buf.Length; i++)
+                {
+                    var cd = buf[i];
+                    if (restrictToTracked && !tracked.Contains(cd.Ability.GuidHash))
+                    {
+                        continue;
+                    }
+
+                    result[cd.Ability] = cd.RemainingSeconds;
+                }
+            }
+            catch
+            {
+                // ignore; return what we collected
+            }
+
+            return result;
+        }
+
+        private static void ApplyCooldowns(Entity playerEntity, Dictionary<PrefabGUID, float> saved)
+        {
+            if (saved == null || saved.Count == 0) return;
+            if (GetEntityManager == null) return;
+
+            var em = GetEntityManager();
+            if (em == default || !em.Exists(playerEntity)) return;
+
+            try
+            {
+                if (!em.HasComponent<ProjectM.AbilityCooldownBuffer>(playerEntity)) return;
+
+                var buf = em.GetBuffer<ProjectM.AbilityCooldownBuffer>(playerEntity);
+                for (int i = 0; i < buf.Length; i++)
+                {
+                    var cd = buf[i];
+                    if (!saved.TryGetValue(cd.Ability, out var secs)) continue;
+                    cd.RemainingSeconds = Math.Max(0f, secs);
+                    buf[i] = cd;
+                }
+            }
+            catch
+            {
+                // best-effort; ignore
+            }
+        }
+
+        // -----------------------------
+        // Config + internal helpers
+        // -----------------------------
+
+        private static void LoadZoneConfigs()
+        {
+            _zoneConfigs.Clear();
+
+            try
+            {
+                TypedJsonConfigManager.TryLoadOrCreate(
+                    _configPath,
+                    CreateDefaultAbilityConfig,
+                    out AbilityZonesConfig root,
+                    out var createdDefault,
+                    CreateAbilityConfigSerializerOptions(writeIndented: true),
+                    ValidateAbilityZonesConfig,
+                    LogInfo,
+                    LogWarn,
+                    LogError);
+
+                if (createdDefault)
+                {
+                    LogInfo?.Invoke($"Config not found/invalid. Created default file at '{_configPath}'.");
+                }
+
+                foreach (var z in root.Zones ?? Enumerable.Empty<ZoneAbilityConfigJson>())
+                {
+                    if (string.IsNullOrWhiteSpace(z.ZoneId)) continue;
+
+                    // Pre-parse preset slots
+                    var presetSlots = (z.PresetSlots ?? new List<string>())
+                        .Select(s => ResolveAbilityGuid?.Invoke(NormalizeAbilityToken(s)))
+                        .Where(g => g.HasValue)
+                        .Select(g => g.Value)
+                        .Take(SlotCount)
+                        .ToArray();
+
+                    // Pre-parse restricted set
+                    var restrictedAbilities = (z.RestrictedAbilities ?? new List<string>())
+                        .Select(s => ResolveAbilityGuid?.Invoke(NormalizeAbilityToken(s)))
+                        .Where(g => g.HasValue)
+                        .Select(g => g.Value)
+                        .ToArray();
+
+                    // Pre-parse allowed set
+                    var allowedAbilities = (z.AllowedAbilities ?? new List<string>())
+                        .Select(s => ResolveAbilityGuid?.Invoke(NormalizeAbilityToken(s)))
+                        .Where(g => g.HasValue)
+                        .Select(g => g.Value)
+                        .ToArray();
+
+                    var config = new ZoneAbilityConfig
+                    {
+                        ZoneId = z.ZoneId,
+                        ResetCooldownsOnEnter = z.ResetCooldownsOnEnter,
+                        ResetCooldownsOnExit = z.ResetCooldownsOnExit,
+                        SaveAndRestoreSlots = z.SaveAndRestoreSlots,
+                        SaveAndRestoreCooldowns = z.SaveAndRestoreCooldowns,
+                        PresetSlots = presetSlots,
+                        RestrictedAbilities = restrictedAbilities,
+                        AllowedAbilities = allowedAbilities
+                    };
+
+                    if (z.ZoneId == "*")
+                    {
+                        _defaultConfig = config;
+                        _hasDefaultConfig = true;
+                    }
+                    else
+                    {
+                        _zoneConfigs[z.ZoneId] = config;
+                    }
+                }
+            }
+            catch (Exception ex)
+            {
+                LogError?.Invoke($"Failed to read/parse '{_configPath}': {ex}");
+                _zoneConfigs.Clear();
+                _hasDefaultConfig = false;
+                _defaultConfig = ZoneAbilityConfig.Default("*");
+            }
+        }
+
+        private static bool TryGetZoneConfig(string zoneId, out ZoneAbilityConfig config)
+        {
+            if (!string.IsNullOrWhiteSpace(zoneId) && _zoneConfigs.TryGetValue(zoneId, out config))
+            {
+                return true;
+            }
+
+            // Zone-driven fallback: if ability_zones.json doesn't specify this zone,
+            // read preset slots directly from VAuto.Zones.json for deterministic behavior.
+            if (!string.IsNullOrWhiteSpace(zoneId))
+            {
+                var zone = ZoneConfigService.GetZoneById(zoneId);
+                if (zone != null && zone.AbilityPresetSlots != null && zone.AbilityPresetSlots.Length > 0)
+                {
+                    var presetSlots = zone.AbilityPresetSlots
+                        .Where(s => !string.IsNullOrWhiteSpace(s))
+                        .Select(s => ResolveAbilityGuid?.Invoke(NormalizeAbilityToken(s)))
+                        .Where(g => g.HasValue)
+                        .Select(g => g.Value)
+                        .ToArray();
+
+                    config = new ZoneAbilityConfig
+                    {
+                        ZoneId = zoneId,
+                        ResetCooldownsOnEnter = true,
+                        ResetCooldownsOnExit = false,
+                        SaveAndRestoreSlots = true,
+                        SaveAndRestoreCooldowns = true,
+                        PresetSlots = presetSlots,
+                        RestrictedAbilities = Array.Empty<PrefabGUID>(),
+                        AllowedAbilities = Array.Empty<PrefabGUID>()
+                    };
+                    return true;
+                }
+            }
+
+            if (_hasDefaultConfig)
+            {
+                config = _defaultConfig;
+                return true;
+            }
+
+            config = default;
+            return false;
+        }
+
+        private static JsonSerializerOptions CreateAbilityConfigSerializerOptions(bool writeIndented)
+        {
+            return new JsonSerializerOptions
+            {
+                PropertyNameCaseInsensitive = true,
+                ReadCommentHandling = JsonCommentHandling.Skip,
+                AllowTrailingCommas = true,
+                WriteIndented = writeIndented
+            };
+        }
+
+        private static void LoadAbilityPrefabAliases()
+        {
+            _abilityAliases.Clear();
+
+            try
+            {
+                TypedJsonConfigManager.TryLoadOrCreate(
+                    _abilityPrefabConfigPath,
+                    CreateDefaultAbilityPrefabAliasesConfig,
+                    out AbilityPrefabAliasesConfig aliasesConfig,
+                    out var createdDefault,
+                    CreateAbilityConfigSerializerOptions(writeIndented: true),
+                    ValidateAbilityPrefabAliasesConfig,
+                    LogInfo,
+                    LogWarn,
+                    LogError);
+
+                foreach (var entry in aliasesConfig.Aliases)
+                {
+                    if (string.IsNullOrWhiteSpace(entry.Key) || string.IsNullOrWhiteSpace(entry.Value))
+                    {
+                        continue;
+                    }
+
+                    _abilityAliases[entry.Key.Trim()] = entry.Value.Trim();
+                }
+
+                if (createdDefault)
+                {
+                    LogInfo?.Invoke($"Created default ability prefab alias config at '{_abilityPrefabConfigPath}'.");
+                }
+            }
+            catch (Exception ex)
+            {
+                LogError?.Invoke($"Failed to load ability prefab alias config '{_abilityPrefabConfigPath}': {ex.Message}");
+            }
+        }
+
+        private static string NormalizeAbilityToken(string raw)
+        {
+            var token = (raw ?? string.Empty).Trim();
+            if (string.IsNullOrWhiteSpace(token))
+            {
+                return string.Empty;
+            }
+
+            if (_abilityAliases.TryGetValue(token, out var mapped) && !string.IsNullOrWhiteSpace(mapped))
+            {
+                token = mapped.Trim();
+            }
+
+            // Hard fallback aliases if config was not created yet.
+            if (token.Equals("Spell_VeilOfBlood", StringComparison.OrdinalIgnoreCase))
+                token = "AB_Vampire_VeilOfBlood_Group";
+            else if (token.Equals("Spell_VeilOfChaos", StringComparison.OrdinalIgnoreCase))
+                token = "AB_Vampire_VeilOfChaos_Group";
+            else if (token.Equals("Spell_VeilOfFrost", StringComparison.OrdinalIgnoreCase))
+                token = "AB_Vampire_VeilOfFrost_Group";
+            else if (token.Equals("Spell_VeilOfBones", StringComparison.OrdinalIgnoreCase))
+                token = "AB_Vampire_VeilOfBones_AbilityGroup";
+            else if (token.Equals("AB_BloodRite_AbilityGroup", StringComparison.OrdinalIgnoreCase))
+                token = "AB_Blood_BloodRite_AbilityGroup";
+
+            return token;
+        }
+
+        private static AbilityZonesConfig CreateDefaultAbilityConfig()
+        {
+            return new AbilityZonesConfig
+            {
+                Zones = new List<ZoneAbilityConfigJson>
+                {
+                    new ZoneAbilityConfigJson
+                    {
+                        ZoneId = "*",
+                        ResetCooldownsOnEnter = true,
+                        ResetCooldownsOnExit = false,
+                        SaveAndRestoreSlots = true,
+                        SaveAndRestoreCooldowns = true,
+                        // Default: Veil on Dash/T/C, Blood Rite on R.
+                        PresetSlots = new List<string>
+                        {
+                            "AB_Vampire_VeilOfBlood_Group",     // T
+                            "AB_Vampire_VeilOfBlood_Group",     // C
+                            "AB_Blood_BloodRite_AbilityGroup",  // R
+                            "AB_Vampire_VeilOfBlood_Group"      // SPACE (Dash)
+                        },
+                        RestrictedAbilities = new List<string>(),
+                        AllowedAbilities = new List<string>()
+                    }
+                }
+            };
+        }
+
+        private static AbilityPrefabAliasesConfig CreateDefaultAbilityPrefabAliasesConfig()
+        {
+            return new AbilityPrefabAliasesConfig
+            {
+                Aliases = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
+                {
+                    ["Spell_VeilOfBlood"] = "AB_Vampire_VeilOfBlood_Group",
+                    ["Spell_VeilOfChaos"] = "AB_Vampire_VeilOfChaos_Group",
+                    ["Spell_VeilOfFrost"] = "AB_Vampire_VeilOfFrost_Group",
+                    ["Spell_VeilOfBones"] = "AB_Vampire_VeilOfBones_AbilityGroup",
+                    ["AB_BloodRite_AbilityGroup"] = "AB_Blood_BloodRite_AbilityGroup"
+                }
+            };
+        }
+
+        private static (bool IsValid, string Error) ValidateAbilityZonesConfig(AbilityZonesConfig config)
+        {
+            if (config == null)
+            {
+                return (false, "Ability config root is null");
+            }
+
+            if (config.Zones == null)
+            {
+                return (false, "Ability config zones list is null");
+            }
+
+            return (true, string.Empty);
+        }
+
+        private static (bool IsValid, string Error) ValidateAbilityPrefabAliasesConfig(AbilityPrefabAliasesConfig config)
+        {
+            if (config == null)
+            {
+                return (false, "Ability prefab alias config is null");
+            }
+
+            if (config.Aliases == null)
+            {
+                return (false, "Ability prefab alias map is null");
+            }
+
+            return (true, string.Empty);
+        }
+
+        private static PlayerAbilityState GetOrCreateState(ulong steamId)
+        {
+            if (!_playerStates.TryGetValue(steamId, out var st))
+            {
+                st = new PlayerAbilityState { SteamId = steamId };
+                _playerStates[steamId] = st;
+            }
+
+            return st;
+        }
+
+        private static bool TryGetCore(Entity playerEntity, out EntityManager em, out ulong steamId, out string error)
+        {
+            em = default;
+            steamId = 0;
+            error = string.Empty;
+
+            if (GetEntityManager == null)
+            {
+                error = "GetEntityManager not set.";
+                return false;
+            }
+
+            em = GetEntityManager();
+            if (em == default)
+            {
+                error = "EntityManager is default/unavailable.";
+                return false;
+            }
+
+            if (!em.Exists(playerEntity))
+            {
+                error = "Player entity does not exist.";
+                return false;
+            }
+
+            if (GetSteamId == null)
+            {
+                error = "GetSteamId not set.";
+                return false;
+            }
+
+            steamId = GetSteamId(playerEntity);
+            if (steamId == 0)
+            {
+                error = "SteamId resolver returned 0.";
+                return false;
+            }
+
+            return true;
+        }
+
+        /// <summary>
+        /// Clear all player states (useful for server shutdown).
+        /// </summary>
+        public static void ClearAllStates()
+        {
+            _playerStates.Clear();
+            LogInfo?.Invoke($"Cleared all player states");
+        }
+
+        /// <summary>
+        /// Get the number of active player states.
+        /// </summary>
+        public static int GetActivePlayerCount()
+        {
+            return _playerStates.Count;
+        }
+
+        // -----------------------------
+        // JSON models
+        // -----------------------------
+
+        private sealed class AbilityZonesConfig
+        {
+            public List<ZoneAbilityConfigJson> Zones { get; set; } = new();
+        }
+
+        private sealed class AbilityPrefabAliasesConfig
+        {
+            public Dictionary<string, string> Aliases { get; set; } = new(StringComparer.OrdinalIgnoreCase);
+        }
+
+        private sealed class ZoneAbilityConfigJson
+        {
+            public string ZoneId { get; set; } = string.Empty;
+
+            public bool ResetCooldownsOnEnter { get; set; }
+            public bool ResetCooldownsOnExit { get; set; }
+
+            public bool SaveAndRestoreSlots { get; set; }
+            public bool SaveAndRestoreCooldowns { get; set; }
+
+            public List<string> PresetSlots { get; set; } = new();
+            public List<string> RestrictedAbilities { get; set; } = new();
+            public List<string> AllowedAbilities { get; set; } = new();
+        }
+
+        // Note: this service now relies on the real ProjectM.AbilitySlotBuffer and
+        // ProjectM.AbilityCooldownBuffer types; no local ECS buffer shims are defined here.
+    }
+}
diff --git a/Bluelock/Services/AbilityZoneService.cs b/Bluelock/Services/AbilityZoneService.cs
deleted file mode 100644
index 862f9e0..0000000
--- a/Bluelock/Services/AbilityZoneService.cs
+++ /dev/null
@@ -1,889 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Linq;
-using System.Text.Json;
-using BepInEx;
-using ProjectM;
-using Stunlock.Core;
-using Unity.Entities;
-using VAuto.Zone.Models;
-using VAuto.Zone.Core;
-using VAutomationCore.Core.Config;
-
-namespace VAuto.Zone.Services
-{
-    public static class AbilityZoneService
-    {
-        public const int SlotCount = 4;
-
-        public static readonly PrefabGUID SlotBuff = new PrefabGUID(-480024072); // Admin_Invulnerable_Buff
-
-        public enum SlotIndex : int
-        {
-            T = 0,
-            C = 1,
-            R = 2,
-            Space = 3
-        }
-
-        public static Func<EntityManager>? GetEntityManager { get; set; }
-        public static Func<Entity, ulong>? GetSteamId { get; set; }
-        public static Func<string, PrefabGUID?>? ResolveAbilityGuid { get; set; }
-        public static Action<string>? LogInfo { get; set; }
-        public static Action<string>? LogWarn { get; set; }
-        public static Action<string>? LogError { get; set; }
-
-        private static bool _initialized;
-        private static readonly Dictionary<string, ZoneAbilityConfig> _zoneConfigs = new(StringComparer.OrdinalIgnoreCase);
-        private static readonly Dictionary<string, string> _abilityAliases = new(StringComparer.OrdinalIgnoreCase);
-        private static ZoneAbilityConfig _defaultConfig = ZoneAbilityConfig.Default("*");
-        private static bool _hasDefaultConfig;
-
-        private static readonly Dictionary<ulong, PlayerAbilityState> _playerStates = new();
-        private sealed class PendingSlotApply
-        {
-            public Entity Player { get; set; }
-            public PrefabGUID[] Slots { get; set; } = Array.Empty<PrefabGUID>();
-            public string ZoneId { get; set; } = string.Empty;
-            public bool MergeWithCurrent { get; set; }
-            public DateTime ExpiresUtc { get; set; }
-        }
-
-        private static readonly Dictionary<ulong, PendingSlotApply> _pendingSlotApplies = new();
-        private static readonly Dictionary<ulong, DateTime> _lastDeferredSlotWarnUtc = new();
-        private static readonly Dictionary<int, ulong> _playerIndexToSteamId = new();
-        private const int DeferredSlotWarnCooldownSeconds = 10;
-
-        private static readonly string _configPath = ResolveAbilityConfigPath();
-        private static readonly string _abilityPrefabConfigPath = ResolveAbilityPrefabConfigPath();
-        public static string ConfigPath => _configPath;
-
-        private static string ResolveAbilityConfigPath()
-        {
-            var rootDir = Path.Combine(Paths.ConfigPath, "Bluelock");
-            Directory.CreateDirectory(rootDir);
-
-            var rootPath = Path.Combine(rootDir, "Bluelock.ability_zones.json");
-            var legacyPath = Path.Combine(rootDir, "config", "Bluelock.ability_zones.json");
-            try
-            {
-                if (!File.Exists(rootPath) && File.Exists(legacyPath))
-                {
-                    File.Copy(legacyPath, rootPath, overwrite: false);
-                }
-            }
-            catch
-            {
-            }
-
-            return rootPath;
-        }
-
-        private static string ResolveAbilityPrefabConfigPath()
-        {
-            var rootDir = Path.Combine(Paths.ConfigPath, "Bluelock");
-            Directory.CreateDirectory(rootDir);
-
-            var rootPath = Path.Combine(rootDir, "Bluelock.ability_prefabs.json");
-            var legacyPath = Path.Combine(rootDir, "config", "Bluelock.ability_prefabs.json");
-            try
-            {
-                if (!File.Exists(rootPath) && File.Exists(legacyPath))
-                {
-                    File.Copy(legacyPath, rootPath, overwrite: false);
-                }
-            }
-            catch
-            {
-            }
-
-            return rootPath;
-        }
-
-        public static void Initialize()
-        {
-            if (_initialized) return;
-
-            try
-            {
-                LogInfo ??= _ => { };
-                LogWarn ??= _ => { };
-                LogError ??= _ => { };
-
-                if (ResolveAbilityGuid == null)
-                {
-                    ResolveAbilityGuid = (s) =>
-                    {
-                        s = NormalizeAbilityToken(s);
-                        if (string.IsNullOrWhiteSpace(s)) return null;
-
-                        if (PrefabResolver.TryResolve(s, out var guid))
-                            return guid;
-
-                        return null;
-                    };
-                }
-
-                if (GetEntityManager == null)
-                    LogWarn("[Initialize] GetEntityManager not set. AbilityZoneService will be inert until wired.");
-                if (GetSteamId == null)
-                    LogWarn("[Initialize] GetSteamId not set. AbilityZoneService will be inert until wired.");
-
-                LoadAbilityPrefabAliases();
-                LoadZoneConfigs();
-                _initialized = true;
-
-                LogInfo($"Initialized. Loaded {_zoneConfigs.Count} zone config(s). SlotCount={SlotCount} (T,C,R,SPACE).");
-            }
-            catch (Exception ex)
-            {
-                LogError($"[AbilityZoneService] Failed to initialize: {ex.Message}");
-                _initialized = true;
-            }
-        }
-
-        public static void Reload()
-        {
-            if (!_initialized)
-            {
-                Initialize();
-                return;
-            }
-
-            LoadAbilityPrefabAliases();
-            LoadZoneConfigs();
-            LogInfo?.Invoke($"Reloaded. Loaded {_zoneConfigs.Count} zone config(s).");
-        }
-
-        public static void OnZoneEnter(Entity playerEntity, string zoneId)
-        {
-            try
-            {
-                if (!_initialized) Initialize();
-
-                if (!TryGetCore(playerEntity, out _, out var steamId, out var err))
-                {
-                    LogWarn?.Invoke($"[OnZoneEnter] {err}");
-                    return;
-                }
-
-                if (!TryGetZoneConfig(zoneId, out var cfg))
-                {
-                    _playerStates.Remove(steamId);
-                    LogInfo?.Invoke($"[OnZoneEnter] Zone '{zoneId}' has no config; no ability changes applied.");
-                    return;
-                }
-
-                var state = GetOrCreateState(steamId);
-                state.SteamId = steamId;
-                state.CurrentZoneId = zoneId;
-                state.ZoneEnterTime = DateTime.UtcNow;
-                _playerIndexToSteamId[playerEntity.Index] = steamId;
-                var hotbarSnapshot = GetPlayerAbilitySlots(playerEntity, out _);
-
-                if (cfg.SaveAndRestoreSlots)
-                    state.SavedSlots = hotbarSnapshot;
-
-                if (cfg.SaveAndRestoreCooldowns)
-                {
-                    var trackedSlots = hotbarSnapshot.Length == SlotCount ? hotbarSnapshot : null;
-                    state.SavedCooldowns = GetPlayerCooldowns(playerEntity, trackedSlots);
-                }
-
-                if (cfg.PresetSlots != null && cfg.PresetSlots.Length > 0)
-                    QueuePendingSlotApply(steamId, playerEntity, zoneId, cfg.PresetSlots, mergeWithCurrent: true, "Awaiting post-unlock ability buffers");
-
-                LogInfo?.Invoke($"[OnZoneEnter] Player {steamId} entered zone '{zoneId}'.");
-            }
-            catch (Exception ex)
-            {
-                LogError?.Invoke($"[OnZoneEnter] Unhandled error: {ex}");
-            }
-        }
-
-        public static void OnZoneExit(Entity playerEntity, string zoneId)
-        {
-            try
-            {
-                if (!_initialized) Initialize();
-
-                if (!TryGetCore(playerEntity, out _, out var steamId, out var err))
-                {
-                    LogWarn?.Invoke($"[OnZoneExit] {err}");
-                    return;
-                }
-
-                if (!TryGetZoneConfig(zoneId, out var cfg))
-                {
-                    _playerStates.Remove(steamId);
-                    LogInfo?.Invoke($"[OnZoneExit] Zone '{zoneId}' had no config; cleared player state.");
-                    return;
-                }
-
-                if (_playerStates.TryGetValue(steamId, out var state))
-                {
-                    if (cfg.SaveAndRestoreSlots && state.SavedSlots != null && state.SavedSlots.Length > 0)
-                    {
-                        ApplySlots(playerEntity, state.SavedSlots, out var restoreErr);
-                        if (!string.IsNullOrWhiteSpace(restoreErr))
-                            LogWarn?.Invoke($"[OnZoneExit] Restore slots failed: {restoreErr}");
-                    }
-
-                    if (cfg.SaveAndRestoreCooldowns && state.SavedCooldowns != null && state.SavedCooldowns.Count > 0)
-                        ApplyCooldowns(playerEntity, state.SavedCooldowns);
-
-                    if (cfg.ResetCooldownsOnExit)
-                        ResetAbilityCooldowns(playerEntity);
-
-                    _playerStates.Remove(steamId);
-                }
-
-                _playerIndexToSteamId.Remove(playerEntity.Index);
-
-                LogInfo?.Invoke($"[OnZoneExit] Player {steamId} exited zone '{zoneId}'.");
-            }
-            catch (Exception ex)
-            {
-                LogError?.Invoke($"[OnZoneExit] Unhandled error: {ex}");
-            }
-        }
-
-        public static void TryApplyPresetForPlayer(Entity playerEntity)
-        {
-            try
-            {
-                if (!_initialized) Initialize();
-
-                if (!TryGetCore(playerEntity, out var em, out var steamId, out _))
-                    return;
-
-                if (!_playerStates.TryGetValue(steamId, out var state))
-                    return;
-
-                if (string.IsNullOrWhiteSpace(state.CurrentZoneId) ||
-                    !TryGetZoneConfig(state.CurrentZoneId, out var cfg) ||
-                    cfg.PresetSlots == null ||
-                    cfg.PresetSlots.Length == 0)
-                {
-                    return;
-                }
-
-                if (!em.HasComponent<ProjectM.AbilitySlotBuffer>(playerEntity))
-                {
-                    QueuePendingSlotApply(steamId, playerEntity, state.CurrentZoneId, cfg.PresetSlots, mergeWithCurrent: true, "AbilitySlotBuffer not ready after unlock");
-                    return;
-                }
-
-                var current = GetPlayerAbilitySlots(playerEntity, out _);
-                if (current.Length != SlotCount)
-                    return;
-
-                for (int i = 0; i < cfg.PresetSlots.Length && i < SlotCount; i++)
-                    current[i] = cfg.PresetSlots[i];
-
-                if (ApplySlots(playerEntity, current, out var applyErr) && string.IsNullOrWhiteSpace(applyErr))
-                {
-                    if (cfg.ResetCooldownsOnEnter)
-                        ResetAbilityCooldowns(playerEntity);
-
-                    _pendingSlotApplies.Remove(steamId);
-                    _lastDeferredSlotWarnUtc.Remove(steamId);
-                    LogInfo?.Invoke($"[TryApplyPresetForPlayer] Applied preset slots for {steamId} in zone '{state.CurrentZoneId}'.");
-                }
-                else if (!string.IsNullOrWhiteSpace(applyErr))
-                {
-                    QueuePendingSlotApply(steamId, playerEntity, state.CurrentZoneId, cfg.PresetSlots, mergeWithCurrent: true, applyErr);
-                }
-            }
-            catch (Exception ex)
-            {
-                LogError?.Invoke($"[TryApplyPresetForPlayer] Unhandled error: {ex}");
-            }
-        }
-
-        public static bool CheckAbilityUsage(Entity playerEntity, PrefabGUID abilityGroup)
-        {
-            try
-            {
-                if (!_initialized)
-                {
-                    Initialize();
-                }
-
-                if (abilityGroup.GuidHash == 0)
-                {
-                    return false;
-                }
-
-                if (!TryGetCore(playerEntity, out _, out var steamId, out _))
-                {
-                    return false;
-                }
-
-                if (!_playerStates.TryGetValue(steamId, out var state))
-                {
-                    return false;
-                }
-
-                if (!TryGetZoneConfig(state.CurrentZoneId, out var cfg))
-                {
-                    return false;
-                }
-
-                return !cfg.IsAbilityAllowed(abilityGroup);
-            }
-            catch
-            {
-                return false;
-            }
-        }
-
-        public static void ClearStateForDisconnectedPlayer(Entity playerEntity, EntityManager em = default)
-        {
-            if (!_initialized)
-            {
-                return;
-            }
-
-            var steamId = 0UL;
-            if (playerEntity != Entity.Null && _playerIndexToSteamId.TryGetValue(playerEntity.Index, out var tracked))
-            {
-                steamId = tracked;
-            }
-            else if (GetSteamId != null)
-            {
-                try
-                {
-                    steamId = GetSteamId(playerEntity);
-                }
-                catch
-                {
-                    steamId = 0;
-                }
-            }
-
-            if (steamId == 0)
-            {
-                return;
-            }
-
-            _playerStates.Remove(steamId);
-            _pendingSlotApplies.Remove(steamId);
-            _lastDeferredSlotWarnUtc.Remove(steamId);
-            _playerIndexToSteamId.Remove(playerEntity.Index);
-            LogInfo?.Invoke($"[ClearStateForDisconnectedPlayer] Cleared ability state for {steamId}.");
-        }
-
-        public static void ProcessPendingSlotApplies()
-        {
-            if (!_initialized) return;
-            if (_pendingSlotApplies.Count == 0) return;
-            if (GetEntityManager == null) return;
-
-            var em = GetEntityManager();
-            if (em == default) return;
-
-            var now = DateTime.UtcNow;
-            var remove = new List<ulong>();
-
-            foreach (var kv in _pendingSlotApplies)
-            {
-                var steamId = kv.Key;
-                var pending = kv.Value;
-
-                if (pending == null || pending.ExpiresUtc <= now)
-                {
-                    if (pending != null && pending.ExpiresUtc <= now)
-                    {
-                        LogWarn?.Invoke($"[ProcessPendingSlotApplies] Deferred preset slots timed out for {steamId}; ability slots never became readable.");
-                    }
-
-                    remove.Add(steamId);
-                    continue;
-                }
-
-                if (!em.Exists(pending.Player))
-                {
-                    remove.Add(steamId);
-                    continue;
-                }
-
-                if (!_playerStates.TryGetValue(steamId, out var activeState) ||
-                    string.IsNullOrWhiteSpace(activeState.CurrentZoneId) ||
-                    (!string.IsNullOrWhiteSpace(pending.ZoneId) &&
-                     !string.Equals(activeState.CurrentZoneId, pending.ZoneId, StringComparison.OrdinalIgnoreCase)))
-                {
-                    remove.Add(steamId);
-                    continue;
-                }
-
-                if (pending.Slots == null || pending.Slots.Length == 0)
-                {
-                    remove.Add(steamId);
-                    continue;
-                }
-
-                PrefabGUID[] targetSlots;
-                if (pending.MergeWithCurrent || pending.Slots.Length != SlotCount)
-                {
-                    var current = GetPlayerAbilitySlots(pending.Player, out _);
-                    if (current.Length != SlotCount)
-                    {
-                        continue;
-                    }
-
-                    for (var i = 0; i < pending.Slots.Length && i < SlotCount; i++)
-                    {
-                        current[i] = pending.Slots[i];
-                    }
-
-                    targetSlots = current;
-                }
-                else
-                {
-                    targetSlots = pending.Slots;
-                }
-
-                if (!em.HasComponent(pending.Player, ComponentType.ReadOnly<ProjectM.AbilitySlotBuffer>()))
-                    continue;
-
-                if (ApplySlots(pending.Player, targetSlots, out var err) && string.IsNullOrWhiteSpace(err))
-                {
-                    if (TryGetZoneConfig(activeState.CurrentZoneId, out var cfg) && cfg.ResetCooldownsOnEnter)
-                        ResetAbilityCooldowns(pending.Player);
-
-                    LogInfo?.Invoke($"[ProcessPendingSlotApplies] Applied deferred slots for {steamId}.");
-                    remove.Add(steamId);
-                }
-            }
-
-            for (int i = 0; i < remove.Count; i++)
-            {
-                var steamId = remove[i];
-                _pendingSlotApplies.Remove(steamId);
-                _lastDeferredSlotWarnUtc.Remove(steamId);
-            }
-        }
-
-        private static bool TryGetCore(Entity entity, out EntityManager em, out ulong steamId, out string error)
-        {
-            em = default;
-            steamId = 0;
-            error = "";
-
-            if (GetEntityManager == null)
-            {
-                error = "GetEntityManager is not set";
-                return false;
-            }
-
-            if (GetSteamId == null)
-            {
-                error = "GetSteamId is not set";
-                return false;
-            }
-
-            em = GetEntityManager();
-            if (!em.Exists(entity))
-            {
-                error = $"Entity {entity} does not exist";
-                return false;
-            }
-
-            try
-            {
-                steamId = GetSteamId(entity);
-            }
-            catch (Exception ex)
-            {
-                error = $"Failed to get SteamId: {ex.Message}";
-                return false;
-            }
-
-            return true;
-        }
-
-        private static bool TryGetZoneConfig(string zoneId, out ZoneAbilityConfig config)
-        {
-            if (_zoneConfigs.TryGetValue(zoneId, out config))
-                return true;
-
-            if (_hasDefaultConfig)
-            {
-                config = _defaultConfig;
-                return true;
-            }
-
-            config = default;
-            return false;
-        }
-
-        private static PlayerAbilityState GetOrCreateState(ulong steamId)
-        {
-            if (!_playerStates.TryGetValue(steamId, out var state))
-            {
-                state = new PlayerAbilityState();
-                _playerStates.Add(steamId, state);
-            }
-            return state;
-        }
-
-        private static PrefabGUID[] GetPlayerAbilitySlots(Entity player, out string error)
-        {
-            error = "";
-
-            if (GetEntityManager == null)
-            {
-                error = "GetEntityManager not set";
-                return Array.Empty<PrefabGUID>();
-            }
-
-            var em = GetEntityManager();
-            if (!em.HasComponent<ProjectM.AbilitySlotBuffer>(player))
-            {
-                error = "No AbilitySlotBuffer";
-                return Array.Empty<PrefabGUID>();
-            }
-
-            var buffer = em.GetBuffer<ProjectM.AbilitySlotBuffer>(player);
-            if (buffer.Length <= 0)
-            {
-                return Array.Empty<PrefabGUID>();
-            }
-
-            var count = Math.Min(SlotCount, buffer.Length);
-            var slots = new PrefabGUID[count];
-            for (var i = 0; i < count; i++)
-            {
-                slots[i] = buffer[i].Ability;
-            }
-
-            return slots;
-        }
-
-        private static Dictionary<PrefabGUID, float> GetPlayerCooldowns(Entity player, PrefabGUID[] trackedSlots)
-        {
-            var result = new Dictionary<PrefabGUID, float>();
-
-            if (GetEntityManager == null || !GetEntityManager().HasBuffer<ProjectM.AbilityCooldownBuffer>(player))
-                return result;
-
-            var buffer = GetEntityManager().GetBuffer<ProjectM.AbilityCooldownBuffer>(player);
-
-            if (trackedSlots != null)
-            {
-                foreach (var slot in trackedSlots)
-                {
-                    if (slot.GuidHash == 0)
-                    {
-                        continue;
-                    }
-
-                    foreach (var cd in buffer)
-                    {
-                        if (cd.Ability.GuidHash == slot.GuidHash)
-                        {
-                            result[slot] = cd.RemainingSeconds;
-                            break;
-                        }
-                    }
-                }
-            }
-            else
-            {
-                foreach (var cd in buffer)
-                {
-                    if (cd.Ability.GuidHash != 0)
-                    {
-                        result[cd.Ability] = cd.RemainingSeconds;
-                    }
-                }
-            }
-
-            return result;
-        }
-
-        private static void ApplyCooldowns(Entity player, Dictionary<PrefabGUID, float> cooldowns)
-        {
-            if (GetEntityManager == null || cooldowns == null || cooldowns.Count == 0)
-                return;
-
-            var em = GetEntityManager();
-            if (!em.HasBuffer<ProjectM.AbilityCooldownBuffer>(player))
-                return;
-
-            var buffer = em.GetBuffer<ProjectM.AbilityCooldownBuffer>(player);
-
-            foreach (var kvp in cooldowns)
-            {
-                var updated = false;
-                for (var i = 0; i < buffer.Length; i++)
-                {
-                    if (buffer[i].Ability.GuidHash != kvp.Key.GuidHash)
-                    {
-                        continue;
-                    }
-
-                    var entry = buffer[i];
-                    entry.RemainingSeconds = kvp.Value;
-                    buffer[i] = entry;
-                    updated = true;
-                    break;
-                }
-
-                if (!updated)
-                {
-                    buffer.Add(new ProjectM.AbilityCooldownBuffer
-                    {
-                        Ability = kvp.Key,
-                        RemainingSeconds = kvp.Value
-                    });
-                }
-            }
-        }
-
-        private static bool ApplySlots(Entity player, PrefabGUID[] slots, out string error)
-        {
-            error = "";
-
-            if (GetEntityManager == null || slots == null || slots.Length != SlotCount)
-            {
-                error = "Invalid arguments";
-                return false;
-            }
-
-            var em = GetEntityManager();
-            if (!em.HasBuffer<ProjectM.AbilitySlotBuffer>(player))
-            {
-                error = "No AbilitySlotBuffer";
-                return false;
-            }
-
-            var buffer = em.GetBuffer<ProjectM.AbilitySlotBuffer>(player);
-            if (buffer.Length < SlotCount)
-            {
-                error = "AbilitySlotBuffer has insufficient entries";
-                return false;
-            }
-
-            for (var i = 0; i < SlotCount; i++)
-            {
-                var entry = buffer[i];
-                entry.Ability = slots[i];
-                buffer[i] = entry;
-            }
-
-            return true;
-        }
-
-        private static void ResetAbilityCooldowns(Entity player)
-        {
-            if (GetEntityManager == null || !GetEntityManager().HasBuffer<ProjectM.AbilityCooldownBuffer>(player))
-                return;
-
-            var em = GetEntityManager();
-            var buffer = em.GetBuffer<ProjectM.AbilityCooldownBuffer>(player);
-            buffer.Clear();
-        }
-
-        private static void QueuePendingSlotApply(ulong steamId, Entity playerEntity, string zoneId, PrefabGUID[] slots, bool mergeWithCurrent, string reason)
-        {
-            var pending = new PendingSlotApply
-            {
-                Player = playerEntity,
-                Slots = slots,
-                ZoneId = zoneId,
-                MergeWithCurrent = mergeWithCurrent,
-                ExpiresUtc = DateTime.UtcNow.AddSeconds(60)
-            };
-
-            _pendingSlotApplies[steamId] = pending;
-
-            if (!_lastDeferredSlotWarnUtc.TryGetValue(steamId, out var lastWarn) ||
-                (DateTime.UtcNow - lastWarn).TotalSeconds > DeferredSlotWarnCooldownSeconds)
-            {
-                LogWarn?.Invoke($"[QueuePendingSlotApply] Deferring preset for {steamId}; {reason}");
-                _lastDeferredSlotWarnUtc[steamId] = DateTime.UtcNow;
-            }
-        }
-
-        private static void LoadAbilityPrefabAliases()
-        {
-            _abilityAliases.Clear();
-
-            try
-            {
-                if (!File.Exists(_abilityPrefabConfigPath))
-                {
-                    var defaultContent = @"{
-  ""aliases"": {
-    ""empty"": 0,
-    ""default"": 0
-  },
-  ""presets"": {}
-}";
-                    File.WriteAllText(_abilityPrefabConfigPath, defaultContent);
-                    LogInfo?.Invoke($"[LoadAbilityPrefabAliases] Created default {_abilityPrefabConfigPath}");
-                    return;
-                }
-
-                var json = File.ReadAllText(_abilityPrefabConfigPath);
-                using var doc = JsonDocument.Parse(json);
-                var root = doc.RootElement;
-                if (root.ValueKind == JsonValueKind.Object &&
-                    root.TryGetProperty("aliases", out var aliasesEl) &&
-                    aliasesEl.ValueKind == JsonValueKind.Object)
-                {
-                    foreach (var kvp in aliasesEl.EnumerateObject())
-                    {
-                        var key = kvp.Name.Trim();
-                        var value = kvp.Value.ToString().Trim();
-                        if (string.IsNullOrWhiteSpace(key))
-                        {
-                            continue;
-                        }
-
-                        _abilityAliases[key] = value;
-                    }
-                }
-            }
-            catch (Exception ex)
-            {
-                LogError?.Invoke($"[LoadAbilityPrefabAliases] Failed to load config: {ex.Message}");
-            }
-        }
-
-        private static void LoadZoneConfigs()
-        {
-            _zoneConfigs.Clear();
-            _hasDefaultConfig = false;
-
-            try
-            {
-                if (!File.Exists(_configPath))
-                {
-                    var defaultContent = @"{
-  ""zones"": [
-    {
-      ""zoneId"": ""*"",
-      ""presetSlots"": [],
-      ""saveAndRestoreSlots"": true,
-      ""saveAndRestoreCooldowns"": true,
-      ""resetCooldownsOnEnter"": false,
-      ""resetCooldownsOnExit"": false
-    }
-  ]
-}";
-                    File.WriteAllText(_configPath, defaultContent);
-                    LogInfo?.Invoke($"[LoadZoneConfigs] Created default {_configPath}");
-                    LoadZoneConfigs();
-                    return;
-                }
-
-                var json = File.ReadAllText(_configPath);
-                using var doc = JsonDocument.Parse(json);
-                var root = doc.RootElement;
-
-                if (root.ValueKind == JsonValueKind.Object &&
-                    root.TryGetProperty("zones", out var zones) &&
-                    zones.ValueKind == JsonValueKind.Array)
-                {
-                    foreach (var zone in zones.EnumerateArray())
-                    {
-                        if (zone.ValueKind != JsonValueKind.Object)
-                        {
-                            continue;
-                        }
-
-                        if (!zone.TryGetProperty("zoneId", out var zoneIdEl))
-                        {
-                            continue;
-                        }
-
-                        var zoneId = zoneIdEl.ToString().Trim();
-                        if (string.IsNullOrWhiteSpace(zoneId))
-                        {
-                            continue;
-                        }
-
-                        var presetSlots = new List<PrefabGUID>();
-
-                        if (zone.TryGetProperty("presetSlots", out var presetSlotsEl) &&
-                            presetSlotsEl.ValueKind == JsonValueKind.Array)
-                        {
-                            foreach (var slot in presetSlotsEl.EnumerateArray())
-                            {
-                                var value = slot.ToString().Trim();
-
-                                if (_abilityAliases.TryGetValue(value, out string aliasValue))
-                                {
-                                    value = aliasValue;
-                                }
-
-                                if (ResolveAbilityGuid != null)
-                                {
-                                    var guid = ResolveAbilityGuid(value);
-                                    if (guid.HasValue)
-                                    {
-                                        presetSlots.Add(guid.Value);
-                                    }
-                                    else if (!string.IsNullOrWhiteSpace(value) && value != "0" && value != "null")
-                                    {
-                                        LogWarn?.Invoke($"[LoadZoneConfigs] Could not resolve ability '{value}' for zone '{zoneId}'");
-                                    }
-                                }
-                            }
-                        }
-
-                        var cfg = new ZoneAbilityConfig
-                        {
-                            ZoneId = zoneId,
-                            PresetSlots = presetSlots.ToArray(),
-                            SaveAndRestoreSlots = TryReadBool(zone, "saveAndRestoreSlots", defaultValue: true),
-                            SaveAndRestoreCooldowns = TryReadBool(zone, "saveAndRestoreCooldowns", defaultValue: true),
-                            ResetCooldownsOnEnter = TryReadBool(zone, "resetCooldownsOnEnter", defaultValue: false),
-                            ResetCooldownsOnExit = TryReadBool(zone, "resetCooldownsOnExit", defaultValue: false)
-                        };
-
-                        if (zoneId == "*")
-                        {
-                            _defaultConfig = cfg;
-                            _hasDefaultConfig = true;
-                        }
-                        else
-                        {
-                            _zoneConfigs[zoneId] = cfg;
-                        }
-                    }
-                }
-                else
-                {
-                    LogWarn?.Invoke("[LoadZoneConfigs] Missing or invalid 'zones' array in config; no zone overrides loaded.");
-                }
-            }
-            catch (Exception ex)
-            {
-                LogError?.Invoke($"[LoadZoneConfigs] Failed to load config: {ex.Message}");
-            }
-        }
-
-        private static bool TryReadBool(JsonElement obj, string name, bool defaultValue)
-        {
-            if (obj.TryGetProperty(name, out var el) &&
-                (el.ValueKind == JsonValueKind.True || el.ValueKind == JsonValueKind.False))
-            {
-                return el.GetBoolean();
-            }
-
-            return defaultValue;
-        }
-
-        private static string NormalizeAbilityToken(string s)
-        {
-            if (string.IsNullOrWhiteSpace(s)) return "";
-            s = s.Trim();
-            return s;
-        }
-    }
-}
diff --git a/Bluelock/Services/Coop/CoopDungeonService.cs b/Bluelock/Services/Coop/CoopDungeonService.cs
deleted file mode 100644
index 313fe88..0000000
--- a/Bluelock/Services/Coop/CoopDungeonService.cs
+++ /dev/null
@@ -1,230 +0,0 @@
-using System;
-using System.Collections.Generic;
-using Unity.Entities;
-using VAuto.Zone.Core;
-using VLifecycle;
-
-namespace VAuto.Zone.Services.Coop
-{
-    /// <summary>
-    /// Template 1 scaffold for co-op progressive dungeons.
-    /// </summary>
-    public sealed class CoopDungeonService
-    {
-        private static readonly Lazy<CoopDungeonService> _lazy = new(() => new CoopDungeonService());
-        public static CoopDungeonService Instance => _lazy.Value;
-
-        private readonly Dictionary<CoopInstanceKey, CoopDungeonState> _instances = new();
-        private const int MaxDeathsPerPlayer = 3;
-        private const int DefaultMaxTier = 5;
-
-        private CoopDungeonService() { }
-
-        public bool StartInstance(string templateId, ulong clanId, ulong platformId)
-        {
-            if (string.IsNullOrWhiteSpace(templateId))
-            {
-                templateId = "Coop_Dungeon_Template";
-            }
-
-            if (platformId == 0)
-            {
-                ZoneCore.Log?.LogWarning($"[CoopDungeonService] StartInstance received invalid platformId=0 for {templateId}:{clanId}");
-                return false;
-            }
-
-            var key = new CoopInstanceKey(templateId, clanId);
-            if (!_instances.TryGetValue(key, out var state))
-            {
-                state = new CoopDungeonState
-                {
-                    TemplateId = templateId,
-                    ClanId = clanId,
-                    CurrentTier = 1,
-                    MaxTier = DefaultMaxTier,
-                    MaxDeathsPerPlayer = MaxDeathsPerPlayer,
-                    IsActive = true,
-                    Status = CoopDungeonStatus.Active,
-                    StartedUtc = DateTime.UtcNow,
-                    LastProgressUtc = DateTime.UtcNow,
-                    CompletedUtc = null,
-                    FailureReason = string.Empty
-                };
-                _instances[key] = state;
-            }
-            else if (state.IsTerminal)
-            {
-                // Re-open terminal instance on explicit start.
-                state.CurrentTier = 1;
-                state.PlayerDeaths.Clear();
-                state.ActivePlayers.Clear();
-                state.Status = CoopDungeonStatus.Active;
-                state.CompletedUtc = null;
-                state.FailureReason = string.Empty;
-                state.StartedUtc = DateTime.UtcNow;
-                state.LastProgressUtc = DateTime.UtcNow;
-            }
-
-            state.ActivePlayers.Add(platformId);
-            state.PlayerDeaths.TryAdd(platformId, 0);
-            state.IsActive = true;
-            state.Status = CoopDungeonStatus.Active;
-            ZoneCore.Log?.LogInfo($"[CoopDungeonService] Started/Joined instance {key} for player {platformId}");
-            return true;
-        }
-
-        public void Progress(string templateId, ulong clanId, ulong platformId = 0)
-        {
-            var key = new CoopInstanceKey(templateId, clanId);
-            if (!_instances.TryGetValue(key, out var state) || !state.IsActive || state.IsTerminal)
-            {
-                return;
-            }
-
-            if (platformId != 0)
-            {
-                state.ActivePlayers.Add(platformId);
-                state.PlayerDeaths.TryAdd(platformId, 0);
-            }
-
-            if (state.CurrentTier < state.MaxTier)
-            {
-                state.CurrentTier++;
-                state.LastProgressUtc = DateTime.UtcNow;
-            }
-
-            if (state.CurrentTier >= state.MaxTier)
-            {
-                state.Status = CoopDungeonStatus.Completed;
-                state.IsActive = false;
-                state.CompletedUtc = DateTime.UtcNow;
-            }
-
-            ZoneCore.Log?.LogInfo($"[CoopDungeonService] Progressed {key} to tier {state.CurrentTier}");
-        }
-
-        public void MarkFinal(string templateId, ulong clanId, ulong platformId = 0)
-        {
-            var key = new CoopInstanceKey(templateId, clanId);
-            if (_instances.TryGetValue(key, out var state) && state.IsActive && !state.IsTerminal)
-            {
-                if (platformId != 0)
-                {
-                    state.ActivePlayers.Add(platformId);
-                    state.PlayerDeaths.TryAdd(platformId, 0);
-                }
-
-                state.CurrentTier = state.MaxTier;
-                state.LastProgressUtc = DateTime.UtcNow;
-                ZoneCore.Log?.LogInfo($"[CoopDungeonService] Final chamber entered for {key}");
-            }
-        }
-
-        public void Exit(string templateId, ulong clanId, ulong platformId)
-        {
-            var key = new CoopInstanceKey(templateId, clanId);
-            if (!_instances.TryGetValue(key, out var state))
-            {
-                return;
-            }
-
-            state.ActivePlayers.Remove(platformId);
-            TeleportToReturnPosition(platformId, contextTemplateId: templateId, contextClanId: clanId);
-
-            if (state.ActivePlayers.Count == 0)
-            {
-                state.IsActive = false;
-                if (state.Status == CoopDungeonStatus.Active)
-                {
-                    state.Status = CoopDungeonStatus.Completed;
-                }
-
-                state.CompletedUtc = DateTime.UtcNow;
-                _instances.Remove(key);
-                ZoneCore.Log?.LogInfo($"[CoopDungeonService] Instance cleaned up: {key}");
-            }
-        }
-
-        public bool RecordDeath(string templateId, ulong clanId, ulong platformId)
-        {
-            var key = new CoopInstanceKey(templateId, clanId);
-            if (!_instances.TryGetValue(key, out var state) || !state.IsActive || state.IsTerminal)
-            {
-                return false;
-            }
-
-            var deaths = state.PlayerDeaths.TryGetValue(platformId, out var current) ? current + 1 : 1;
-            state.PlayerDeaths[platformId] = deaths;
-            if (deaths > state.MaxDeathsPerPlayer)
-            {
-                state.ActivePlayers.Remove(platformId);
-                ZoneCore.Log?.LogInfo($"[CoopDungeonService] Player {platformId} exceeded death cap and was removed from {key}");
-                TeleportToReturnPosition(platformId, contextTemplateId: templateId, contextClanId: clanId);
-
-                if (state.ActivePlayers.Count == 0)
-                {
-                    state.IsActive = false;
-                    state.Status = CoopDungeonStatus.Failed;
-                    state.CompletedUtc = DateTime.UtcNow;
-                    state.FailureReason = "All active players were eliminated";
-                    _instances.Remove(key);
-                    ZoneCore.Log?.LogWarning($"[CoopDungeonService] Instance failed (all eliminated): {key}");
-                }
-
-                return false;
-            }
-
-            RespawnInsideDungeon(platformId, state.CurrentTier);
-
-            return true;
-        }
-
-        public bool TryGetState(string templateId, ulong clanId, out CoopDungeonState state)
-        {
-            return _instances.TryGetValue(new CoopInstanceKey(templateId, clanId), out state);
-        }
-
-        private static void RespawnInsideDungeon(ulong platformId, int tier)
-        {
-            ZoneCore.Log?.LogDebug($"[CoopDungeonService] Respawn requested for player {platformId} at tier {tier}");
-        }
-
-        private static void TeleportToReturnPosition(ulong platformId, string contextTemplateId, ulong contextClanId)
-        {
-            ZoneCore.Log?.LogDebug($"[CoopDungeonService] Return teleport requested for player {platformId} from {contextTemplateId}:{contextClanId}");
-        }
-
-        public static (string templateId, ulong clanId) ResolveKey(LifecycleContext context)
-        {
-            var templateId = "Coop_Dungeon_Template";
-            ulong clanId = 0;
-
-            if (context?.Data != null)
-            {
-                if (context.Data.TryGetValue("templateId", out var rawTemplate) && rawTemplate is string t && !string.IsNullOrWhiteSpace(t))
-                {
-                    templateId = t;
-                }
-
-                if (context.Data.TryGetValue("clanId", out var rawClan))
-                {
-                    switch (rawClan)
-                    {
-                        case ulong u:
-                            clanId = u;
-                            break;
-                        case long l when l >= 0:
-                            clanId = (ulong)l;
-                            break;
-                        case int i when i >= 0:
-                            clanId = (ulong)i;
-                            break;
-                    }
-                }
-            }
-
-            return (templateId, clanId);
-        }
-
-    }
-}
diff --git a/Bluelock/Services/Coop/CoopDungeonState.cs b/Bluelock/Services/Coop/CoopDungeonState.cs
deleted file mode 100644
index 2f02647..0000000
--- a/Bluelock/Services/Coop/CoopDungeonState.cs
+++ /dev/null
@@ -1,74 +0,0 @@
-using System;
-using System.Collections.Generic;
-
-namespace VAuto.Zone.Services.Coop
-{
-    public enum CoopDungeonStatus
-    {
-        Inactive = 0,
-        Active = 1,
-        Completed = 2,
-        Failed = 3
-    }
-
-    public readonly struct ZoneInstanceKey : IEquatable<ZoneInstanceKey>
-    {
-        public readonly string ZoneId;
-        public readonly ulong ClanId;
-
-        public ZoneInstanceKey(string zoneId, ulong clanId)
-        {
-            ZoneId = zoneId ?? string.Empty;
-            ClanId = clanId;
-        }
-
-        public bool Equals(ZoneInstanceKey other) =>
-            string.Equals(ZoneId, other.ZoneId, StringComparison.OrdinalIgnoreCase) && ClanId == other.ClanId;
-
-        public override bool Equals(object obj) => obj is ZoneInstanceKey other && Equals(other);
-
-        public override int GetHashCode() => HashCode.Combine(ZoneId?.ToLowerInvariant(), ClanId);
-
-        public override string ToString() => $"{ZoneId}:{ClanId}";
-    }
-
-    public readonly struct CoopInstanceKey : IEquatable<CoopInstanceKey>
-    {
-        public readonly string TemplateId;
-        public readonly ulong ClanId;
-
-        public CoopInstanceKey(string templateId, ulong clanId)
-        {
-            TemplateId = templateId ?? string.Empty;
-            ClanId = clanId;
-        }
-
-        public bool Equals(CoopInstanceKey other) =>
-            string.Equals(TemplateId, other.TemplateId, StringComparison.OrdinalIgnoreCase) && ClanId == other.ClanId;
-
-        public override bool Equals(object obj) => obj is CoopInstanceKey other && Equals(other);
-
-        public override int GetHashCode() => HashCode.Combine(TemplateId?.ToLowerInvariant(), ClanId);
-
-        public override string ToString() => $"{TemplateId}:{ClanId}";
-    }
-
-    public sealed class CoopDungeonState
-    {
-        public string TemplateId { get; set; } = string.Empty;
-        public ulong ClanId { get; set; }
-        public int CurrentTier { get; set; } = 1;
-        public int MaxTier { get; set; } = 5;
-        public int MaxDeathsPerPlayer { get; set; } = 3;
-        public Dictionary<ulong, int> PlayerDeaths { get; } = new();
-        public HashSet<ulong> ActivePlayers { get; } = new();
-        public bool IsActive { get; set; }
-        public CoopDungeonStatus Status { get; set; } = CoopDungeonStatus.Inactive;
-        public DateTime StartedUtc { get; set; } = DateTime.UtcNow;
-        public DateTime LastProgressUtc { get; set; } = DateTime.UtcNow;
-        public DateTime? CompletedUtc { get; set; }
-        public string FailureReason { get; set; } = string.Empty;
-
-        public bool IsTerminal => Status is CoopDungeonStatus.Completed or CoopDungeonStatus.Failed;
-    }
-}
diff --git a/Bluelock/Services/Coop/CoopExitHandler.cs b/Bluelock/Services/Coop/CoopExitHandler.cs
deleted file mode 100644
index e7d372b..0000000
--- a/Bluelock/Services/Coop/CoopExitHandler.cs
+++ /dev/null
@@ -1,18 +0,0 @@
-using VLifecycle;
-
-namespace VAuto.Zone.Services.Coop
-{
-    public sealed class CoopExitHandler : IDomainLifecycleHandler
-    {
-        public void OnEnter(LifecycleContext context)
-        {
-            // no-op
-        }
-
-        public void OnExit(LifecycleContext context)
-        {
-            var (templateId, clanId) = CoopDungeonService.ResolveKey(context);
-            CoopDungeonService.Instance.Exit(templateId, clanId, context?.PlatformId ?? 0);
-        }
-    }
-}
diff --git a/Bluelock/Services/Coop/CoopFinalHandler.cs b/Bluelock/Services/Coop/CoopFinalHandler.cs
deleted file mode 100644
index b51d8c9..0000000
--- a/Bluelock/Services/Coop/CoopFinalHandler.cs
+++ /dev/null
@@ -1,18 +0,0 @@
-using VLifecycle;
-
-namespace VAuto.Zone.Services.Coop
-{
-    public sealed class CoopFinalHandler : IDomainLifecycleHandler
-    {
-        public void OnEnter(LifecycleContext context)
-        {
-            var (templateId, clanId) = CoopDungeonService.ResolveKey(context);
-            CoopDungeonService.Instance.MarkFinal(templateId, clanId, context?.PlatformId ?? 0);
-        }
-
-        public void OnExit(LifecycleContext context)
-        {
-            // no-op
-        }
-    }
-}
diff --git a/Bluelock/Services/Coop/CoopProgressHandler.cs b/Bluelock/Services/Coop/CoopProgressHandler.cs
deleted file mode 100644
index 463ce51..0000000
--- a/Bluelock/Services/Coop/CoopProgressHandler.cs
+++ /dev/null
@@ -1,18 +0,0 @@
-using VLifecycle;
-
-namespace VAuto.Zone.Services.Coop
-{
-    public sealed class CoopProgressHandler : IDomainLifecycleHandler
-    {
-        public void OnEnter(LifecycleContext context)
-        {
-            var (templateId, clanId) = CoopDungeonService.ResolveKey(context);
-            CoopDungeonService.Instance.Progress(templateId, clanId, context?.PlatformId ?? 0);
-        }
-
-        public void OnExit(LifecycleContext context)
-        {
-            // no-op
-        }
-    }
-}
diff --git a/Bluelock/Services/Coop/CoopStartHandler.cs b/Bluelock/Services/Coop/CoopStartHandler.cs
deleted file mode 100644
index 8fae5d3..0000000
--- a/Bluelock/Services/Coop/CoopStartHandler.cs
+++ /dev/null
@@ -1,18 +0,0 @@
-using VLifecycle;
-
-namespace VAuto.Zone.Services.Coop
-{
-    public sealed class CoopStartHandler : IDomainLifecycleHandler
-    {
-        public void OnEnter(LifecycleContext context)
-        {
-            var (templateId, clanId) = CoopDungeonService.ResolveKey(context);
-            CoopDungeonService.Instance.StartInstance(templateId, clanId, context?.PlatformId ?? 0);
-        }
-
-        public void OnExit(LifecycleContext context)
-        {
-            // no-op
-        }
-    }
-}
diff --git a/Bluelock/Services/GlowZoneEntryService.cs b/Bluelock/Services/GlowZoneEntryService.cs
deleted file mode 100644
index 86a475f..0000000
--- a/Bluelock/Services/GlowZoneEntryService.cs
+++ /dev/null
@@ -1,248 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Text.Json;
-using System.Text.Json.Serialization;
-using BepInEx;
-using ProjectM;
-using Stunlock.Core;
-using Unity.Mathematics;
-using VAuto.Zone.Core;
-
-namespace VAuto.Zone.Services
-{
-    /// <summary>
-    /// Service for loading GlowZoneEntry scan files from config/Bluelock/glow_zones/
-    /// These files define zone templates that can be referenced by zones.
-    /// </summary>
-    public static class GlowZoneEntryService
-    {
-        private static readonly string GlowZonesRoot = Path.Combine(Paths.ConfigPath, "Bluelock", "glow_zones");
-        
-        private static readonly JsonSerializerOptions JsonOptions = new(JsonSerializerDefaults.Web)
-        {
-            PropertyNameCaseInsensitive = true,
-            WriteIndented = true
-        };
-
-        private static readonly Dictionary<string, GlowZoneEntry> _loadedEntries = new(StringComparer.OrdinalIgnoreCase);
-        private static bool _initialized;
-
-        /// <summary>
-        /// Initialize and load all GlowZoneEntry scan files
-        /// </summary>
-        public static void Initialize()
-        {
-            if (_initialized) return;
-            
-            LoadAllGlowZoneEntries();
-            _initialized = true;
-            ZoneCore.LogInfo($"[GlowZoneEntryService] Initialized with {_loadedEntries.Count} zone entries");
-        }
-
-        /// <summary>
-        /// Reload all GlowZoneEntry scan files
-        /// </summary>
-        public static void Reload()
-        {
-            _loadedEntries.Clear();
-            LoadAllGlowZoneEntries();
-            ZoneCore.LogInfo($"[GlowZoneEntryService] Reloaded with {_loadedEntries.Count} zone entries");
-        }
-
-        /// <summary>
-        /// Load all GlowZoneEntry scan files from the glow_zones directory
-        /// </summary>
-        private static void LoadAllGlowZoneEntries()
-        {
-            try
-            {
-                if (!Directory.Exists(GlowZonesRoot))
-                {
-                    Directory.CreateDirectory(GlowZonesRoot);
-                    CreateDefaultGlowZonesConfig();
-                    return;
-                }
-
-                var files = Directory.GetFiles(GlowZonesRoot, "*.json");
-                if (files.Length == 0)
-                {
-                    CreateDefaultGlowZonesConfig();
-                    return;
-                }
-
-                foreach (var file in files)
-                {
-                    LoadGlowZoneFile(file);
-                }
-
-                ZoneCore.LogInfo($"[GlowZoneEntryService] Loaded {_loadedEntries.Count} glow zone entries from {files.Length} files");
-            }
-            catch (Exception ex)
-            {
-                ZoneCore.LogError($"[GlowZoneEntryService] Failed to load glow zones: {ex.Message}");
-            }
-        }
-
-        /// <summary>
-        /// Load a single GlowZoneEntry JSON file
-        /// </summary>
-        private static void LoadGlowZoneFile(string filePath)
-        {
-            try
-            {
-                var json = File.ReadAllText(filePath);
-                var entries = JsonSerializer.Deserialize<List<GlowZoneEntry>>(json, JsonOptions);
-                
-                if (entries == null || entries.Count == 0)
-                {
-                    ZoneCore.LogWarning($"[GlowZoneEntryService] No entries found in {filePath}");
-                    return;
-                }
-
-                foreach (var entry in entries)
-                {
-                    if (string.IsNullOrWhiteSpace(entry.Name))
-                    {
-                        continue;
-                    }
-
-                    _loadedEntries[entry.Name] = entry;
-                    ZoneCore.LogDebug($"[GlowZoneEntryService] Loaded glow zone: {entry.Name}");
-                }
-            }
-            catch (Exception ex)
-            {
-                ZoneCore.LogError($"[GlowZoneEntryService] Failed to load {filePath}: {ex.Message}");
-            }
-        }
-
-        /// <summary>
-        /// Create a default glow_zones.json file with example entries
-        /// </summary>
-        private static void CreateDefaultGlowZonesConfig()
-        {
-            var defaultConfig = new List<GlowZoneEntry>
-            {
-                new GlowZoneEntry
-                {
-                    Name = "ArenaGlow",
-                    Position = new float3(0, 0.3f, 0),
-                    Radius = 45f,
-                    PrefabIds = new List<PrefabGUID> { new PrefabGUID(1144832236) },
-                    RotationIntervalSeconds = 300f,
-                    IsActive = true
-                },
-                new GlowZoneEntry
-                {
-                    Name = "BossGlow",
-                    Position = new float3(0, 0.5f, 0),
-                    Radius = 20f,
-                    PrefabIds = new List<PrefabGUID> { new PrefabGUID(230163020) },
-                    RotationIntervalSeconds = 0f,
-                    IsActive = true
-                }
-            };
-
-            var defaultPath = Path.Combine(GlowZonesRoot, "glow_zones.json");
-            try
-            {
-                var json = JsonSerializer.Serialize(defaultConfig, JsonOptions);
-                File.WriteAllText(defaultPath, json);
-                ZoneCore.LogInfo($"[GlowZoneEntryService] Created default glow_zones.json at {defaultPath}");
-                
-                foreach (var entry in defaultConfig)
-                {
-                    _loadedEntries[entry.Name] = entry;
-                }
-            }
-            catch (Exception ex)
-            {
-                ZoneCore.LogError($"[GlowZoneEntryService] Failed to create default config: {ex.Message}");
-            }
-        }
-
-        /// <summary>
-        /// Get a GlowZoneEntry by name
-        /// </summary>
-        public static bool TryGetEntry(string name, out GlowZoneEntry entry)
-        {
-            return _loadedEntries.TryGetValue(name, out entry);
-        }
-
-        /// <summary>
-        /// Get all loaded GlowZoneEntry names
-        /// </summary>
-        public static IReadOnlyList<string> GetAllEntryNames()
-        {
-            return new List<string>(_loadedEntries.Keys);
-        }
-
-        /// <summary>
-        /// Get the count of loaded entries
-        /// </summary>
-        public static int GetEntryCount()
-        {
-            return _loadedEntries.Count;
-        }
-    }
-
-    /// <summary>
-    /// Represents a glow zone entry with position, rotation, and prefab information.
-    /// This is loaded from JSON scan files in config/Bluelock/glow_zones/
-    /// </summary>
-    public class GlowZoneEntry
-    {
-        [JsonPropertyName("name")]
-        public string Name { get; set; } = string.Empty;
-
-        [JsonPropertyName("position")]
-        public float3 Position { get; set; }
-
-        [JsonPropertyName("x")]
-        public float X 
-        { 
-            get => Position.x; 
-            set => Position = new float3(value, Position.y, Position.z); 
-        }
-
-        [JsonPropertyName("y")]
-        public float Y 
-        { 
-            get => Position.y; 
-            set => Position = new float3(Position.x, value, Position.z); 
-        }
-
-        [JsonPropertyName("z")]
-        public float Z 
-        { 
-            get => Position.z; 
-            set => Position = new float3(Position.x, Position.y, value); 
-        }
-
-        [JsonPropertyName("radius")]
-        public float Radius { get; set; }
-
-        [JsonPropertyName("prefabIds")]
-        public List<PrefabGUID> PrefabIds { get; set; } = new List<PrefabGUID>();
-
-        [JsonPropertyName("prefabId")]
-        public int PrefabId 
-        { 
-            get => PrefabIds.Count > 0 ? PrefabIds[0].GuidHash : 0;
-            set
-            {
-                if (PrefabIds.Count == 0)
-                    PrefabIds.Add(new PrefabGUID(value));
-                else
-                    PrefabIds[0] = new PrefabGUID(value);
-            }
-        }
-
-        [JsonPropertyName("rotationIntervalSeconds")]
-        public float RotationIntervalSeconds { get; set; }
-
-        [JsonPropertyName("isActive")]
-        public bool IsActive { get; set; } = true;
-    }
-}
diff --git a/Bluelock/Services/KitService.cs b/Bluelock/Services/KitService.cs
index f2b5037..4c9626f 100644
--- a/Bluelock/Services/KitService.cs
+++ b/Bluelock/Services/KitService.cs
@@ -264,10 +264,12 @@ namespace VAuto.Zone.Services
                         ClearTrackingByPlatform(platformIdExit, player.Index);
                     }
 
-                    // Always restore snapshot on exit (KitRestoreOnExitValue controls messaging only)
-                    if (!PlayerSnapshotService.RestoreSnapshot(player, out var snapshotError))
+                    if (Plugin.KitRestoreOnExitValue)
                     {
-                        _log.LogDebug($"[KitService] Snapshot restore skipped/failed in ArenaBuild mode for zone '{zoneId}': {snapshotError}");
+                        if (!PlayerSnapshotService.RestoreSnapshot(player, out var snapshotError))
+                        {
+                            _log.LogDebug($"[KitService] Snapshot restore skipped/failed in ArenaBuild mode for zone '{zoneId}': {snapshotError}");
+                        }
                     }
 
                     ArenaBuildExecutor.TryClearBuild(player, em);
@@ -803,16 +805,6 @@ namespace VAuto.Zone.Services
                 // Weapon
                 new() { PrefabName = weapon, Amount = 1 },
 
-                // Weapon coatings/enchantments
-                new() { PrefabName = "Item_Ingredient_Whetstone", Amount = 10 },
-                new() { PrefabName = "Item_Ingredient_MutantGrease", Amount = 10 },
-
-                // Jewels (T02)
-                new() { PrefabName = "Item_Jewel_Blood_T02", Amount = 2 },
-                new() { PrefabName = "Item_Jewel_Storm_T02", Amount = 2 },
-                new() { PrefabName = "Item_Jewel_Unholy_T02", Amount = 2 },
-                new() { PrefabName = "Item_Jewel_Frost_T02", Amount = 2 },
-
                 // Consumables
                 new() { PrefabName = "Item_Consumable_Salve_Vermin", Amount = 10 },
                 new() { PrefabName = "Item_Consumable_HealingPotion_T02", Amount = 10 },
@@ -859,8 +851,8 @@ namespace VAuto.Zone.Services
                 var rootDir = Path.Combine(Paths.ConfigPath, "Bluelock");
                 Directory.CreateDirectory(rootDir);
 
-                var rootPath = Path.Combine(rootDir, "Bluelock.kits.json");
-                var legacyPath = Path.Combine(rootDir, "config", "Bluelock.kits.json");
+                var rootPath = Path.Combine(rootDir, "VAuto.Kits.json");
+                var legacyPath = Path.Combine(rootDir, "config", "VAuto.Kits.json");
                 try
                 {
                     if (!File.Exists(rootPath) && File.Exists(legacyPath))
diff --git a/Bluelock/Services/Lifecycle/BluelockLifecycleAdapterRegistry.cs b/Bluelock/Services/Lifecycle/BluelockLifecycleAdapterRegistry.cs
deleted file mode 100644
index b4844f3..0000000
--- a/Bluelock/Services/Lifecycle/BluelockLifecycleAdapterRegistry.cs
+++ /dev/null
@@ -1,409 +0,0 @@
-using System;
-using System.Collections.Generic;
-using Unity.Entities;
-using VAutomationCore.Core;
-using VAuto.Zone.Core;
-using VAuto.Zone.Models;
-using VAuto.Zone.Core.Components;
-using VAuto.Zone.Services;
-using VAuto.Zone.Services.Coop;
-using VLifecycle;
-
-namespace VAuto.Zone.Services.Lifecycle
-{
-    /// <summary>
-    /// Registry that bridges lifecycle action tokens to Bluelock domain services.
-    /// Registers only IDomainLifecycleHandler handlers with CycleBorn orchestration.
-    /// </summary>
-    public sealed class BluelockLifecycleAdapterRegistry
-    {
-        private static BluelockLifecycleAdapterRegistry _instance;
-        private static readonly object _lock = new object();
-
-        private readonly HashSet<string> _domainTokens = new(StringComparer.OrdinalIgnoreCase);
-        private bool _isInitialized;
-
-        /// <summary>
-        /// Singleton instance
-        /// </summary>
-        public static BluelockLifecycleAdapterRegistry Instance
-        {
-            get
-            {
-                if (_instance == null)
-                {
-                    lock (_lock)
-                    {
-                        _instance ??= new BluelockLifecycleAdapterRegistry();
-                    }
-                }
-                return _instance;
-            }
-        }
-
-        /// <summary>
-        /// Initialize the registry with all domain token handlers
-        /// </summary>
-        public void Initialize()
-        {
-            if (_isInitialized) return;
-
-            RegisterDomainHandlers();
-            RegisterCoopHandlers();
-            _isInitialized = true;
-
-            ZoneCore.Log?.LogInfo("[BluelockLifecycleAdapterRegistry] Initialized with domain token handlers");
-        }
-
-        private void RegisterDomainHandlers()
-        {
-            Register("apply_kit", new DelegateDomainLifecycleHandler(onEnter: ApplyKitOnEnter));
-            Register("restore_kit_snapshot", new DelegateDomainLifecycleHandler(onExit: RestoreKitOnExit));
-
-            Register("apply_templates", new DelegateDomainLifecycleHandler(onEnter: ApplyTemplatesOnEnter));
-
-            Register("apply_abilities", new DelegateDomainLifecycleHandler(onEnter: ApplyAbilitiesOnEnter));
-            Register("restore_abilities", new DelegateDomainLifecycleHandler(onExit: RestoreAbilitiesOnExit));
-
-            Register("boss_enter", new DelegateDomainLifecycleHandler(onEnter: BossEnter));
-            Register("boss_exit", new DelegateDomainLifecycleHandler(onExit: BossExit));
-
-            Register("glow_spawn", new DelegateDomainLifecycleHandler(onEnter: GlowSpawnOnEnter));
-            Register("glow_reset", new DelegateDomainLifecycleHandler(onExit: GlowResetOnExit));
-
-            Register("spellbookgrant", new DelegateDomainLifecycleHandler(onEnter: SpellbookGrantOnEnter));
-            Register("spellbookrestore", new DelegateDomainLifecycleHandler(onExit: SpellbookRestoreOnExit));
-
-            Register("vbloodunlock", new DelegateDomainLifecycleHandler(onEnter: VBloodUnlockOnEnter));
-
-            Register("bossarena_start", new DelegateDomainLifecycleHandler(onEnter: BossArenaStartOnEnter));
-            Register("bossarena_end", new DelegateDomainLifecycleHandler(onExit: BossArenaEndOnExit));
-            Register("glowcorners_show", new DelegateDomainLifecycleHandler(onEnter: GlowCornersShowOnEnter));
-            Register("glowcorners_hide", new DelegateDomainLifecycleHandler(onExit: GlowCornersHideOnExit));
-        }
-
-        private void RegisterCoopHandlers()
-        {
-            Register("coop_start", new CoopStartHandler());
-            Register("coop_progress", new CoopProgressHandler());
-            Register("coop_final", new CoopFinalHandler());
-            Register("coop_exit", new CoopExitHandler());
-        }
-
-        private void Register(string token, IDomainLifecycleHandler handler)
-        {
-            if (string.IsNullOrWhiteSpace(token) || handler == null)
-                return;
-
-            var resolved = NormalizeToken(token);
-            _domainTokens.Add(resolved);
-
-            try
-            {
-                LifecycleRegistry.Instance.Register(resolved, handler);
-            }
-            catch (Exception ex)
-            {
-                ZoneCore.Log?.LogWarning($"[BluelockLifecycleAdapterRegistry] Failed to register token '{resolved}': {ex.Message}");
-            }
-        }
-
-        /// <summary>
-        /// Check if a token is a domain token
-        /// </summary>
-        public bool IsDomainToken(string token)
-        {
-
-            if (string.IsNullOrWhiteSpace(token))
-            {
-                return false;
-            }
-
-            var resolved = NormalizeToken(token);
-            return _domainTokens.Contains(resolved);
-        }
-
-        private static string NormalizeToken(string token)
-        {
-            return token?.Trim() ?? string.Empty;
-        }
-
-        private sealed class DelegateDomainLifecycleHandler : IDomainLifecycleHandler
-        {
-            private readonly Action<LifecycleContext> _onEnter;
-            private readonly Action<LifecycleContext> _onExit;
-
-            public DelegateDomainLifecycleHandler(Action<LifecycleContext> onEnter = null, Action<LifecycleContext> onExit = null)
-            {
-                _onEnter = onEnter;
-                _onExit = onExit;
-            }
-
-            public void OnEnter(LifecycleContext context)
-            {
-                _onEnter?.Invoke(context);
-            }
-
-            public void OnExit(LifecycleContext context)
-            {
-                _onExit?.Invoke(context);
-            }
-        }
-
-        private static EntityManager ResolveEntityManager(LifecycleContext context)
-        {
-            if (context?.Data != null &&
-                context.Data.TryGetValue("EntityManager", out var raw) &&
-                raw is EntityManager em)
-            {
-                return em;
-            }
-
-            return UnifiedCore.EntityManager;
-        }
-
-        private static void ApplyKitOnEnter(LifecycleContext context)
-        {
-            try
-            {
-                if (!Plugin.KitAutoEquipEnabledValue || context == null) return;
-                KitService.ApplyKitOnEnter(context.ZoneId, context.Player, ResolveEntityManager(context));
-            }
-            catch (Exception ex)
-            {
-                ZoneCore.Log?.LogError($"[BluelockLifecycleAdapterRegistry.apply_kit] Failed: {ex.Message}");
-            }
-        }
-
-        private static void RestoreKitOnExit(LifecycleContext context)
-        {
-            try
-            {
-                if (!Plugin.KitRestoreOnExitValue || context == null) return;
-                KitService.RestoreKitOnExit(context.ZoneId, context.Player, ResolveEntityManager(context));
-            }
-            catch (Exception ex)
-            {
-                ZoneCore.Log?.LogError($"[BluelockLifecycleAdapterRegistry.restore_kit_snapshot] Failed: {ex.Message}");
-            }
-        }
-
-        private static void ApplyTemplatesOnEnter(LifecycleContext context)
-        {
-            try
-            {
-                if (context == null) return;
-                var em = ResolveEntityManager(context);
-                var results = ZoneTemplateService.SpawnAllZoneTemplates(context.ZoneId, em, context.Player);
-                foreach (var result in results)
-                {
-                    if (!result.Success)
-                    {
-                        ZoneCore.Log?.LogWarning($"[BluelockLifecycleAdapterRegistry.apply_templates] Template '{result.TemplateType}' failed: {result.Error}");
-                    }
-                }
-            }
-            catch (Exception ex)
-            {
-                ZoneCore.Log?.LogError($"[BluelockLifecycleAdapterRegistry.apply_templates] Failed: {ex.Message}");
-            }
-        }
-
-        private static void ApplyAbilitiesOnEnter(LifecycleContext context)
-        {
-            try
-            {
-                if (context == null) return;
-                AbilityZoneService.OnZoneEnter(context.Player, context.ZoneId);
-            }
-            catch (Exception ex)
-            {
-                ZoneCore.Log?.LogError($"[BluelockLifecycleAdapterRegistry.apply_abilities] Failed: {ex.Message}");
-            }
-        }
-
-        private static void RestoreAbilitiesOnExit(LifecycleContext context)
-        {
-            try
-            {
-                if (context == null) return;
-                AbilityZoneService.OnZoneExit(context.Player, context.ZoneId);
-            }
-            catch (Exception ex)
-            {
-                ZoneCore.Log?.LogError($"[BluelockLifecycleAdapterRegistry.restore_abilities] Failed: {ex.Message}");
-            }
-        }
-
-        private static void BossEnter(LifecycleContext context)
-        {
-            try
-            {
-                if (context == null) return;
-                if (ZoneBossSpawnerService.TryHandlePlayerEnter(context.Player, context.ZoneId, out var message))
-                {
-                    ZoneCore.Log?.LogInfo($"[BluelockLifecycleAdapterRegistry.boss_enter] {message}");
-                    VAutomationCore.Core.Services.GameActionService.TrySendSystemMessageToAll($"[ZONE EVENT] {message}");
-                }
-            }
-            catch (Exception ex)
-            {
-                ZoneCore.Log?.LogError($"[BluelockLifecycleAdapterRegistry.boss_enter] Failed: {ex.Message}");
-            }
-        }
-
-        private static void BossExit(LifecycleContext context)
-        {
-            try
-            {
-                if (context == null) return;
-                ZoneBossSpawnerService.HandlePlayerExit(context.Player, context.ZoneId);
-            }
-            catch (Exception ex)
-            {
-                ZoneCore.Log?.LogError($"[BluelockLifecycleAdapterRegistry.boss_exit] Failed: {ex.Message}");
-            }
-        }
-
-        private static void GlowSpawnOnEnter(LifecycleContext context)
-        {
-            try
-            {
-                if (context == null) return;
-                var playersInZone = Plugin.GetPlayersInZoneCount(context.ZoneId);
-                if (!ZoneConfigService.ShouldAutoSpawnGlowOnEnter(context.ZoneId) || playersInZone != 0)
-                {
-                    return;
-                }
-
-                var zone = ZoneConfigService.GetZoneById(context.ZoneId);
-                if (zone == null) return;
-
-                var em = ResolveEntityManager(context);
-                GlowTileService.PrepareForZoneActivation(context.ZoneId, em);
-                var spawn = GlowTileService.TryAutoSpawnGlowTiles(zone, em);
-                if (!spawn.Success)
-                {
-                    ZoneCore.Log?.LogWarning($"[BluelockLifecycleAdapterRegistry.glow_spawn] Failed: {spawn.Error}");
-                }
-            }
-            catch (Exception ex)
-            {
-                ZoneCore.Log?.LogError($"[BluelockLifecycleAdapterRegistry.glow_spawn] Failed: {ex.Message}");
-            }
-        }
-
-        private static void GlowResetOnExit(LifecycleContext context)
-        {
-            try
-            {
-                if (context == null) return;
-                var playersInZone = Plugin.GetPlayersInZoneCount(context.ZoneId);
-                if (ZoneConfigService.ShouldAutoSpawnGlowOnReset(context.ZoneId) && playersInZone <= 1)
-                {
-                    GlowTileService.ClearZoneGlow(context.ZoneId, ResolveEntityManager(context));
-                }
-            }
-            catch (Exception ex)
-            {
-                ZoneCore.Log?.LogError($"[BluelockLifecycleAdapterRegistry.glow_reset] Failed: {ex.Message}");
-            }
-        }
-
-        private static void SpellbookGrantOnEnter(LifecycleContext context)
-        {
-            ZoneCore.Log?.LogDebug($"[BluelockLifecycleAdapterRegistry.spellbookgrant] Invoked for zone: {context?.ZoneId}");
-        }
-
-        private static void SpellbookRestoreOnExit(LifecycleContext context)
-        {
-            ZoneCore.Log?.LogDebug($"[BluelockLifecycleAdapterRegistry.spellbookrestore] Invoked for zone: {context?.ZoneId}");
-        }
-
-        private static void VBloodUnlockOnEnter(LifecycleContext context)
-        {
-            ZoneCore.Log?.LogDebug($"[BluelockLifecycleAdapterRegistry.vbloodunlock] Invoked for zone: {context?.ZoneId}");
-        }
-
-        private static void BossArenaStartOnEnter(LifecycleContext context)
-        {
-            try
-            {
-                if (context == null) return;
-                if (ZoneBossSpawnerService.TryHandlePlayerEnter(context.Player, context.ZoneId, out var message))
-                {
-                    ZoneCore.Log?.LogInfo($"[BluelockLifecycleAdapterRegistry.bossarena_start] {message}");
-                }
-            }
-            catch (Exception ex)
-            {
-                ZoneCore.Log?.LogError($"[BluelockLifecycleAdapterRegistry.bossarena_start] Failed: {ex.Message}");
-            }
-        }
-
-        private static void BossArenaEndOnExit(LifecycleContext context)
-        {
-            try
-            {
-                if (context == null) return;
-                ZoneBossSpawnerService.HandlePlayerExit(context.Player, context.ZoneId);
-            }
-            catch (Exception ex)
-            {
-                ZoneCore.Log?.LogError($"[BluelockLifecycleAdapterRegistry.bossarena_end] Failed: {ex.Message}");
-            }
-        }
-
-        private static void GlowCornersShowOnEnter(LifecycleContext context)
-        {
-            try
-            {
-                if (context == null) return;
-                var zone = ZoneConfigService.GetZoneById(context.ZoneId);
-                if (zone == null) return;
-                var em = ResolveEntityManager(context);
-                GlowTileService.PrepareForZoneActivation(context.ZoneId, em);
-                _ = GlowTileService.TryAutoSpawnGlowTiles(zone, em);
-            }
-            catch (Exception ex)
-            {
-                ZoneCore.Log?.LogError($"[BluelockLifecycleAdapterRegistry.glowcorners_show] Failed: {ex.Message}");
-            }
-        }
-
-        private static void GlowCornersHideOnExit(LifecycleContext context)
-        {
-            try
-            {
-                if (context == null) return;
-                GlowTileService.ClearZoneGlow(context.ZoneId, ResolveEntityManager(context));
-            }
-            catch (Exception ex)
-            {
-                ZoneCore.Log?.LogError($"[BluelockLifecycleAdapterRegistry.glowcorners_hide] Failed: {ex.Message}");
-            }
-        }
-    }
-
-    /// <summary>
-    /// Static accessor for BluelockLifecycleAdapterRegistry
-    /// </summary>
-    public static class BluelockLifecycleAdapters
-    {
-        /// <summary>
-        /// Initialize the Bluelock lifecycle adapters
-        /// </summary>
-        public static void Initialize()
-        {
-            BluelockLifecycleAdapterRegistry.Instance.Initialize();
-        }
-
-        /// <summary>
-        /// Check if token is a domain token
-        /// </summary>
-        public static bool IsDomainToken(string token)
-        {
-            return BluelockLifecycleAdapterRegistry.Instance.IsDomainToken(token);
-        }
-    }
-}
diff --git a/Bluelock/Services/Lifecycle/SpellbookLifecycleService.cs b/Bluelock/Services/Lifecycle/SpellbookLifecycleService.cs
new file mode 100644
index 0000000..237520c
--- /dev/null
+++ b/Bluelock/Services/Lifecycle/SpellbookLifecycleService.cs
@@ -0,0 +1,110 @@
+using System;
+using BepInEx.Logging;
+using Unity.Collections;
+using Unity.Entities;
+using Unity.Mathematics;
+using ProjectM;
+using VAuto.Zone.Core;
+using VAuto.Zone.Core.Lifecycle;
+
+namespace VAuto.Zone.Services
+{
+    /// <summary>
+    /// Service for managing spellbook granting automation on zone transitions.
+    /// Implements ILifecycleActionHandler for integration with lifecycle stages.
+    /// </summary>
+    public class SpellbookLifecycleService : ILifecycleActionHandler
+    {
+        private const string LogSource = "SpellbookLifecycleService";
+        
+        /// <summary>
+        /// Priority for grant requests (lower = higher priority).
+        /// </summary>
+        public int Priority { get; set; } = 0;
+        
+        /// <summary>
+        /// Behavior when inventory is full.
+        /// </summary>
+        public InventoryOverflowBehavior OverflowBehavior { get; set; } = InventoryOverflowBehavior.DropExisting;
+
+        /// <summary>
+        /// Behavior when inventory is full.
+        /// </summary>
+        public enum InventoryOverflowBehavior
+        {
+            DropExisting,
+            FailGracefully,
+            CreateMail
+        }
+
+        private static ManualLogSource _log => ZoneCore.Log;
+
+        /// <summary>
+        /// Executes the spellbook grant action for the given context.
+        /// </summary>
+        public bool Execute(LifecycleModels.LifecycleAction action, LifecycleModels.LifecycleContext context)
+        {
+            if (action.Type != "SpellbookGrant")
+            {
+                _log.LogDebug($"[{LogSource}] Ignoring action type: {action.Type}");
+                return false;
+            }
+            // For now, treat this as a no-op lifecycle hook that always succeeds
+            // when a SpellbookGrant action is dispatched. Actual menu handling
+            // is driven via AbilityUi and zone enter/exit hooks.
+            if (string.IsNullOrEmpty(action.ConfigId))
+            {
+                _log.LogWarning($"[{LogSource}] No spellbook ID specified in action");
+                return false;
+            }
+
+            _log.LogInfo($"[{LogSource}] Spellbook grant hook invoked for '{action.ConfigId}'");
+            return true;
+        }
+
+        // Inventory-based grant helpers have been removed; the spellbook is treated
+        // as a UI/menu concept, not a tangible inventory item.
+
+        /// <summary>
+        /// Creates a spellbook grant lifecycle action.
+        /// </summary>
+        public static LifecycleModels.LifecycleAction CreateSpellbookGrantAction(string spellbookId)
+        {
+            return new LifecycleModels.LifecycleAction
+            {
+                Type = "SpellbookGrant",
+                ConfigId = spellbookId
+            };
+        }
+
+        /// <summary>
+        /// Grants spellbooks based on configuration.
+        /// Called when player enters a lifecycle zone.
+        /// </summary>
+        public static bool GrantSpellbooksOnZoneEnter(Entity character, string[] spellbookIds)
+        {
+            if (character == Entity.Null || spellbookIds == null) return false;
+            
+            var em = LifecycleCore.EntityManager;
+            var allGranted = true;
+
+            foreach (var spellbookId in spellbookIds)
+            {
+                var service = new SpellbookLifecycleService();
+                var action = CreateSpellbookGrantAction(spellbookId);
+                var context = new LifecycleModels.LifecycleContext
+                {
+                    CharacterEntity = character,
+                    Position = LifecycleCore.GetPosition(character)
+                };
+
+                if (!service.Execute(action, context))
+                {
+                    allGranted = false;
+                }
+            }
+
+            return allGranted;
+        }
+    }
+}
diff --git a/Bluelock/Services/Lifecycle/VBloodLifecycleService.cs b/Bluelock/Services/Lifecycle/VBloodLifecycleService.cs
new file mode 100644
index 0000000..c964154
--- /dev/null
+++ b/Bluelock/Services/Lifecycle/VBloodLifecycleService.cs
@@ -0,0 +1,152 @@
+using System;
+using BepInEx.Logging;
+using Unity.Entities;
+using Unity.Mathematics;
+using VAuto.Zone.Core;
+using VAuto.Zone.Core.Lifecycle;
+
+namespace VAuto.Zone.Services
+{
+    /// <summary>
+    /// Service for managing VBlood unlock automation on zone transitions.
+    /// Implements ILifecycleActionHandler for integration with lifecycle stages.
+    /// </summary>
+    public class VBloodLifecycleService : ILifecycleActionHandler
+    {
+        private const string LogSource = "VBloodLifecycleService";
+        
+        /// <summary>
+        /// Cooldown in seconds between unlock operations.
+        /// </summary>
+        public float CooldownSeconds { get; set; } = 60f;
+        
+        /// <summary>
+        /// Whether to force unlock regardless of conditions.
+        /// </summary>
+        public bool ForceUnlockOverride { get; set; } = false;
+        
+        /// <summary>
+        /// Priority for unlock requests (lower = higher priority).
+        /// </summary>
+        public int UnlockPriority { get; set; } = 0;
+        
+        private float _lastUnlockTime;
+
+        private static ManualLogSource _log => ZoneCore.Log;
+
+        /// <summary>
+        /// Executes the VBlood unlock action for the given context.
+        /// </summary>
+        public bool Execute(LifecycleModels.LifecycleAction action, LifecycleModels.LifecycleContext context)
+        {
+            if (action.Type != "VBloodUnlock")
+            {
+                _log.LogDebug($"[{LogSource}] Ignoring action type: {action.Type}");
+                return false;
+            }
+
+            var em = LifecycleCore.EntityManager;
+            var user = context.UserEntity;
+
+            if (user == Entity.Null)
+            {
+                _log.LogWarning($"[{LogSource}] User entity is null");
+                return false;
+            }
+
+            try
+            {
+                // Check cooldown
+                if (CooldownSeconds > 0 && LifecycleCore.IsInitialized && (float)0 - _lastUnlockTime < CooldownSeconds)
+                {
+                    _log.LogDebug($"[{LogSource}] Unlock cooldown active");
+                    return false;
+                }
+
+                // Check conditions or use force override
+                if (!ForceUnlockOverride && !AreUnlockConditionsMet(user, em))
+                {
+                    _log.LogDebug($"[{LogSource}] Unlock conditions not met");
+                    return false;
+                }
+
+                // Perform unlock
+                var result = UnlockVBloods(user, em);
+                
+                if (result == UnlockResult.Success)
+                {
+                    _lastUnlockTime = 0; // Would use actual time in implementation
+                    _log.LogInfo($"[{LogSource}] ✅ VBlood unlock completed successfully");
+                }
+                
+                return result == UnlockResult.Success;
+            }
+            catch (Exception ex)
+            {
+                _log.LogError($"[{LogSource}] Exception: {ex.Message}");
+                return false;
+            }
+        }
+
+        /// <summary>
+        /// Checks if unlock conditions are met for the player.
+        /// </summary>
+        private bool AreUnlockConditionsMet(Entity user, EntityManager em)
+        {
+            // Check if player is in valid zone for unlocks
+            // This is a placeholder - actual implementation would check zone membership
+            return true;
+        }
+
+        /// <summary>
+        /// Unlocks VBlood content for the player using SandboxUnlockUtility.
+        /// </summary>
+        private UnlockResult UnlockVBloods(Entity user, EntityManager em)
+        {
+            try
+            {
+                // Use existing SandboxUnlockUtility for VBlood unlocks
+                // Placeholder: SandboxUnlockUtility.UnlockEverythingForPlayer(user);
+                
+                _log.LogInfo($"[{LogSource}] VBlood unlocks applied");
+                return UnlockResult.Success;
+            }
+            catch (Exception ex)
+            {
+                _log.LogError($"[{LogSource}] Unlock failed: {ex.Message}");
+                return UnlockResult.Failed;
+            }
+        }
+
+        /// <summary>
+        /// Creates a VBlood unlock lifecycle action.
+        /// </summary>
+        public static LifecycleModels.LifecycleAction CreateVBloodUnlockAction(bool forceOverride = false, int priority = 0)
+        {
+            return new LifecycleModels.LifecycleAction
+            {
+                Type = "VBloodUnlock",
+                ConfigId = forceOverride ? "force" : null
+            };
+        }
+
+        /// <summary>
+        /// Unlocks all VBlood content for a player on zone enter.
+        /// </summary>
+        public static bool UnlockVBloodsOnZoneEnter(Entity user)
+        {
+            if (user == Entity.Null) return false;
+            
+            var service = new VBloodLifecycleService();
+            var action = CreateVBloodUnlockAction();
+            var context = new LifecycleModels.LifecycleContext
+            {
+                UserEntity = user,
+                CharacterEntity = user, // Would get character from user
+                Position = LifecycleCore.GetPosition(user)
+            };
+
+            return service.Execute(action, context);
+        }
+    }
+}
diff --git a/Bluelock/Services/ZoneConfigService.cs b/Bluelock/Services/ZoneConfigService.cs
index 0408665..6e68957 100644
--- a/Bluelock/Services/ZoneConfigService.cs
+++ b/Bluelock/Services/ZoneConfigService.cs
@@ -43,8 +43,8 @@ namespace VAuto.Zone.Services
             var rootDir = Path.Combine(Paths.ConfigPath, "Bluelock");
             Directory.CreateDirectory(rootDir);
 
-            var rootPath = Path.Combine(rootDir, "Bluelock.zones.json");
-            var legacyPath = Path.Combine(rootDir, "config", "Bluelock.zones.json");
+            var rootPath = Path.Combine(rootDir, "VAuto.Zones.json");
+            var legacyPath = Path.Combine(rootDir, "config", "VAuto.Zones.json");
             try
             {
                 if (!File.Exists(rootPath) && File.Exists(legacyPath))
diff --git a/Bluelock/Services/ZoneTemplateRegistry.cs b/Bluelock/Services/ZoneTemplateRegistry.cs
index a35d831..3a5e1d8 100644
--- a/Bluelock/Services/ZoneTemplateRegistry.cs
+++ b/Bluelock/Services/ZoneTemplateRegistry.cs
@@ -19,15 +19,14 @@ namespace VAuto.Zone.Services
         private static readonly Dictionary<string, Dictionary<string, TemplateSpawnMetadata>> _zoneTemplateMetadata =
             new(StringComparer.OrdinalIgnoreCase);
 
-        public static bool RegisterEntities(string zoneId, string templateType, List<Entity> entities, TemplateSpawnMetadata metadata = null, string instanceKey = null)
+        public static bool RegisterEntities(string zoneId, string templateType, List<Entity> entities, TemplateSpawnMetadata metadata = null)
         {
             if (string.IsNullOrWhiteSpace(zoneId) || string.IsNullOrWhiteSpace(templateType) || entities == null || entities.Count == 0)
             {
                 return false;
             }
 
-            var scopedZoneId = BuildScopedZoneId(zoneId, instanceKey);
-            var zoneMap = GetOrCreateZone(scopedZoneId);
+            var zoneMap = GetOrCreateZone(zoneId);
             var existingZoneTotal = zoneMap.Values.Sum(list => list.Count);
             if (existingZoneTotal + entities.Count > MaxEntitiesPerZone)
             {
@@ -43,23 +42,22 @@ namespace VAuto.Zone.Services
             templateList.AddRange(entities);
             foreach (var entity in entities)
             {
-                _entityToZoneType[entity] = (scopedZoneId, templateType);
+                _entityToZoneType[entity] = (zoneId, templateType);
             }
 
             if (metadata != null)
             {
-                var metaMap = GetOrCreateMetadata(scopedZoneId);
+                var metaMap = GetOrCreateMetadata(zoneId);
                 metaMap[templateType] = metadata;
             }
 
             return true;
         }
 
-        public static bool TryGetEntities(string zoneId, string templateType, out List<Entity> entities, string instanceKey = null)
+        public static bool TryGetEntities(string zoneId, string templateType, out List<Entity> entities)
         {
             entities = null;
-            var scopedZoneId = BuildScopedZoneId(zoneId, instanceKey);
-            if (!_zoneTemplateEntities.TryGetValue(scopedZoneId, out var map))
+            if (!_zoneTemplateEntities.TryGetValue(zoneId, out var map))
             {
                 return false;
             }
@@ -73,10 +71,9 @@ namespace VAuto.Zone.Services
             return true;
         }
 
-        public static void ClearZoneType(string zoneId, string templateType, string instanceKey = null)
+        public static void ClearZoneType(string zoneId, string templateType)
         {
-            var scopedZoneId = BuildScopedZoneId(zoneId, instanceKey);
-            if (!_zoneTemplateEntities.TryGetValue(scopedZoneId, out var map))
+            if (!_zoneTemplateEntities.TryGetValue(zoneId, out var map))
             {
                 return;
             }
@@ -94,30 +91,29 @@ namespace VAuto.Zone.Services
             map.Remove(templateType);
             if (map.Count == 0)
             {
-                _zoneTemplateEntities.Remove(scopedZoneId);
+                _zoneTemplateEntities.Remove(zoneId);
             }
 
-            if (_zoneTemplateMetadata.TryGetValue(scopedZoneId, out var metaMap))
+            if (_zoneTemplateMetadata.TryGetValue(zoneId, out var metaMap))
             {
                 metaMap.Remove(templateType);
                 if (metaMap.Count == 0)
                 {
-                    _zoneTemplateMetadata.Remove(scopedZoneId);
+                    _zoneTemplateMetadata.Remove(zoneId);
                 }
             }
         }
 
-        public static void ClearZone(string zoneId, string instanceKey = null)
+        public static void ClearZone(string zoneId)
         {
-            var scopedZoneId = BuildScopedZoneId(zoneId, instanceKey);
-            if (!_zoneTemplateEntities.TryGetValue(scopedZoneId, out var map))
+            if (!_zoneTemplateEntities.TryGetValue(zoneId, out var map))
             {
                 return;
             }
 
             foreach (var templateType in map.Keys.ToList())
             {
-                ClearZoneType(zoneId, templateType, instanceKey);
+                ClearZoneType(zoneId, templateType);
             }
         }
 
@@ -148,10 +144,9 @@ namespace VAuto.Zone.Services
 
         public static IReadOnlyCollection<string> GetSpawnedZones() => _zoneTemplateEntities.Keys.ToList();
 
-        public static IReadOnlyCollection<string> GetSpawnedTypes(string zoneId, string instanceKey = null)
+        public static IReadOnlyCollection<string> GetSpawnedTypes(string zoneId)
         {
-            var scopedZoneId = BuildScopedZoneId(zoneId, instanceKey);
-            if (!_zoneTemplateEntities.TryGetValue(scopedZoneId, out var map))
+            if (!_zoneTemplateEntities.TryGetValue(zoneId, out var map))
             {
                 return Array.Empty<string>();
             }
@@ -159,10 +154,9 @@ namespace VAuto.Zone.Services
             return map.Keys.ToList();
         }
 
-        public static int GetEntityCount(string zoneId, string templateType, string instanceKey = null)
+        public static int GetEntityCount(string zoneId, string templateType)
         {
-            var scopedZoneId = BuildScopedZoneId(zoneId, instanceKey);
-            if (!_zoneTemplateEntities.TryGetValue(scopedZoneId, out var map))
+            if (!_zoneTemplateEntities.TryGetValue(zoneId, out var map))
             {
                 return 0;
             }
@@ -170,13 +164,12 @@ namespace VAuto.Zone.Services
             return map.TryGetValue(templateType, out var list) ? list.Count : 0;
         }
 
-        public static bool IsSpawned(string zoneId, string templateType, string instanceKey = null)
-            => GetEntityCount(zoneId, templateType, instanceKey) > 0;
+        public static bool IsSpawned(string zoneId, string templateType)
+            => GetEntityCount(zoneId, templateType) > 0;
 
-        public static TemplateSpawnMetadata GetMetadata(string zoneId, string templateType, string instanceKey = null)
+        public static TemplateSpawnMetadata GetMetadata(string zoneId, string templateType)
         {
-            var scopedZoneId = BuildScopedZoneId(zoneId, instanceKey);
-            if (!_zoneTemplateMetadata.TryGetValue(scopedZoneId, out var metaMap))
+            if (!_zoneTemplateMetadata.TryGetValue(zoneId, out var metaMap))
             {
                 return null;
             }
@@ -217,17 +210,6 @@ namespace VAuto.Zone.Services
             return list;
         }
 
-        private static string BuildScopedZoneId(string zoneId, string instanceKey)
-        {
-            var cleanZoneId = zoneId ?? string.Empty;
-            if (string.IsNullOrWhiteSpace(instanceKey))
-            {
-                return cleanZoneId;
-            }
-
-            return $"{cleanZoneId}::{instanceKey.Trim()}";
-        }
-
         private sealed class EntityEqualityComparer : IEqualityComparer<Entity>
         {
             public static readonly EntityEqualityComparer Instance = new();
diff --git a/Bluelock/Services/ZoneTemplateService.cs b/Bluelock/Services/ZoneTemplateService.cs
index fe6dee1..9ab8322 100644
--- a/Bluelock/Services/ZoneTemplateService.cs
+++ b/Bluelock/Services/ZoneTemplateService.cs
@@ -2,7 +2,6 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 using ProjectM;
-using ProjectM.Network;
 using Unity.Entities;
 using Unity.Mathematics;
 using VAuto.Zone.Core;
@@ -12,38 +11,7 @@ namespace VAuto.Zone.Services
 {
     public static class ZoneTemplateService
     {
-        public static List<TemplateSpawnResult> SpawnAllZoneTemplates(string zoneId, EntityManager em, Entity player)
-        {
-            var zone = ZoneConfigService.GetZoneById(zoneId);
-            var instanceKey = ResolveInstanceKey(zone, player, em);
-            return SpawnAllZoneTemplates(zoneId, em, instanceKey);
-        }
-
-        public static TemplateSpawnResult SpawnZoneTemplateType(string zoneId, string templateType, EntityManager em, Entity player)
-        {
-            var zone = ZoneConfigService.GetZoneById(zoneId);
-            var instanceKey = ResolveInstanceKey(zone, player, em);
-            return SpawnZoneTemplateType(zoneId, templateType, em, instanceKey);
-        }
-
-        public static int ClearZoneTemplateType(string zoneId, string templateType, EntityManager em, Entity player)
-        {
-            var zone = ZoneConfigService.GetZoneById(zoneId);
-            var instanceKey = ResolveInstanceKey(zone, player, em);
-            return ClearZoneTemplateType(zoneId, templateType, em, instanceKey);
-        }
-
-        public static int ClearAllZoneTemplates(string zoneId, EntityManager em, Entity player)
-        {
-            var zone = ZoneConfigService.GetZoneById(zoneId);
-            var instanceKey = ResolveInstanceKey(zone, player, em);
-            return ClearAllZoneTemplates(zoneId, em, instanceKey);
-        }
-
         public static TemplateSpawnResult SpawnZoneTemplateType(string zoneId, string templateType, EntityManager em)
-            => SpawnZoneTemplateType(zoneId, templateType, em, instanceKey: null);
-
-        public static TemplateSpawnResult SpawnZoneTemplateType(string zoneId, string templateType, EntityManager em, string instanceKey)
         {
             if (em == default || em.World == null || !em.World.IsCreated)
             {
@@ -74,7 +42,7 @@ namespace VAuto.Zone.Services
                 };
             }
 
-            if (ZoneTemplateRegistry.IsSpawned(zoneId, templateType, instanceKey))
+            if (ZoneTemplateRegistry.IsSpawned(zoneId, templateType))
             {
                 return new TemplateSpawnResult
                 {
@@ -103,7 +71,7 @@ namespace VAuto.Zone.Services
                     Rotation = quaternion.identity
                 };
 
-                if (!ZoneTemplateRegistry.RegisterEntities(zoneId, templateType, result.Entities, metadata, instanceKey))
+                if (!ZoneTemplateRegistry.RegisterEntities(zoneId, templateType, result.Entities, metadata))
                 {
                     // Capacity exceeded: cleanup spawned entities
                     foreach (var entity in result.Entities)
@@ -124,9 +92,6 @@ namespace VAuto.Zone.Services
         }
 
         public static List<TemplateSpawnResult> SpawnAllZoneTemplates(string zoneId, EntityManager em)
-            => SpawnAllZoneTemplates(zoneId, em, instanceKey: null);
-
-        public static List<TemplateSpawnResult> SpawnAllZoneTemplates(string zoneId, EntityManager em, string instanceKey)
         {
             var results = new List<TemplateSpawnResult>();
             var zone = ZoneConfigService.GetZoneById(zoneId);
@@ -137,23 +102,20 @@ namespace VAuto.Zone.Services
 
             foreach (var kvp in zone.Templates)
             {
-                results.Add(SpawnZoneTemplateType(zoneId, kvp.Key, em, instanceKey));
+                results.Add(SpawnZoneTemplateType(zoneId, kvp.Key, em));
             }
 
             return results;
         }
 
         public static int ClearZoneTemplateType(string zoneId, string templateType, EntityManager em)
-            => ClearZoneTemplateType(zoneId, templateType, em, instanceKey: null);
-
-        public static int ClearZoneTemplateType(string zoneId, string templateType, EntityManager em, string instanceKey)
         {
             if (em == default || em.World == null || !em.World.IsCreated)
             {
                 return 0;
             }
 
-            if (!ZoneTemplateRegistry.TryGetEntities(zoneId, templateType, out var entities, instanceKey))
+            if (!ZoneTemplateRegistry.TryGetEntities(zoneId, templateType, out var entities))
             {
                 return 0;
             }
@@ -169,14 +131,11 @@ namespace VAuto.Zone.Services
                 }
             }
 
-            ZoneTemplateRegistry.ClearZoneType(zoneId, templateType, instanceKey);
+            ZoneTemplateRegistry.ClearZoneType(zoneId, templateType);
             return destroyed;
         }
 
         public static int ClearAllZoneTemplates(string zoneId, EntityManager em)
-            => ClearAllZoneTemplates(zoneId, em, instanceKey: null);
-
-        public static int ClearAllZoneTemplates(string zoneId, EntityManager em, string instanceKey)
         {
             if (em == default || em.World == null || !em.World.IsCreated)
             {
@@ -184,99 +143,39 @@ namespace VAuto.Zone.Services
             }
 
             var total = 0;
-            var templateTypes = ZoneTemplateRegistry.GetSpawnedTypes(zoneId, instanceKey);
+            var templateTypes = ZoneTemplateRegistry.GetSpawnedTypes(zoneId);
             foreach (var templateType in templateTypes.ToList())
             {
-                total += ClearZoneTemplateType(zoneId, templateType, em, instanceKey);
+                total += ClearZoneTemplateType(zoneId, templateType, em);
             }
 
             return total;
         }
 
         public static List<TemplateSpawnResult> RebuildZoneTemplates(string zoneId, EntityManager em)
-            => RebuildZoneTemplates(zoneId, em, instanceKey: null);
-
-        public static List<TemplateSpawnResult> RebuildZoneTemplates(string zoneId, EntityManager em, Entity player)
-        {
-            var zone = ZoneConfigService.GetZoneById(zoneId);
-            var instanceKey = ResolveInstanceKey(zone, player, em);
-            return RebuildZoneTemplates(zoneId, em, instanceKey);
-        }
-
-        public static List<TemplateSpawnResult> RebuildZoneTemplates(string zoneId, EntityManager em, string instanceKey)
         {
-            ClearAllZoneTemplates(zoneId, em, instanceKey);
-            return SpawnAllZoneTemplates(zoneId, em, instanceKey);
+            ClearAllZoneTemplates(zoneId, em);
+            return SpawnAllZoneTemplates(zoneId, em);
         }
 
         public static bool IsTemplateSpawned(string zoneId, string templateType)
-            => ZoneTemplateRegistry.IsSpawned(zoneId, templateType, instanceKey: null);
-
-        public static bool IsTemplateSpawned(string zoneId, string templateType, string instanceKey)
-            => ZoneTemplateRegistry.IsSpawned(zoneId, templateType, instanceKey);
+            => ZoneTemplateRegistry.IsSpawned(zoneId, templateType);
 
         public static List<string> GetSpawnedTemplateTypes(string zoneId)
-            => ZoneTemplateRegistry.GetSpawnedTypes(zoneId, instanceKey: null).ToList();
-
-        public static List<string> GetSpawnedTemplateTypes(string zoneId, string instanceKey)
-            => ZoneTemplateRegistry.GetSpawnedTypes(zoneId, instanceKey).ToList();
+            => ZoneTemplateRegistry.GetSpawnedTypes(zoneId).ToList();
 
         public static int GetTemplateEntityCount(string zoneId, string templateType)
-            => ZoneTemplateRegistry.GetEntityCount(zoneId, templateType, instanceKey: null);
-
-        public static int GetTemplateEntityCount(string zoneId, string templateType, string instanceKey)
-            => ZoneTemplateRegistry.GetEntityCount(zoneId, templateType, instanceKey);
+            => ZoneTemplateRegistry.GetEntityCount(zoneId, templateType);
 
         public static Dictionary<string, int> GetZoneTemplateStats(string zoneId)
-            => GetZoneTemplateStats(zoneId, instanceKey: null);
-
-        public static Dictionary<string, int> GetZoneTemplateStats(string zoneId, Entity player, EntityManager em)
-        {
-            var zone = ZoneConfigService.GetZoneById(zoneId);
-            var instanceKey = ResolveInstanceKey(zone, player, em);
-            return GetZoneTemplateStats(zoneId, instanceKey);
-        }
-
-        public static Dictionary<string, int> GetZoneTemplateStats(string zoneId, string instanceKey)
         {
             var stats = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
-            foreach (var type in ZoneTemplateRegistry.GetSpawnedTypes(zoneId, instanceKey))
+            foreach (var type in ZoneTemplateRegistry.GetSpawnedTypes(zoneId))
             {
-                stats[type] = ZoneTemplateRegistry.GetEntityCount(zoneId, type, instanceKey);
+                stats[type] = ZoneTemplateRegistry.GetEntityCount(zoneId, type);
             }
 
             return stats;
         }
-
-        private static string ResolveInstanceKey(ZoneDefinition zone, Entity player, EntityManager em)
-        {
-            if (zone == null || !zone.Dedicated)
-            {
-                return null;
-            }
-
-            try
-            {
-                if (player == Entity.Null || em == default || !em.Exists(player) || !em.HasComponent<PlayerCharacter>(player))
-                {
-                    return "dedicated_unknown";
-                }
-
-                var playerCharacter = em.GetComponentData<PlayerCharacter>(player);
-                if (playerCharacter.UserEntity == Entity.Null || !em.Exists(playerCharacter.UserEntity) || !em.HasComponent<User>(playerCharacter.UserEntity))
-                {
-                    return player.Index > 0 ? $"player_{player.Index}" : "dedicated_unknown";
-                }
-
-                var user = em.GetComponentData<User>(playerCharacter.UserEntity);
-                return user.PlatformId == 0
-                    ? (player.Index > 0 ? $"player_{player.Index}" : "dedicated_unknown")
-                    : user.PlatformId.ToString();
-            }
-            catch
-            {
-                return "dedicated_unknown";
-            }
-        }
     }
 }
diff --git a/CycleBorn/Cycleborn.prefabs.json b/Bluelock/config/Prefabsref.json
similarity index 99%
rename from CycleBorn/Cycleborn.prefabs.json
rename to Bluelock/config/Prefabsref.json
index 0fb04a4..776ad21 100644
--- a/CycleBorn/Cycleborn.prefabs.json
+++ b/Bluelock/config/Prefabsref.json
@@ -1,7 +1,7 @@
 {
     "schemaVersion":  2,
     "maxEntries":  200,
-    "source":  "Bluelock/Services/GlowService.cs + Bluelock/Core/PrefabResolver.cs",
+    "source":  "temp_reference/KindredSchematics/Services/GlowService.cs + temp_reference/KindredCommands/Data/Prefabs.cs",
     "count":  200,
     "choices":  [
                     {
diff --git a/config/Bluelock.kits.json b/Bluelock/config/VAuto.Kits.json
similarity index 100%
rename from config/Bluelock.kits.json
rename to Bluelock/config/VAuto.Kits.json
diff --git a/Bluelock/config/VAuto.ZoneLifecycle.json b/Bluelock/config/VAuto.ZoneLifecycle.json
new file mode 100644
index 0000000..2e980dc
--- /dev/null
+++ b/Bluelock/config/VAuto.ZoneLifecycle.json
@@ -0,0 +1,34 @@
+{
+    "enabled":  true,
+    "checkIntervalMs":  100,
+    "positionChangeThreshold":  1.0,
+    "mapIconSpawnRefreshIntervalSeconds":  10.0,
+    "mappings":  {
+                     "*":  {
+                               "onEnter":  [
+                                               "capture_return_position",
+                                               "snapshot_save",
+                                               "zone_enter_message",
+                                               "apply_kit",
+                                               "teleport_enter",
+                                               "apply_templates",
+                                               "apply_abilities",
+                                               "player_tag",
+                                               "boss_enter",
+                                               "integration_events_enter",
+                                               "announce_enter"
+                                           ],
+                               "onExit":  [
+                                              "zone_exit_message",
+                                              "restore_kit_snapshot",
+                                              "restore_abilities",
+                                              "boss_exit",
+                                              "player_tag",
+                                              "teleport_return",
+                                              "integration_events_exit"
+                                          ],
+                               "useGlobalDefaults":  false,
+                               "mapIconChangePrefab":  ""
+                           }
+                 }
+}
diff --git a/config/Bluelock.zones.json b/Bluelock/config/VAuto.Zones.json
similarity index 100%
rename from config/Bluelock.zones.json
rename to Bluelock/config/VAuto.Zones.json
diff --git a/config/Bluelock.ability_prefabs.json b/Bluelock/config/ability_prefabs.json
similarity index 100%
rename from config/Bluelock.ability_prefabs.json
rename to Bluelock/config/ability_prefabs.json
diff --git a/config/Bluelock.ability_zones.json b/Bluelock/config/ability_zones.json
similarity index 100%
rename from config/Bluelock.ability_zones.json
rename to Bluelock/config/ability_zones.json
diff --git a/Core/Arena/ArenaLifecycleManager.cs b/Core/Arena/ArenaLifecycleManager.cs
new file mode 100644
index 0000000..4a201f0
--- /dev/null
+++ b/Core/Arena/ArenaLifecycleManager.cs
@@ -0,0 +1,55 @@
+using Unity.Entities;
+using Unity.Mathematics;
+using VAutomationCore.Core.Logging;
+using VAutomationCore.Models;
+using VAutomationCore.Services;
+
+namespace VAutomationCore.Core.Arena
+{
+    /// <summary>
+    /// Manages arena lifecycle events and state.
+    /// </summary>
+    public class ArenaLifecycleManager
+    {
+        private readonly CoreLogger _logger;
+
+        public ArenaLifecycleManager(CoreLogger logger)
+        {
+            _logger = logger;
+        }
+
+        /// <summary>
+        /// Handles player entering an arena zone.
+        /// </summary>
+        public void OnPlayerEntered(Entity player, string zoneId)
+        {
+            _logger?.Info($"Player entered arena: {zoneId}");
+            ZoneEventBridge.PublishPlayerEntered(player, zoneId);
+        }
+
+        /// <summary>
+        /// Handles player exiting an arena zone.
+        /// </summary>
+        public void OnPlayerExited(Entity player, string zoneId)
+        {
+            _logger?.Info($"Player exited arena: {zoneId}");
+            ZoneEventBridge.PublishPlayerExited(player, zoneId);
+        }
+
+        /// <summary>
+        /// Initializes the arena lifecycle manager.
+        /// </summary>
+        public void Initialize()
+        {
+            _logger?.Info("ArenaLifecycleManager initialized");
+        }
+
+        /// <summary>
+        /// Shuts down the arena lifecycle manager.
+        /// </summary>
+        public void Shutdown()
+        {
+            _logger?.Info("ArenaLifecycleManager shutdown");
+        }
+    }
+}
diff --git a/Core/Components/LifecycleRequestComponents.cs b/Core/Components/LifecycleRequestComponents.cs
new file mode 100644
index 0000000..b0ab5d4
--- /dev/null
+++ b/Core/Components/LifecycleRequestComponents.cs
@@ -0,0 +1,126 @@
+using Unity.Entities;
+using Unity.Mathematics;
+using Stunlock.Core;
+
+namespace VAuto.Core.Components
+{
+    /// <summary>
+    /// Base component for all lifecycle requests with common fields.
+    /// Implements IComponentData for Unity ECS compatibility.
+    /// </summary>
+    public abstract class LifecycleRequestBase : IComponentData
+    {
+        public RequestType Type { get; set; }
+        public float Timestamp { get; set; }
+        public Entity SourceZone { get; set; }
+        public Entity TargetZone { get; set; }
+        public RequestStatus Status { get; set; }
+        public string ErrorMessage { get; set; }
+    }
+
+    /// <summary>
+    /// Enumeration of request types for lifecycle automation.
+    /// </summary>
+    public enum RequestType : byte
+    {
+        ZoneTransition = 0,
+        Repair = 1,
+        VBloodUnlock = 2,
+        SpellbookGrant = 3
+    }
+
+    /// <summary>
+    /// Status tracking for request processing lifecycle.
+    /// </summary>
+    public enum RequestStatus : byte
+    {
+        Pending = 0,
+        Processing = 1,
+        Completed = 2,
+        Failed = 3
+    }
+
+    /// <summary>
+    /// Zone transition request for arena entry/exit events.
+    /// Triggers lifecycle handler chains when players cross zone boundaries.
+    /// </summary>
+    public struct ZoneTransitionRequest : IComponentData
+    {
+        public TransitionDirection Direction;
+        public bool TriggeredByPlayer;
+        public float3 Position;
+    }
+
+    /// <summary>
+    /// Direction of zone transition.
+    /// </summary>
+    public enum TransitionDirection : byte
+    {
+        Enter = 0,
+        Exit = 1
+    }
+
+    /// <summary>
+    /// Equipment durability repair request.
+    /// Generated when items fall below durability threshold.
+    /// </summary>
+    public struct RepairRequest : IComponentData
+    {
+        public int ItemSlot;
+        public RepairAmount Amount;
+        public RepairTriggerCondition TriggerCondition;
+        public int DurabilityThreshold;
+    }
+
+    /// <summary>
+    /// Amount of durability to restore during repair.
+    /// </summary>
+    public enum RepairAmount : byte
+    {
+        Full = 0,
+        Partial = 1
+    }
+
+    /// <summary>
+    /// Condition that triggered the repair request.
+    /// </summary>
+    public enum RepairTriggerCondition : byte
+    {
+        OnZoneEnter = 0,
+        OnZoneExit = 1,
+        OnCommand = 2,
+        PeriodicCheck = 3
+    }
+
+    /// <summary>
+    /// VBlood boss unlock request.
+    /// Generated when players defeat VBlood bosses or enter unlock zones.
+    /// </summary>
+    public struct VBloodUnlockRequest : IComponentData
+    {
+        public PrefabGUID BossType;
+        public int UnlockPriority;
+        public bool ForceUnlockOverride;
+    }
+
+    /// <summary>
+    /// Spellbook granting request.
+    /// Generated when players enter zones with spellbook rewards.
+    /// </summary>
+    public struct SpellbookGrantRequest : IComponentData
+    {
+        public PrefabGUID SpellId;
+        public GrantReason Reason;
+        public int Priority;
+    }
+
+    /// <summary>
+    /// Reason for granting a spellbook.
+    /// </summary>
+    public enum GrantReason : byte
+    {
+        ZoneEnter = 0,
+        QuestReward = 1,
+        AdminCommand = 2
+    }
+}
diff --git a/Core/Config/LifecycleConfigWatcher.cs b/Core/Config/LifecycleConfigWatcher.cs
new file mode 100644
index 0000000..9f14dbc
--- /dev/null
+++ b/Core/Config/LifecycleConfigWatcher.cs
@@ -0,0 +1,153 @@
+using System;
+using System.IO;
+using System.Threading;
+using Newtonsoft.Json;
+using VAuto.Core.Lifecycle;
+using Microsoft.Extensions.Logging;
+
+namespace VAuto.Core.Config
+{
+    /// <summary>
+    /// Hot-reload configuration watcher using FileSystemWatcher pattern.
+    /// Monitors config file changes and automatically reloads configuration.
+    /// </summary>
+    public class LifecycleConfigWatcher : IDisposable
+    {
+        private readonly FileSystemWatcher _watcher;
+        private readonly Timer _debounceTimer;
+        private readonly string _configPath;
+        private readonly ILogger<LifecycleConfigWatcher> _log;
+        private bool _pendingReload;
+
+        /// <summary>
+        /// Event fired when configuration is reloaded.
+        /// </summary>
+        public event Action<ZoneLifecycleConfig> OnConfigReloaded;
+
+        public LifecycleConfigWatcher(string configPath, ILogger<LifecycleConfigWatcher> log)
+        {
+            _configPath = configPath ?? throw new ArgumentNullException(nameof(configPath));
+            _log = log ?? throw new ArgumentNullException(nameof(log));
+            
+            var directory = Path.GetDirectoryName(configPath);
+            var fileName = Path.GetFileName(configPath);
+            
+            if (string.IsNullOrEmpty(directory) || !Directory.Exists(directory))
+            {
+                _log.LogError($"[LifecycleConfigWatcher] Directory not found: {directory}");
+                throw new DirectoryNotFoundException($"Configuration directory not found: {directory}");
+            }
+
+            _watcher = new FileSystemWatcher(directory, fileName)
+            {
+                NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.Size | NotifyFilters.FileName,
+                EnableRaisingEvents = false
+            };
+            
+            _watcher.Changed += OnConfigChanged;
+            _watcher.Deleted += OnConfigChanged;
+            _watcher.Renamed += OnConfigChanged;
+            
+            _debounceTimer = new Timer(ProcessReload, null, Timeout.Infinite, Timeout.Infinite);
+            
+            _log.LogInformation($"[LifecycleConfigWatcher] Watching: {configPath}");
+        }
+
+        /// <summary>
+        /// Starts monitoring the configuration file.
+        /// </summary>
+        public void Start()
+        {
+            _watcher.EnableRaisingEvents = true;
+            _log.LogDebug("[LifecycleConfigWatcher] File watching started");
+        }
+
+        /// <summary>
+        /// Stops monitoring the configuration file.
+        /// </summary>
+        public void Stop()
+        {
+            _watcher.EnableRaisingEvents = false;
+            _log.LogDebug("[LifecycleConfigWatcher] File watching stopped");
+        }
+
+        private void OnConfigChanged(object sender, FileSystemEventArgs e)
+        {
+            // Prevent rapid successive triggers
+            if (_pendingReload) return;
+            _pendingReload = true;
+            
+            // Debounce: wait 2 seconds before reloading to allow file write to complete
+            _debounceTimer.Change(2000, Timeout.Infinite);
+            
+            _log.LogDebug($"[LifecycleConfigWatcher] Config change detected: {e.ChangeType} ({e.Name})");
+        }
+
+        private void ProcessReload(object state)
+        {
+            try
+            {
+                // Check if file still exists
+                if (!File.Exists(_configPath))
+                {
+                    _log.LogWarning($"[LifecycleConfigWatcher] Config file deleted: {_configPath}");
+                    return;
+                }
+
+                // Read and parse configuration
+                var json = File.ReadAllText(_configPath);
+                
+                if (string.IsNullOrWhiteSpace(json))
+                {
+                    _log.LogWarning("[LifecycleConfigWatcher] Config file is empty");
+                    return;
+                }
+
+                var config = JsonConvert.DeserializeObject<ZoneLifecycleConfig>(json);
+                
+                if (config == null)
+                {
+                    _log.LogWarning("[LifecycleConfigWatcher] Deserialized config is null");
+                    return;
+                }
+
+                // Fire reloaded event
+                OnConfigReloaded?.Invoke(config);
+                
+                _log.LogInformation("[LifecycleConfigWatcher] Configuration reloaded successfully");
+            }
+            catch (JsonException ex)
+            {
+                _log.LogError($"[LifecycleConfigWatcher] Invalid JSON in config: {ex.Message}");
+            }
+            catch (Exception ex)
+            {
+                _log.LogError($"[LifecycleConfigWatcher] Failed to reload configuration: {ex.Message}");
+            }
+            finally
+            {
+                _pendingReload = false;
+            }
+        }
+
+        /// <summary>
+        /// Manually trigger a configuration reload.
+        /// </summary>
+        public void Reload()
+        {
+            _log.LogInformation("[LifecycleConfigWatcher] Manual reload triggered");
+            ProcessReload(null);
+        }
+
+        /// <summary>
+        /// Dispose resources used by the config watcher.
+        /// </summary>
+        public void Dispose()
+        {
+            Stop();
+            _watcher.Dispose();
+            _debounceTimer.Dispose();
+            _log.LogInformation("[LifecycleConfigWatcher] Disposed");
+        }
+    }
+}
diff --git a/Core/Events/PatchEvents.cs b/Core/Events/PatchEvents.cs
index a656047..589c7bd 100644
--- a/Core/Events/PatchEvents.cs
+++ b/Core/Events/PatchEvents.cs
@@ -1,68 +1,10 @@
 using ProjectM;
 using Stunlock.Core;
-using Stunlock.Network;
-using Unity.Collections;
 using Unity.Entities;
 using Unity.Mathematics;
 
 namespace VAutomationCore.Core.Events
 {
-    public static class PrefixEvents
-    {
-        public sealed class OnCastStarted
-        {
-            public NativeArray<Entity> Entities { get; init; }
-        }
-
-        public sealed class OnPreCastFinished
-        {
-            public NativeArray<Entity> Entities { get; init; }
-        }
-
-        public sealed class OnPostCastEnded
-        {
-            public NativeArray<Entity> Entities { get; init; }
-        }
-
-        public sealed class OnCastInterrupted
-        {
-            public NativeArray<Entity> Entities { get; init; }
-        }
-
-        public sealed class OnReplaceAbilityOnSlot
-        {
-            public NativeArray<Entity> Entities { get; init; }
-        }
-    }
-
-    public static class PostfixEvents
-    {
-        public sealed class OnCastStarted
-        {
-            public NativeArray<Entity> Entities { get; init; }
-        }
-
-        public sealed class OnPreCastFinished
-        {
-            public NativeArray<Entity> Entities { get; init; }
-        }
-
-        public sealed class OnPostCastEnded
-        {
-            public NativeArray<Entity> Entities { get; init; }
-        }
-
-        public sealed class OnCastInterrupted
-        {
-            public NativeArray<Entity> Entities { get; init; }
-        }
-
-        public sealed class OnReplaceAbilityOnSlot
-        {
-            public NativeArray<Entity> Entities { get; init; }
-        }
-    }
-
     public sealed class BuffInitializedEvent
     {
         public Entity Owner { get; init; }
@@ -116,33 +58,4 @@ namespace VAutomationCore.Core.Events
     public sealed class WorldInitializedEvent
     {
     }
-
-    public sealed class UserConnectedEvent
-    {
-        public int UserIndex { get; init; }
-        public NetConnectionId ConnectionId { get; init; }
-    }
-
-    public sealed class UserDisconnectedEvent
-    {
-        public int UserIndex { get; init; }
-        public NetConnectionId ConnectionId { get; init; }
-    }
-
-    public sealed class BuffSpawnQueueEvent
-    {
-        public Entity[] Entities { get; init; }
-    }
-
-    public sealed class BuffSpawnCompleteEvent
-    {
-    }
-
-    public sealed class DropItemEvent
-    {
-        public Entity ItemEntity { get; init; }
-        public Entity Owner { get; init; }
-        public PrefabGUID ItemHash { get; init; }
-        public int Amount { get; init; }
-    }
 }
diff --git a/Core/Patches/AbilityRunScriptsSystemPatch.cs b/Core/Patches/AbilityRunScriptsSystemPatch.cs
deleted file mode 100644
index a32e26e..0000000
--- a/Core/Patches/AbilityRunScriptsSystemPatch.cs
+++ /dev/null
@@ -1,64 +0,0 @@
-using HarmonyLib;
-using ProjectM;
-using VAutomationCore.Core.Events;
-using VAutomationCore.Core.Systems;
-using Unity.Collections;
-
-namespace VAutomationCore.Core.Patches;
-
-[HarmonyPatch]
-internal static class AbilityRunScriptsSystemPatch {
-  [HarmonyPatch(typeof(AbilityRunScriptsSystem), nameof(AbilityRunScriptsSystem.OnUpdate))]
-  [HarmonyPriority(Priority.First)]
-  [HarmonyPrefix]
-  static void Prefix(AbilityRunScriptsSystem __instance) {
-    if (!GameSystems.Initialized) return;
-    var castStartedEvents = __instance._OnCastStartedQuery.ToEntityArray(Allocator.Temp);
-    var preCastFinishedEvents = __instance._OnPreCastFinishedQuery.ToEntityArray(Allocator.Temp);
-    var postCastEndedEvents = __instance._OnPostCastEndedQuery.ToEntityArray(Allocator.Temp);
-    var interruptedEvents = __instance._OnInterruptedQuery.ToEntityArray(Allocator.Temp);
-
-    try {
-      if (castStartedEvents.Length > 0 && TypedEventBus.GetSubscriberCount<PrefixEvents.OnCastStarted>() > 0)
-        TypedEventBus.Emit(new PrefixEvents.OnCastStarted { Entities = castStartedEvents });
-      if (preCastFinishedEvents.Length > 0 && TypedEventBus.GetSubscriberCount<PrefixEvents.OnPreCastFinished>() > 0)
-        TypedEventBus.Emit(new PrefixEvents.OnPreCastFinished { Entities = preCastFinishedEvents });
-      if (postCastEndedEvents.Length > 0 && TypedEventBus.GetSubscriberCount<PrefixEvents.OnPostCastEnded>() > 0)
-        TypedEventBus.Emit(new PrefixEvents.OnPostCastEnded { Entities = postCastEndedEvents });
-      if (interruptedEvents.Length > 0 && TypedEventBus.GetSubscriberCount<PrefixEvents.OnCastInterrupted>() > 0)
-        TypedEventBus.Emit(new PrefixEvents.OnCastInterrupted { Entities = interruptedEvents });
-    } finally {
-      castStartedEvents.Dispose();
-      preCastFinishedEvents.Dispose();
-      postCastEndedEvents.Dispose();
-      interruptedEvents.Dispose();
-    }
-  }
-
-  [HarmonyPatch(typeof(AbilityRunScriptsSystem), nameof(AbilityRunScriptsSystem.OnUpdate))]
-  [HarmonyPriority(Priority.First)]
-  [HarmonyPostfix]
-  static void Postfix(AbilityRunScriptsSystem __instance) {
-    if (!GameSystems.Initialized) return;
-    var castStartedEvents = __instance._OnCastStartedQuery.ToEntityArray(Allocator.Temp);
-    var preCastFinishedEvents = __instance._OnPreCastFinishedQuery.ToEntityArray(Allocator.Temp);
-    var postCastEndedEvents = __instance._OnPostCastEndedQuery.ToEntityArray(Allocator.Temp);
-    var interruptedEvents = __instance._OnInterruptedQuery.ToEntityArray(Allocator.Temp);
-
-    try {
-      if (TypedEventBus.GetSubscriberCount<PostfixEvents.OnCastStarted>() > 0)
-        TypedEventBus.Emit(new PostfixEvents.OnCastStarted { Entities = castStartedEvents });
-      if (TypedEventBus.GetSubscriberCount<PostfixEvents.OnPreCastFinished>() > 0)
-        TypedEventBus.Emit(new PostfixEvents.OnPreCastFinished { Entities = preCastFinishedEvents });
-      if (TypedEventBus.GetSubscriberCount<PostfixEvents.OnPostCastEnded>() > 0)
-        TypedEventBus.Emit(new PostfixEvents.OnPostCastEnded { Entities = postCastEndedEvents });
-      if (TypedEventBus.GetSubscriberCount<PostfixEvents.OnCastInterrupted>() > 0)
-        TypedEventBus.Emit(new PostfixEvents.OnCastInterrupted { Entities = interruptedEvents });
-    } finally {
-      castStartedEvents.Dispose();
-      preCastFinishedEvents.Dispose();
-      postCastEndedEvents.Dispose();
-      interruptedEvents.Dispose();
-    }
-  }
-}
diff --git a/Core/Patches/BuffSpawnServerPatch.cs b/Core/Patches/BuffSpawnServerPatch.cs
deleted file mode 100644
index c220040..0000000
--- a/Core/Patches/BuffSpawnServerPatch.cs
+++ /dev/null
@@ -1,100 +0,0 @@
-using System;
-using HarmonyLib;
-using ProjectM;
-using Unity.Entities;
-using VAutomationCore.Core.Events;
-using VAutomationCore.Core.Logging;
-
-namespace VAutomationCore.Core.Patches;
-
-/// <summary>
-/// Patch for Buff spawning to track when buffs are applied to entities.
-/// Useful for tracking buff effects, durations, and stacks.
-/// </summary>
-[HarmonyPatch(typeof(Buff), nameof(Buff.Initialize))]
-internal static class BuffSpawnServerPatch
-{
-    public static event EventHandler<BuffEventArgs> OnBuffInitialized;
-    
-    public class BuffEventArgs : EventArgs
-    {
-        public Entity Owner { get; set; }
-        public Entity Source { get; set; }
-        public PrefabGUID BuffGuid { get; set; }
-        public float Duration { get; set; }
-        public bool IsExtended { get; set; }
-    }
-
-    [HarmonyPrefix]
-    static bool InitializePrefix(Buff __instance, Entity owner, Entity sourceEntity)
-    {
-        try
-        {
-            var args = new BuffEventArgs
-            {
-                Owner = owner,
-                Source = sourceEntity,
-                BuffGuid = __instance.PrefabGuid,
-                Duration = __instance.Duration,
-                IsExtended = __instance.IsExtended
-            };
-
-            OnBuffInitialized?.Invoke(__instance, args);
-            TypedEventBus.Publish(new BuffInitializedEvent
-            {
-                Owner = args.Owner,
-                Source = args.Source,
-                BuffGuid = args.BuffGuid,
-                Duration = args.Duration,
-                IsExtended = args.IsExtended
-            });
-        }
-        catch (Exception ex)
-        {
-            CoreLogger.LogException("Error in buff initialize prefix", ex);
-        }
-
-        return true; // Continue with original method
-    }
-}
-
-/// <summary>
-/// Patch for Buff destruction to track when buffs are removed.
-/// </summary>
-[HarmonyPatch(typeof(Buff), nameof(Buff.Destroy))]
-internal static class BuffDestroyPatch
-{
-    public static event EventHandler<BuffEventArgs> OnBuffDestroyed;
-    
-    public class BuffEventArgs : EventArgs
-    {
-        public Entity Owner { get; set; }
-        public PrefabGUID BuffGuid { get; set; }
-    }
-
-    [HarmonyPrefix]
-    static bool DestroyPrefix(Buff __instance, Entity owner)
-    {
-        try
-        {
-            var args = new BuffEventArgs
-            {
-                Owner = owner,
-                BuffGuid = __instance.PrefabGuid
-            };
-
-            OnBuffDestroyed?.Invoke(__instance, args);
-            TypedEventBus.Publish(new BuffDestroyedEvent
-            {
-                Owner = args.Owner,
-                BuffGuid = args.BuffGuid
-            });
-        }
-        catch (Exception ex)
-        {
-            CoreLogger.LogException("Error in buff destroy prefix", ex);
-        }
-
-        return true; // Continue with original method
-    }
-}
diff --git a/Core/Patches/BuffSystemSpawnServerPatch.cs b/Core/Patches/BuffSystemSpawnServerPatch.cs
deleted file mode 100644
index 6a61053..0000000
--- a/Core/Patches/BuffSystemSpawnServerPatch.cs
+++ /dev/null
@@ -1,62 +0,0 @@
-using System;
-using HarmonyLib;
-using ProjectM;
-using ProjectM.Gameplay.Systems;
-using Unity.Entities;
-using Unity.Collections;
-using VAutomationCore.Core.Events;
-using VAutomationCore.Core.Logging;
-
-namespace VAutomationCore.Core.Patches;
-
-/// <summary>
-/// Non-destructive patch for BuffSystem_Spawn_Server.
-/// Provides events for buff spawn operations without modifying original behavior.
-/// </summary>
-[HarmonyPatch(typeof(BuffSystem_Spawn_Server))]
-public static class BuffSystemSpawnServerPatch
-{
-    private const string LogSource = "BuffSystemSpawnServerPatch";
-
-    [HarmonyPrefix]
-    [HarmonyPatch("OnUpdate")]
-    public static void Prefix(BuffSystem_Spawn_Server __instance)
-    {
-        try
-        {
-            if (!CoreLogger.IsInitialized) return;
-
-            // Safely iterate spawn queue
-            using (var entities = __instance._SpawnQueue.ToEntityArray(Allocator.Temp))
-            {
-                if (entities.Length == 0) return;
-                
-                TypedEventBus.Publish(new BuffSpawnQueueEvent
-                {
-                    Entities = entities.ToArray()
-                });
-            }
-        }
-        catch (Exception ex)
-        {
-            CoreLogger.LogException($"[{LogSource}] Error in prefix", ex);
-        }
-    }
-
-    [HarmonyPostfix]
-    [HarmonyPatch("OnUpdate")]
-    public static void Postfix(BuffSystem_Spawn_Server __instance)
-    {
-        try
-        {
-            if (!CoreLogger.IsInitialized) return;
-            
-            // Emit event for post-spawn processing
-            TypedEventBus.Publish(new BuffSpawnCompleteEvent());
-        }
-        catch (Exception ex)
-        {
-            CoreLogger.LogException($"[{LogSource}] Error in postfix", ex);
-        }
-    }
-}
diff --git a/Core/Patches/ConnectionEventPatches.cs b/Core/Patches/ConnectionEventPatches.cs
deleted file mode 100644
index fade8ea..0000000
--- a/Core/Patches/ConnectionEventPatches.cs
+++ /dev/null
@@ -1,175 +0,0 @@
-using System;
-using System.Reflection;
-using HarmonyLib;
-using ProjectM;
-using ProjectM.Network;
-using Stunlock.Network;
-using VAutomationCore.Core.Events;
-using VAutomationCore.Core.Logging;
-
-namespace VAutomationCore.Core.Patches;
-
-/// <summary>
-/// Handles user connection/disconnection events.
-/// Provides events for player connect/disconnect with user index resolution.
-/// </summary>
-public static class ConnectionEventPatches
-{
-    private static bool _isInitialized = false;
-    private static Harmony _harmony;
-    private static readonly string _logPrefix = "[ConnectionEventPatches]";
-    
-    // Cache the NetEndPointToUserIndex field for performance
-    private static FieldInfo _netEndPointToUserIndexField;
-
-    public static event EventHandler<UserConnectedEventArgs> OnUserConnected;
-    public static event EventHandler<UserDisconnectedEventArgs> OnUserDisconnected;
-    
-    public class UserConnectedEventArgs : EventArgs
-    {
-        public int UserIndex { get; set; }
-        public NetConnectionId ConnectionId { get; set; }
-    }
-    
-    public class UserDisconnectedEventArgs : EventArgs
-    {
-        public int UserIndex { get; set; }
-        public NetConnectionId ConnectionId { get; set; }
-    }
-
-    public static void Initialize()
-    {
-        if (_isInitialized) return;
-
-        // Try to get the internal field via reflection
-        try {
-            var bootstrapType = typeof(ServerBootstrapSystem);
-            _netEndPointToUserIndexField = bootstrapType.GetField("_NetEndPointToUserIndex", 
-                BindingFlags.NonPublic | BindingFlags.Instance);
-            if (_netEndPointToUserIndexField != null)
-            {
-                CoreLogger.LogInfo($"{_logPrefix} Found _NetEndPointToUserIndex field via reflection");
-            }
-            else
-            {
-                CoreLogger.LogWarning($"{_logPrefix} _NetEndPointToUserIndex field not found - connection events will be skipped");
-            }
-        } catch (Exception ex) {
-            CoreLogger.LogWarning($"{_logPrefix} Failed to get _NetEndPointToUserIndex: {ex.Message}");
-        }
-
-        _harmony = new Harmony("gg.coyote.VAutomationCore.ConnectionEvents");
-        _harmony.PatchAll(typeof(ConnectionEventPatches));
-        _isInitialized = true;
-
-        CoreLogger.LogInfo($"{_logPrefix} Initialized");
-    }
-
-    public static void Dispose()
-    {
-        _harmony?.UnpatchSelf();
-        _isInitialized = false;
-    }
-
-    /// <summary>
-    /// Handles player connection events.
-    /// </summary>
-    [HarmonyPatch(typeof(ServerBootstrapSystem), nameof(ServerBootstrapSystem.OnUserConnected))]
-    public static class OnUserConnectedPatch
-    {
-        [HarmonyPostfix]
-        public static void Postfix(ServerBootstrapSystem __instance, NetConnectionId netConnectionId)
-        {
-            try
-            {
-                var userIndex = GetUserIndex(__instance, netConnectionId);
-                if (userIndex.HasValue)
-                {
-                    var args = new UserConnectedEventArgs
-                    {
-                        UserIndex = userIndex.Value,
-                        ConnectionId = netConnectionId
-                    };
-                    
-                    OnUserConnected?.Invoke(__instance, args);
-                    TypedEventBus.Publish(new UserConnectedEvent
-                    {
-                        UserIndex = userIndex.Value,
-                        ConnectionId = netConnectionId
-                    });
-                }
-                else
-                {
-                    CoreLogger.LogDebug($"{_logPrefix} OnUserConnected: could not resolve user index for {netConnectionId}");
-                }
-            }
-            catch (Exception ex)
-            {
-                CoreLogger.LogError($"{_logPrefix} OnUserConnected Error: {ex.Message}");
-            }
-        }
-    }
-
-    /// <summary>
-    /// Handles player disconnection events.
-    /// </summary>
-    [HarmonyPatch(typeof(ServerBootstrapSystem), nameof(ServerBootstrapSystem.OnUserDisconnected))]
-    public static class OnUserDisconnectedPatch
-    {
-        [HarmonyPostfix]
-        public static void Postfix(ServerBootstrapSystem __instance, NetConnectionId netConnectionId)
-        {
-            try
-            {
-                var userIndex = GetUserIndex(__instance, netConnectionId);
-                if (userIndex.HasValue)
-                {
-                    var args = new UserDisconnectedEventArgs
-                    {
-                        UserIndex = userIndex.Value,
-                        ConnectionId = netConnectionId
-                    };
-                    
-                    OnUserDisconnected?.Invoke(__instance, args);
-                    TypedEventBus.Publish(new UserDisconnectedEvent
-                    {
-                        UserIndex = userIndex.Value,
-                        ConnectionId = netConnectionId
-                    });
-                }
-                else
-                {
-                    CoreLogger.LogDebug($"{_logPrefix} OnUserDisconnected: could not resolve user index for {netConnectionId}");
-                }
-            }
-            catch (Exception ex)
-            {
-                CoreLogger.LogError($"{_logPrefix} OnUserDisconnected Error: {ex.Message}");
-            }
-        }
-    }
-
-    /// <summary>
-    /// Try to get user index from NetConnectionId using reflection.
-    /// Returns null if the field is not available.
-    /// </summary>
-    private static int? GetUserIndex(ServerBootstrapSystem instance, NetConnectionId connectionId)
-    {
-        if (_netEndPointToUserIndexField == null)
-            return null;
-
-        try
-        {
-            var dictionary = _netEndPointToUserIndexField.GetValue(instance) as System.Collections.IDictionary;
-            if (dictionary != null && dictionary.Contains(connectionId))
-            {
-                return (int)dictionary[connectionId];
-            }
-        }
-        catch (Exception ex)
-        {
-            CoreLogger.LogWarning($"{_logPrefix} Failed to get user index: {ex.Message}");
-        }
-        return null;
-    }
-}
diff --git a/Core/Patches/CorePatchBootstrap.cs b/Core/Patches/CorePatchBootstrap.cs
deleted file mode 100644
index 0216918..0000000
--- a/Core/Patches/CorePatchBootstrap.cs
+++ /dev/null
@@ -1,8 +0,0 @@
-namespace VAutomationCore.Core.Patches
-{
-    /// <summary>
-    /// Bootstrap class for Harmony patch discovery.
-    /// All patches in this assembly will be auto-discovered by Harmony PatchAll.
-    /// </summary>
-    internal static class CorePatchBootstrap { }
-}
diff --git a/Core/Patches/DeathEventSystemPatch.cs b/Core/Patches/DeathEventSystemPatch.cs
deleted file mode 100644
index 8309cc1..0000000
--- a/Core/Patches/DeathEventSystemPatch.cs
+++ /dev/null
@@ -1,71 +0,0 @@
-using System;
-using HarmonyLib;
-using ProjectM;
-using Unity.Collections;
-using Unity.Entities;
-using VAutomationCore.Core;
-using VAutomationCore.Core.Events;
-using VAutomationCore.Core.Logging;
-
-namespace VAutomationCore.Core.Patches;
-
-/// <summary>
-/// Patch for DeathEventListenerSystem to track death events.
-/// Provides events for kills, deaths, and VBlood consumption.
-/// </summary>
-[HarmonyPatch]
-internal static class DeathEventSystemPatch
-{
-    public static event EventHandler<DeathEventArgs> OnDeathEvent;
-    
-    public class DeathEventArgs : EventArgs
-    {
-        public Entity Killer { get; set; }
-        public Entity Victim { get; set; }
-        public StatChangeReason Reason { get; set; }
-        public bool IsPlayerKill { get; set; }
-        public bool IsVBlood { get; set; }
-    }
-
-    [HarmonyPatch(typeof(DeathEventListenerSystem), nameof(DeathEventListenerSystem.OnUpdate))]
-    [HarmonyPostfix]
-    static unsafe void OnUpdatePostfix(DeathEventListenerSystem __instance)
-    {
-        if (!CoreLogger.IsInitialized) return;
-
-        try
-        {
-            using var deathEvents = __instance._DeathEventQuery.ToComponentDataArrayAccessor<DeathEvent>(Allocator.Temp);
-            var killerLookup = __instance.GetComponentLookup<Killer>(true);
-            var vBloodLookup = __instance.GetComponentLookup<VBloodConsumeSource>(true);
-
-            for (int i = 0; i < deathEvents.Length; i++)
-            {
-                var deathEvent = deathEvents[i];
-                
-                var args = new DeathEventArgs
-                {
-                    Killer = deathEvent.Killer,
-                    Victim = deathEvent.Died,
-                    Reason = deathEvent.StatChangeReason,
-                    IsPlayerKill = killerLookup.HasComponent(deathEvent.Killer),
-                    IsVBlood = vBloodLookup.HasComponent(deathEvent.Died)
-                };
-
-                OnDeathEvent?.Invoke(__instance, args);
-                TypedEventBus.Publish(new DeathOccurredEvent
-                {
-                    Killer = args.Killer,
-                    Victim = args.Victim,
-                    Reason = args.Reason,
-                    IsPlayerKill = args.IsPlayerKill,
-                    IsVBlood = args.IsVBlood
-                });
-            }
-        }
-        catch (Exception ex)
-        {
-            CoreLogger.LogException("Error processing death events", ex);
-        }
-    }
-}
diff --git a/Core/Patches/DropInventorySystemPatch.cs b/Core/Patches/DropInventorySystemPatch.cs
deleted file mode 100644
index e8634c4..0000000
--- a/Core/Patches/DropInventorySystemPatch.cs
+++ /dev/null
@@ -1,95 +0,0 @@
-using System;
-using System.Runtime.InteropServices;
-using HarmonyLib;
-using ProjectM;
-using ProjectM.Shared;
-using Stunlock.Core;
-using Unity.Entities;
-using Unity.Transforms;
-using VAutomationCore.Core.Events;
-using VAutomationCore.Core.Logging;
-
-namespace VAutomationCore.Core.Patches;
-
-/// <summary>
-/// Patch for DropInventorySystem.DropItem to control item drop behavior.
-/// Useful for preventing drops in specific zones or situations.
-/// </summary>
-[HarmonyPatch(typeof(DropInventorySystem), nameof(DropInventorySystem.DropItem))]
-internal static class DropInventorySystemPatch
-{
-    public static event EventHandler<DropItemEventArgs> OnDropItem;
-    
-    public class DropItemEventArgs : EventArgs
-    {
-        public Entity ItemEntity { get; set; }
-        public Entity Owner { get; set; }
-        public PrefabGUID ItemHash { get; set; }
-        public int Amount { get; set; }
-        public bool CancelDrop { get; set; }
-    }
-
-    [HarmonyPrefix]
-    private static bool Prefix(
-        DropInventorySystem __instance,
-        EntityCommandBuffer commandBuffer,
-        [In] ref Translation translation,
-        PrefabGUID itemHash,
-        int amount,
-        Entity itemEntity,
-        Il2CppSystem.Nullable_Unboxed<float> customDropArc,
-        Il2CppSystem.Nullable_Unboxed<float> minRange,
-        Il2CppSystem.Nullable_Unboxed<float> maxRange)
-    {
-        try
-        {
-            var em = __instance.EntityManager;
-            if (em == default || itemEntity == Entity.Null || !em.Exists(itemEntity))
-            {
-                return true;
-            }
-
-            if (!em.HasComponent<EntityOwner>(itemEntity))
-            {
-                return true;
-            }
-
-            var owner = em.GetComponentData<EntityOwner>(itemEntity).Owner;
-            if (owner == Entity.Null || !em.Exists(owner))
-            {
-                return true;
-            }
-
-            var args = new DropItemEventArgs
-            {
-                ItemEntity = itemEntity,
-                Owner = owner,
-                ItemHash = itemHash,
-                Amount = amount,
-                CancelDrop = false
-            };
-
-            OnDropItem?.Invoke(__instance, args);
-
-            if (args.CancelDrop)
-            {
-                return false;
-            }
-
-            // Publish event for subscribers to react
-            TypedEventBus.Publish(new DropItemEvent
-            {
-                ItemEntity = itemEntity,
-                Owner = owner,
-                ItemHash = itemHash,
-                Amount = amount
-            });
-        }
-        catch (Exception ex)
-        {
-            CoreLogger.LogException($"[DropInventorySystemPatch] Drop hook failed", ex);
-        }
-
-        return true;
-    }
-}
diff --git a/Core/Patches/InputSystemUpdatePatch.cs b/Core/Patches/InputSystemUpdatePatch.cs
deleted file mode 100644
index 5a4ee2e..0000000
--- a/Core/Patches/InputSystemUpdatePatch.cs
+++ /dev/null
@@ -1,129 +0,0 @@
-using HarmonyLib;
-using ProjectM;
-using Unity.Entities;
-using Unity.Collections;
-using UnityEngine;
-
-namespace VAutomationCore.Core.Patches;
-
-/// <summary>
-/// Patches ClientBootstrapSystem.OnUpdate to momentarily block all game inputs during ZUI interactions.
-/// Only blocks when explicitly triggered by ZUIInputBlocker.BlockMomentarily().
-/// </summary>
-[HarmonyPatch(typeof(ClientBootstrapSystem), nameof(ClientBootstrapSystem.OnUpdate))]
-public static class InputSystemUpdatePatch
-{
-    private static bool _previousBlockState = false;
-
-    [HarmonyPostfix]
-    public static void Postfix(ClientBootstrapSystem __instance)
-    {
-        try
-        {
-            var shouldBlock = ZUIInputBlocker.ShouldBlock;
-
-            // CRITICAL: Only do something if the block state has CHANGED
-            if (shouldBlock == _previousBlockState)
-            {
-                return; // No change, do nothing
-            }
-
-            CoreLogger.LogDebug($"[ZUI] Block state changed: {_previousBlockState} -> {shouldBlock}");
-            _previousBlockState = shouldBlock;
-
-            var entityManager = __instance.EntityManager;
-            var playerQuery = entityManager.CreateEntityQuery(
-                ComponentType.ReadOnly<PlayerCharacter>(),
-                ComponentType.ReadOnly<EntityInput>()
-            );
-
-            if (playerQuery.IsEmpty)
-            {
-                playerQuery.Dispose();
-                return;
-            }
-
-            var playerEntities = playerQuery.ToEntityArray(Allocator.Temp);
-
-            foreach (var playerEntity in playerEntities)
-            {
-                if (shouldBlock)
-                {
-                    // BLOCK: Add components
-                    if (!entityManager.HasComponent<InputActionsDisabled>(playerEntity))
-                    {
-                        entityManager.AddComponentData(playerEntity, new InputActionsDisabled());
-                        CoreLogger.LogDebug("[ZUI] Added InputActionsDisabled");
-                    }
-
-                    if (!entityManager.HasComponent<Disabled>(playerEntity))
-                    {
-                        entityManager.AddComponentData(playerEntity, new Disabled());
-                        CoreLogger.LogDebug("[ZUI] Added Disabled");
-                    }
-                }
-                else
-                {
-                    // UNBLOCK: Remove components
-                    if (entityManager.HasComponent<InputActionsDisabled>(playerEntity))
-                    {
-                        entityManager.RemoveComponent<InputActionsDisabled>(playerEntity);
-                        CoreLogger.LogDebug("[ZUI] Removed InputActionsDisabled");
-                    }
-
-                    if (entityManager.HasComponent<Disabled>(playerEntity))
-                    {
-                        entityManager.RemoveComponent<Disabled>(playerEntity);
-                        CoreLogger.LogDebug("[ZUI] Removed Disabled");
-                    }
-                }
-            }
-
-            playerEntities.Dispose();
-            playerQuery.Dispose();
-        }
-        catch (System.Exception ex)
-        {
-            CoreLogger.LogError($"[ZUI] Error in input blocking: {ex}");
-        }
-    }
-}
-
-/// <summary>
-/// Helper class for ZUI input blocking.
-/// </summary>
-public static class ZUIInputBlocker
-{
-    private static bool _shouldBlock = false;
-
-    /// <summary>
-    /// Gets or sets whether input should be blocked.
-    /// </summary>
-    public static bool ShouldBlock => _shouldBlock;
-
-    /// <summary>
-    /// Block all game inputs.
-    /// </summary>
-    public static void Block()
-    {
-        _shouldBlock = true;
-    }
-
-    /// <summary>
-    /// Unblock all game inputs.
-    /// </summary>
-    public static void Unblock()
-    {
-        _shouldBlock = false;
-    }
-
-    /// <summary>
-    /// Block inputs momentarily for a short duration.
-    /// </summary>
-    public static void BlockMomentarily(float duration = 0.5f)
-    {
-        _shouldBlock = true;
-        // Note: In a real implementation, you'd use a coroutine or timer to unblock after duration
-        // For now, this is a simplified version
-    }
-}
diff --git a/Core/Patches/ReplaceAbilityOnSlotSystemPatch.cs b/Core/Patches/ReplaceAbilityOnSlotSystemPatch.cs
deleted file mode 100644
index f9527be..0000000
--- a/Core/Patches/ReplaceAbilityOnSlotSystemPatch.cs
+++ /dev/null
@@ -1,43 +0,0 @@
-using HarmonyLib;
-using ProjectM;
-using VAutomationCore.Core.Events;
-using VAutomationCore.Core.Systems;
-using Unity.Collections;
-using Unity.Entities;
-
-namespace VAutomationCore.Core.Patches;
-
-[HarmonyPatch]
-internal static class ReplaceAbilityOnSlotSystemPatch {
-  [HarmonyPatch(typeof(ReplaceAbilityOnSlotSystem), nameof(ReplaceAbilityOnSlotSystem.OnUpdate))]
-  [HarmonyPrefix]
-  static void Prefix(ReplaceAbilityOnSlotSystem __instance) {
-    if (!GameSystems.Initialized) return;
-
-    if (TypedEventBus.GetSubscriberCount<PrefixEvents.OnReplaceAbilityOnSlot>() == 0) return;
-    NativeArray<Entity> entities = __instance.__query_1482480545_0.ToEntityArray(Allocator.Temp);
-
-    try {
-      if (entities.Length == 0) return;
-      TypedEventBus.Emit(new PrefixEvents.OnReplaceAbilityOnSlot { Entities = entities });
-    } finally {
-      entities.Dispose();
-    }
-  }
-
-  [HarmonyPatch(typeof(ReplaceAbilityOnSlotSystem), nameof(ReplaceAbilityOnSlotSystem.OnUpdate))]
-  [HarmonyPostfix]
-  static void Postfix(ReplaceAbilityOnSlotSystem __instance) {
-    if (!GameSystems.Initialized) return;
-
-    if (TypedEventBus.GetSubscriberCount<PostfixEvents.OnReplaceAbilityOnSlot>() == 0) return;
-    NativeArray<Entity> entities = __instance.__query_1482480545_0.ToEntityArray(Allocator.Temp);
-
-    try {
-      if (entities.Length == 0) return;
-      TypedEventBus.Emit(new PostfixEvents.OnReplaceAbilityOnSlot { Entities = entities });
-    } finally {
-      entities.Dispose();
-    }
-  }
-}
diff --git a/Core/Patches/ServerBootstrapSystemPatch.cs b/Core/Patches/ServerBootstrapSystemPatch.cs
deleted file mode 100644
index 0a84c40..0000000
--- a/Core/Patches/ServerBootstrapSystemPatch.cs
+++ /dev/null
@@ -1,86 +0,0 @@
-using System;
-using HarmonyLib;
-using ProjectM;
-using Unity.Entities;
-using VAutomationCore.Core.Events;
-using VAutomationCore.Core.Logging;
-
-namespace VAutomationCore.Core.Patches;
-
-/// <summary>
-/// Patch for ServerBootstrapSystem to track world initialization state.
-/// Provides events for server startup, world ready, and shutdown.
-/// </summary>
-[HarmonyPatch(typeof(ServerBootstrapSystem), nameof(ServerBootstrapSystem.OnUpdate))]
-internal static class ServerBootstrapSystemPatch
-{
-    public static event EventHandler OnServerStarted;
-    public static event EventHandler OnWorldReady;
-    public static event EventHandler OnServerShutdown;
-    
-    private static bool _hasStarted = false;
-    private static bool _isReady = false;
-
-    [HarmonyPrefix]
-    static void OnUpdatePrefix(ServerBootstrapSystem __instance)
-    {
-        try
-        {
-            // Check if server has started (first update)
-            if (!_hasStarted)
-            {
-                _hasStarted = true;
-                OnServerStarted?.Invoke(__instance, EventArgs.Empty);
-                TypedEventBus.Publish(new ServerStartedEvent());
-                CoreLogger.LogInfo("Server bootstrap started");
-            }
-
-            // Check if world is ready (systems are initialized)
-            if (!_isReady && __instance.World.IsCreated)
-            {
-                _isReady = true;
-                OnWorldReady?.Invoke(__instance, EventArgs.Empty);
-                TypedEventBus.Publish(new WorldReadyEvent());
-                CoreLogger.LogInfo("World is ready - all systems initialized");
-            }
-        }
-        catch (Exception ex)
-        {
-            CoreLogger.LogException("Error in server bootstrap update", ex);
-        }
-    }
-
-    /// <summary>
-    /// Check if the server has completed startup.
-    /// </summary>
-    public static bool IsServerStarted => _hasStarted;
-
-    /// <summary>
-    /// Check if the world is ready and all systems are initialized.
-    /// </summary>
-    public static bool IsWorldReady => _isReady;
-}
-
-/// <summary>
-/// Patch for Initialization completion to track when the game world is fully loaded.
-/// </summary>
-[HarmonyPatch(typeof(WorldBootstrapSystem), nameof(WorldBootstrapSystem.Initialize))]
-internal static class WorldBootstrapPatch
-{
-    public static event EventHandler OnWorldInitialized;
-
-    [HarmonyPostfix]
-    static void InitializePostfix(WorldBootstrapSystem __instance)
-    {
-        try
-        {
-            OnWorldInitialized?.Invoke(__instance, EventArgs.Empty);
-            TypedEventBus.Publish(new WorldInitializedEvent());
-            CoreLogger.LogInfo("WorldBootstrapSystem.Initialize completed");
-        }
-        catch (Exception ex)
-        {
-            CoreLogger.LogException("Error in world bootstrap initialize", ex);
-        }
-    }
-}
diff --git a/Core/Patches/UnitSpawnerSystemPatch.cs b/Core/Patches/UnitSpawnerSystemPatch.cs
deleted file mode 100644
index da26fc3..0000000
--- a/Core/Patches/UnitSpawnerSystemPatch.cs
+++ /dev/null
@@ -1,144 +0,0 @@
-using System;
-using HarmonyLib;
-using ProjectM;
-using Unity.Collections;
-using Unity.Entities;
-using Unity.Mathematics;
-using VAutomationCore.Core.Events;
-using VAutomationCore.Core.Logging;
-
-namespace VAutomationCore.Core.Patches;
-
-/// <summary>
-/// Patch for UnitSpawnerSystem to track when units are spawned.
-/// Useful for tracking spawns, spawners, and spawn locations.
-/// </summary>
-[HarmonyPatch(typeof(UnitSpawnerSystem), nameof(UnitSpawnerSystem.OnUpdate))]
-internal static class UnitSpawnerSystemPatch
-{
-    public static event EventHandler<UnitSpawnEventArgs> OnUnitSpawned;
-    
-    public class UnitSpawnEventArgs : EventArgs
-    {
-        public Entity Spawner { get; set; }
-        public Entity SpawnedUnit { get; set; }
-        public PrefabGUID PrefabGuid { get; set; }
-        public float3 Position { get; set; }
-        public int Level { get; set; }
-        public bool IsNightSpawn { get; set; }
-    }
-
-    [HarmonyPostfix]
-    static unsafe void OnUpdatePostfix(UnitSpawnerSystem __instance)
-    {
-        if (!CoreLogger.IsInitialized) return;
-
-        try
-        {
-            // Access the internal spawn buffer if available
-            var spawnBufferField = typeof(UnitSpawnerSystem)
-                .GetField("_SpawnBuffer", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
-            
-            if (spawnBufferField != null)
-            {
-                var spawnBuffer = spawnBufferField.GetValue(__instance) as NativeList<UnitSpawnRequest>;
-                if (spawnBuffer != null)
-                {
-                    for (int i = 0; i < spawnBuffer.Length; i++)
-                    {
-                        var spawnRequest = spawnBuffer[i];
-                        
-                        var args = new UnitSpawnEventArgs
-                        {
-                            Spawner = spawnRequest.SpawnerEntity,
-                            SpawnedUnit = spawnRequest.UnitEntity,
-                            PrefabGuid = spawnRequest.PrefabGuid,
-                            Position = spawnRequest.Position,
-                            Level = spawnRequest.Level,
-                            IsNightSpawn = spawnRequest.NightPop
-                        };
-
-                        OnUnitSpawned?.Invoke(__instance, args);
-                        TypedEventBus.Publish(new UnitSpawnedEvent
-                        {
-                            Spawner = args.Spawner,
-                            SpawnedUnit = args.SpawnedUnit,
-                            PrefabGuid = args.PrefabGuid,
-                            Position = args.Position,
-                            Level = args.Level,
-                            IsNightSpawn = args.IsNightSpawn
-                        });
-                    }
-                }
-            }
-        }
-        catch (Exception ex)
-        {
-            CoreLogger.LogException("Error processing unit spawn events", ex);
-        }
-    }
-}
-
-/// <summary>
-/// Patch for tracking spawn travel buff events.
-/// Useful for tracking when units get spawn travel buffs.
-/// </summary>
-[HarmonyPatch(typeof(SpawnTravelBuffSystem), nameof(SpawnTravelBuffSystem.OnUpdate))]
-internal static class SpawnTravelBuffSystemPatch
-{
-    public static event EventHandler<SpawnTravelBuffEventArgs> OnSpawnTravelBuffApplied;
-    
-    public class SpawnTravelBuffEventArgs : EventArgs
-    {
-        public Entity Unit { get; set; }
-        public PrefabGUID PrefabGuid { get; set; }
-        public float3 Position { get; set; }
-        public bool IsMoving { get; set; }
-    }
-
-    [HarmonyPostfix]
-    static void OnUpdatePostfix(SpawnTravelBuffSystem __instance)
-    {
-        if (!CoreLogger.IsInitialized) return;
-
-        try
-        {
-            using var query = __instance.EntityManager.CreateEntityQuery(
-                ComponentType.ReadOnly<SpawnTravelBuff>(),
-                ComponentType.ReadOnly<LocalTransform>()
-            );
-
-            var entities = query.ToEntityArray(Allocator.Temp);
-            var buffs = query.ToComponentDataArray<SpawnTravelBuff>(Allocator.Temp);
-            var transforms = query.ToComponentDataArray<LocalTransform>(Allocator.Temp);
-
-            for (int i = 0; i < entities.Length; i++)
-            {
-                var args = new SpawnTravelBuffEventArgs
-                {
-                    Unit = entities[i],
-                    PrefabGuid = buffs[i].PrefabGuid,
-                    Position = transforms[i].Position,
-                    IsMoving = !buffs[i].Arrived
-                };
-
-                OnSpawnTravelBuffApplied?.Invoke(__instance, args);
-                TypedEventBus.Publish(new SpawnTravelBuffAppliedEvent
-                {
-                    Unit = args.Unit,
-                    PrefabGuid = args.PrefabGuid,
-                    Position = args.Position,
-                    IsMoving = args.IsMoving
-                });
-            }
-
-            entities.Dispose();
-            buffs.Dispose();
-            transforms.Dispose();
-        }
-        catch (Exception ex)
-        {
-            CoreLogger.LogException("Error processing spawn travel buff events", ex);
-        }
-    }
-}
diff --git a/Core/Services/Ecs/EcsSystemHierarchyModel.cs b/Core/Services/Ecs/EcsSystemHierarchyModel.cs
deleted file mode 100644
index 523401f..0000000
--- a/Core/Services/Ecs/EcsSystemHierarchyModel.cs
+++ /dev/null
@@ -1,169 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using ProjectM;
-using Unity.Entities;
-
-namespace VAutomationCore.Core.Services.Ecs
-{
-    /// <summary>
-    /// Classifies ECS systems by runtime shape.
-    /// </summary>
-    public enum EcsSystemCategory
-    {
-        /// <summary>
-        /// A <see cref="ComponentSystemGroup"/>.
-        /// </summary>
-        Group,
-
-        /// <summary>
-        /// A managed <see cref="ComponentSystemBase"/>, but not a group.
-        /// </summary>
-        Base,
-
-        /// <summary>
-        /// An unmanaged system implementing <c>ISystem</c>.
-        /// </summary>
-        Unmanaged,
-
-        /// <summary>
-        /// Referenced in hierarchy but unresolved or not discoverable.
-        /// </summary>
-        Unknown,
-    }
-
-    /// <summary>
-    /// Represents one system node in an ECS update hierarchy.
-    /// </summary>
-    public sealed class EcsSystemTreeNode
-    {
-        public EcsSystemTreeNode(
-            EcsSystemCategory category,
-            SystemHandle systemHandle,
-            Il2CppSystem.Type type = null,
-            ComponentSystemBase instance = null)
-        {
-            if (category == EcsSystemCategory.Unmanaged && instance != null)
-            {
-                throw new ArgumentException("Unmanaged systems cannot carry a managed ComponentSystemBase instance.", nameof(instance));
-            }
-
-            Category = category;
-            Type = type;
-            SystemHandle = systemHandle;
-            Instance = instance;
-        }
-
-        public EcsSystemCategory Category { get; }
-
-        public Il2CppSystem.Type Type { get; }
-
-        public SystemHandle SystemHandle { get; }
-
-        /// <summary>
-        /// Managed system instance. This is valid only for managed categories
-        /// (typically <see cref="EcsSystemCategory.Group"/> and <see cref="EcsSystemCategory.Base"/>).
-        /// For unmanaged systems this must be null.
-        /// </summary>
-        public ComponentSystemBase Instance { get; }
-
-        public IList<EcsSystemTreeNode> ChildrenOrderedForUpdate { get; } = new List<EcsSystemTreeNode>();
-
-        public IList<EcsSystemTreeNode> Parents { get; } = new List<EcsSystemTreeNode>();
-
-        public int CountDescendants()
-        {
-            var count = 0;
-            foreach (var child in ChildrenOrderedForUpdate)
-            {
-                count++;
-                count += child.CountDescendants();
-            }
-
-            return count;
-        }
-    }
-
-    public sealed class EcsSystemHierarchy
-    {
-        public World World { get; init; }
-
-        public EcsSystemCounts Counts { get; init; } = new();
-
-        public KnownUnknowns KnownUnknowns { get; init; } = new();
-
-        public IList<EcsSystemTreeNode> RootNodesUnordered { get; init; } = new List<EcsSystemTreeNode>();
-
-        public IList<EcsSystemTreeNode> FindNodesWithMultipleParents()
-        {
-            var foundNodes = new List<EcsSystemTreeNode>();
-            var visited = new HashSet<EcsSystemTreeNode>();
-
-            foreach (var node in RootNodesUnordered)
-            {
-                FindNodesWithMultipleParents(node, foundNodes, visited);
-            }
-
-            return foundNodes;
-        }
-
-        private static void FindNodesWithMultipleParents(
-            EcsSystemTreeNode node,
-            IList<EcsSystemTreeNode> foundNodes,
-            HashSet<EcsSystemTreeNode> visited)
-        {
-            if (node == null || !visited.Add(node))
-            {
-                return;
-            }
-
-            if (node.Parents.Count > 1)
-            {
-                foundNodes.Add(node);
-            }
-
-            foreach (var childNode in node.ChildrenOrderedForUpdate)
-            {
-                FindNodesWithMultipleParents(childNode, foundNodes, visited);
-            }
-        }
-    }
-
-    public sealed class EcsSystemCounts
-    {
-        public int Group;
-        public int Base;
-        public int Unmanaged;
-
-        /// <summary>
-        /// Referenced by hierarchy but not discoverable/resolvable as an instantiated runtime system.
-        /// </summary>
-        public int Unknown;
-
-        /// <summary>
-        /// Known system type but currently not instantiated in the world.
-        /// </summary>
-        public int NotUsed;
-
-        public int SumUsed()
-        {
-            return Group + Base + Unmanaged + Unknown;
-        }
-    }
-
-    public sealed class KnownUnknowns
-    {
-        public ISet<SystemHandle> SystemNotFoundInWorld { get; } = new HashSet<SystemHandle>();
-
-        public bool HasUnknownSystems()
-        {
-            return SystemNotFoundInWorld.Any();
-        }
-
-        [Obsolete("Use HasUnknownSystems() for clear semantics.")]
-        public bool AreKnown()
-        {
-            return HasUnknownSystems();
-        }
-    }
-}
diff --git a/Core/Services/Ecs/EcsSystemHierarchyService.cs b/Core/Services/Ecs/EcsSystemHierarchyService.cs
deleted file mode 100644
index 3fe8c9a..0000000
--- a/Core/Services/Ecs/EcsSystemHierarchyService.cs
+++ /dev/null
@@ -1,218 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using BepInEx.Logging;
-using Unity.Entities;
-
-namespace VAutomationCore.Core.Services.Ecs
-{
-    /// <summary>
-    /// Builds a point-in-time structural ECS hierarchy snapshot for a given world.
-    /// This is "what exists in the world and how groups reference children",
-    /// not a full scheduler/constraint simulation.
-    /// </summary>
-    public sealed class EcsSystemHierarchyService
-    {
-        private readonly ManualLogSource _log;
-
-        public EcsSystemHierarchyService(ManualLogSource log)
-        {
-            _log = log;
-        }
-
-        // Kept for compatibility with existing callers that may contain the original typo.
-        public EcsSystemHierarchy BuildSystemHiearchyForWorld(World world) => BuildSystemHierarchyForWorld(world);
-
-        public EcsSystemHierarchy BuildSystemHierarchyForWorld(World world)
-        {
-            _log?.LogInfo($"[EcsSystemHierarchyService] Building hierarchy for world: {world?.Name ?? "<null>"}");
-
-            if (world == null || !world.IsCreated)
-            {
-                return new EcsSystemHierarchy
-                {
-                    World = world,
-                    Counts = new EcsSystemCounts(),
-                    KnownUnknowns = new KnownUnknowns(),
-                    RootNodesUnordered = new List<EcsSystemTreeNode>()
-                };
-            }
-
-            var knownUnknowns = new KnownUnknowns();
-            var nodes = FindSystems(world, out var counts);
-            var groupNodes = nodes.Values.Where(node => node.Category == EcsSystemCategory.Group).ToList();
-
-            foreach (var groupNode in groupNodes)
-            {
-                try
-                {
-                    if (groupNode.Instance is not ComponentSystemGroup group)
-                    {
-                        continue;
-                    }
-
-                    var orderedSubsystems = group.GetAllSystems();
-                    foreach (var subsystemHandle in orderedSubsystems)
-                    {
-                        if (!nodes.TryGetValue(subsystemHandle, out var childNode))
-                        {
-                            if (TryGetSystemTypeIndexForMissedSystem(world, subsystemHandle, out var subsystemTypeIndex))
-                            {
-                                childNode = BuildNodeAndIncrementAppropriateCount(world, subsystemTypeIndex, counts);
-                                if (!nodes.ContainsKey(subsystemHandle))
-                                {
-                                    nodes[subsystemHandle] = childNode;
-                                }
-                            }
-                            else
-                            {
-                                counts.Unknown++;
-                                knownUnknowns.SystemNotFoundInWorld.Add(subsystemHandle);
-
-                                childNode = new EcsSystemTreeNode(
-                                    category: EcsSystemCategory.Unknown,
-                                    systemHandle: subsystemHandle,
-                                    type: null,
-                                    instance: null);
-
-                                _log?.LogWarning($"[EcsSystemHierarchyService] Group child not found in world. Group={groupNode.Type?.FullName ?? "<unknown>"}, Handle={subsystemHandle}");
-                            }
-                        }
-
-                        groupNode.ChildrenOrderedForUpdate.Add(childNode);
-
-                        if (childNode.Parents.Count > 0)
-                        {
-                            var existingParents = string.Join(", ", childNode.Parents.Select(p => p.Type?.FullName ?? "<unknown>"));
-                            _log?.LogDebug($"[EcsSystemHierarchyService] System appears in multiple groups: {childNode.Type?.FullName ?? "<unknown>"}. Existing=[{existingParents}] New={groupNode.Type?.FullName ?? "<unknown>"}");
-                        }
-
-                        childNode.Parents.Add(groupNode);
-                    }
-                }
-                catch (Exception ex)
-                {
-                    _log?.LogWarning($"[EcsSystemHierarchyService] Failed processing group {groupNode.Type?.FullName ?? "<unknown>"}: {ex.Message}");
-                }
-            }
-
-            var rootNodes = nodes.Values.Where(node => node.Parents.Count == 0).ToList();
-
-            return new EcsSystemHierarchy
-            {
-                World = world,
-                Counts = counts,
-                KnownUnknowns = knownUnknowns,
-                RootNodesUnordered = rootNodes,
-            };
-        }
-
-        private static Dictionary<SystemHandle, EcsSystemTreeNode> FindSystems(World world, out EcsSystemCounts counts)
-        {
-            var nodes = new Dictionary<SystemHandle, EcsSystemTreeNode>();
-            counts = new EcsSystemCounts();
-
-            var systemTypeIndices = TypeManager.GetSystemTypeIndices(WorldSystemFilterFlags.All, 0);
-            foreach (var systemTypeIndex in systemTypeIndices)
-            {
-                var systemHandle = world.GetExistingSystem(systemTypeIndex);
-                if (!world.Unmanaged.IsSystemValid(systemHandle))
-                {
-                    counts.NotUsed++;
-                    continue;
-                }
-
-                if (nodes.ContainsKey(systemHandle))
-                {
-                    continue;
-                }
-
-                var node = BuildNodeAndIncrementAppropriateCount(world, systemTypeIndex, counts);
-                nodes.Add(systemHandle, node);
-            }
-
-            return nodes;
-        }
-
-        private static EcsSystemTreeNode BuildNodeAndIncrementAppropriateCount(World world, SystemTypeIndex systemTypeIndex, EcsSystemCounts counts)
-        {
-            var systemHandle = world.GetExistingSystem(systemTypeIndex);
-            var systemType = world.Unmanaged.GetTypeOfSystem(systemHandle);
-            var category = CategorizeSystem(systemTypeIndex);
-
-            var instance = systemTypeIndex.IsManaged
-                ? world.GetExistingSystemInternal(systemTypeIndex)
-                : null;
-
-            var node = new EcsSystemTreeNode(
-                category: category,
-                systemHandle: systemHandle,
-                type: systemType,
-                instance: instance);
-
-            switch (category)
-            {
-                case EcsSystemCategory.Group:
-                    counts.Group++;
-                    break;
-                case EcsSystemCategory.Base:
-                    counts.Base++;
-                    break;
-                case EcsSystemCategory.Unmanaged:
-                    counts.Unmanaged++;
-                    break;
-            }
-
-            return node;
-        }
-
-        private static EcsSystemCategory CategorizeSystem(SystemTypeIndex systemTypeIndex)
-        {
-            return systemTypeIndex.IsGroup
-                ? EcsSystemCategory.Group
-                : systemTypeIndex.IsManaged
-                    ? EcsSystemCategory.Base
-                    : EcsSystemCategory.Unmanaged;
-        }
-
-        private bool TryGetSystemTypeIndexForMissedSystem(World world, SystemHandle systemHandle, out SystemTypeIndex systemTypeIndex, bool logDebug = true)
-        {
-            systemTypeIndex = SystemTypeIndex.Null;
-
-            if (systemHandle.Equals(SystemHandle.Null))
-            {
-                return false;
-            }
-
-            if (!world.Unmanaged.IsSystemValid(systemHandle))
-            {
-                return false;
-            }
-
-            var systemType = world.Unmanaged.GetTypeOfSystem(systemHandle);
-            if (systemType == null)
-            {
-                return false;
-            }
-
-            systemTypeIndex = TypeManager.GetSystemTypeIndex(systemType);
-
-            if (logDebug)
-            {
-                var filtered = TypeManager.GetSystemTypeIndices(WorldSystemFilterFlags.All, 0);
-                var filteredSet = new HashSet<int>(filtered.Select(x => x.Index));
-                var existsInFiltered = filteredSet.Contains(systemTypeIndex.Index);
-
-                var sb = new StringBuilder();
-                sb.AppendLine($"Found missed system {systemType.FullName}.");
-                sb.AppendLine($"  SystemTypeIndex.Index: {systemTypeIndex.Index}");
-                sb.Append($"  Exists in TypeManager.GetSystemTypeIndices(WorldSystemFilterFlags.All, 0): {existsInFiltered}");
-                _log?.LogDebug(sb.ToString());
-            }
-
-            return true;
-        }
-    }
-}
-
diff --git a/Core/Systems/LifecycleEventBridgeSystem.cs b/Core/Systems/LifecycleEventBridgeSystem.cs
new file mode 100644
index 0000000..24ed48d
--- /dev/null
+++ b/Core/Systems/LifecycleEventBridgeSystem.cs
@@ -0,0 +1,128 @@
+using Unity.Entities;
+using Unity.Collections;
+using VAuto.Core.Components;
+using VAuto.Core.Lifecycle;
+using Microsoft.Extensions.Logging;
+
+namespace VAuto.Core.Systems
+{
+    /// <summary>
+    /// Bridges ECS request components to lifecycle handlers.
+    /// Routes requests to appropriate handlers based on type.
+    /// Runs every frame to process pending automation requests.
+    /// </summary>
+    [UpdateInGroup(typeof(SimulationSystemGroup))]
+    public partial class LifecycleEventBridgeSystem : SystemBase
+    {
+        private EntityQuery _pendingRequests;
+        private ILogger<LifecycleEventBridgeSystem> _log;
+        private Entity _arenaLifecycleService;
+
+        protected override void OnCreate()
+        {
+            // Query for all pending lifecycle requests
+            _pendingRequests = GetEntityQuery(
+                ComponentType.ReadOnly<LifecycleRequestBase>()
+            );
+            
+            _log = VAutoCore.LogFactory.CreateLogger<LifecycleEventBridgeSystem>();
+            _log.LogInformation("[LifecycleEventBridgeSystem] Initialized");
+        }
+
+        protected override void OnUpdate()
+        {
+            var ecb = World.GetExistingSystemManaged<BeginSimulationEntityCommandBufferSystem>()
+                .CreateCommandBuffer();
+
+            // Get ArenaUnlockLifecycleService singleton for handler routing
+            if (!SystemAPI.TryGetSingletonEntity(out _arenaLifecycleService))
+            {
+                return;
+            }
+
+            // Process pending requests
+            var requests = _pendingRequests.ToComponentDataArray<LifecycleRequestBase>(Allocator.Temp);
+
+            foreach (var request in requests)
+            {
+                try
+                {
+                    RouteRequest(request, ecb);
+                }
+                catch (System.Exception ex)
+                {
+                    _log.LogError($"Error routing request {request.Type}: {ex.Message}");
+                    UpdateRequestStatus(request, RequestStatus.Failed, ex.Message, ecb);
+                }
+            }
+
+            requests.Dispose();
+        }
+
+        /// <summary>
+        /// Routes request to appropriate handler based on type.
+        /// </summary>
+        private void RouteRequest(LifecycleRequestBase request, EntityCommandBuffer ecb)
+        {
+            switch (request.Type)
+            {
+                case RequestType.ZoneTransition:
+                    RouteZoneTransition(request, ecb);
+                    break;
+                    
+                case RequestType.Repair:
+                    RouteRepairRequest(request, ecb);
+                    break;
+                    
+                case RequestType.VBloodUnlock:
+                    RouteVBloodUnlockRequest(request, ecb);
+                    break;
+                    
+                case RequestType.SpellbookGrant:
+                    RouteSpellbookGrantRequest(request, ecb);
+                    break;
+                    
+                default:
+                    _log.LogWarning($"Unknown request type: {request.Type}");
+                    UpdateRequestStatus(request, RequestStatus.Failed, $"Unknown request type: {request.Type}", ecb);
+                    break;
+            }
+        }
+
+        private void RouteZoneTransition(LifecycleRequestBase request, EntityCommandBuffer ecb)
+        {
+            // Route to ArenaUnlockLifecycleService
+            _log.LogDebug($"Routing ZoneTransitionRequest to ArenaUnlockLifecycleService");
+            UpdateRequestStatus(request, RequestStatus.Processing, null, ecb);
+        }
+
+        private void RouteRepairRequest(LifecycleRequestBase request, EntityCommandBuffer ecb)
+        {
+            // Route to AutoRepairHandler
+            _log.LogDebug($"Routing RepairRequest to AutoRepairHandler");
+            UpdateRequestStatus(request, RequestStatus.Processing, null, ecb);
+        }
+
+        private void RouteVBloodUnlockRequest(LifecycleRequestBase request, EntityCommandBuffer ecb)
+        {
+            // Route to AutoVBloodUnlockHandler
+            _log.LogDebug($"Routing VBloodUnlockRequest to AutoVBloodUnlockHandler");
+            UpdateRequestStatus(request, RequestStatus.Processing, null, ecb);
+        }
+
+        private void RouteSpellbookGrantRequest(LifecycleRequestBase request, EntityCommandBuffer ecb)
+        {
+            // Route to AutoSpellbookGrantHandler
+            _log.LogDebug($"Routing SpellbookGrantRequest to AutoSpellbookGrantHandler");
+            UpdateRequestStatus(request, RequestStatus.Processing, null, ecb);
+        }
+
+        private void UpdateRequestStatus(LifecycleRequestBase request, RequestStatus status, string errorMessage, EntityCommandBuffer ecb)
+        {
+            request.Status = status;
+            request.ErrorMessage = errorMessage;
+            request.Timestamp = (float)SystemAPI.Time.ElapsedTime;
+            ecb.SetComponentData(request.SourceZone, request);
+        }
+    }
+}
diff --git a/CycleBorn/icon.png b/CycleBorn/1.png
similarity index 100%
rename from CycleBorn/icon.png
rename to CycleBorn/1.png
diff --git a/CycleBorn/Config/StrictMigrationScanner.cs b/CycleBorn/Config/StrictMigrationScanner.cs
deleted file mode 100644
index 1e28e47..0000000
--- a/CycleBorn/Config/StrictMigrationScanner.cs
+++ /dev/null
@@ -1,518 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Linq;
-using System.Text;
-using System.Text.Json;
-using VLifecycle;
-
-namespace VLifecycle.Config
-{
-    /// <summary>
-    /// Strict scanner for CycleBorn lifecycle mappings.
-    /// Validates key ownership and token/phase consistency.
-    /// </summary>
-    public sealed class StrictMigrationScanner
-    {
-        private const int MinCheckIntervalMs = 10;
-        private const int MaxCheckIntervalMs = 60000;
-        private const double MinPositionThreshold = 0.01d;
-        private const double MaxPositionThreshold = 10000d;
-        private const double MinMapIconRefreshSeconds = 0.1d;
-        private const double MaxMapIconRefreshSeconds = 3600d;
-
-        private static readonly HashSet<string> AllowedMappingKeys = new(StringComparer.OrdinalIgnoreCase)
-        {
-            "onEnter",
-            "onExit",
-            "useGlobalDefaults",
-            "mapIconChangePrefab"
-        };
-
-        public sealed class Violation
-        {
-            public string FilePath { get; set; } = string.Empty;
-            public string KeyPath { get; set; } = string.Empty;
-            public string Description { get; set; } = string.Empty;
-
-            public override string ToString() => $"[{FilePath}] {KeyPath}: {Description}";
-        }
-
-        private static readonly HashSet<string> AllowedRootKeys = new(StringComparer.OrdinalIgnoreCase)
-        {
-            "strictMigrationEnabled",
-            "enabled",
-            "checkIntervalMs",
-            "positionChangeThreshold",
-            "mapIconSpawnRefreshIntervalSeconds",
-            "mappings"
-        };
-
-        public bool IsStrictEnabled(string lifecycleConfigPath)
-        {
-            try
-            {
-                using var doc = JsonDocument.Parse(File.ReadAllText(lifecycleConfigPath));
-                if (doc.RootElement.TryGetProperty("strictMigrationEnabled", out var strictProp) &&
-                    strictProp.ValueKind is JsonValueKind.True or JsonValueKind.False)
-                {
-                    return strictProp.GetBoolean();
-                }
-            }
-            catch
-            {
-                // Scanner caller handles parse errors in ScanLifecycleConfig.
-            }
-
-            return false;
-        }
-
-        public List<Violation> ScanLifecycleConfig(string lifecycleConfigPath)
-        {
-            var violations = new List<Violation>();
-
-            try
-            {
-                using var doc = JsonDocument.Parse(File.ReadAllText(lifecycleConfigPath));
-                var root = doc.RootElement;
-
-                if (root.ValueKind != JsonValueKind.Object)
-                {
-                    violations.Add(new Violation
-                    {
-                        FilePath = lifecycleConfigPath,
-                        KeyPath = "$",
-                        Description = "Root must be a JSON object"
-                    });
-                    return violations;
-                }
-
-                ValidateRootKeys(root, lifecycleConfigPath, violations);
-                ValidateRootValueTypes(root, lifecycleConfigPath, violations);
-                ValidateMappings(root, lifecycleConfigPath, violations);
-            }
-            catch (Exception ex)
-            {
-                violations.Add(new Violation
-                {
-                    FilePath = lifecycleConfigPath,
-                    KeyPath = "$",
-                    Description = $"Failed to parse lifecycle config: {ex.Message}"
-                });
-            }
-
-            return violations;
-        }
-
-        public string BuildViolationReport(IReadOnlyList<Violation> violations)
-        {
-            if (violations == null || violations.Count == 0)
-            {
-                return "No strict-migration violations detected.";
-            }
-
-            var sb = new StringBuilder();
-            sb.AppendLine("=== STRICT MIGRATION VIOLATIONS ===");
-            foreach (var violation in violations)
-            {
-                sb.AppendLine(violation.ToString());
-            }
-
-            return sb.ToString();
-        }
-
-        private static void ValidateRootKeys(JsonElement root, string filePath, List<Violation> violations)
-        {
-            foreach (var prop in root.EnumerateObject())
-            {
-                if (!AllowedRootKeys.Contains(prop.Name))
-                {
-                    violations.Add(new Violation
-                    {
-                        FilePath = filePath,
-                        KeyPath = prop.Name,
-                        Description = $"Unknown root key '{prop.Name}' in CycleBorn lifecycle config"
-                    });
-                }
-            }
-        }
-
-        private static void ValidateRootValueTypes(JsonElement root, string filePath, List<Violation> violations)
-        {
-            ValidateOptionalBool(root, "strictMigrationEnabled", filePath, violations);
-            ValidateOptionalBool(root, "enabled", filePath, violations);
-            ValidateOptionalIntegerInRange(root, "checkIntervalMs", MinCheckIntervalMs, MaxCheckIntervalMs, filePath, violations);
-            ValidateOptionalNumberInRange(root, "positionChangeThreshold", MinPositionThreshold, MaxPositionThreshold, filePath, violations);
-            ValidateOptionalNumberInRange(root, "mapIconSpawnRefreshIntervalSeconds", MinMapIconRefreshSeconds, MaxMapIconRefreshSeconds, filePath, violations);
-
-            if (root.TryGetProperty("mappings", out var mappings) && mappings.ValueKind != JsonValueKind.Object)
-            {
-                violations.Add(new Violation
-                {
-                    FilePath = filePath,
-                    KeyPath = "mappings",
-                        Description = "Expected object"
-                });
-            }
-
-            if (!root.TryGetProperty("mappings", out var mappingsObject) || mappingsObject.ValueKind != JsonValueKind.Object)
-            {
-                violations.Add(new Violation
-                {
-                    FilePath = filePath,
-                    KeyPath = "mappings",
-                    Description = "Lifecycle config must define a 'mappings' object"
-                });
-                return;
-            }
-
-            if (!mappingsObject.EnumerateObject().Any())
-            {
-                violations.Add(new Violation
-                {
-                    FilePath = filePath,
-                    KeyPath = "mappings",
-                    Description = "Mappings object cannot be empty"
-                });
-            }
-        }
-
-        private static void ValidateMappings(JsonElement root, string filePath, List<Violation> violations)
-        {
-            if (!root.TryGetProperty("mappings", out var mappings) || mappings.ValueKind != JsonValueKind.Object)
-            {
-                return;
-            }
-
-            foreach (var zoneMapping in mappings.EnumerateObject())
-            {
-                var zoneId = zoneMapping.Name;
-                if (string.IsNullOrWhiteSpace(zoneId))
-                {
-                    violations.Add(new Violation
-                    {
-                        FilePath = filePath,
-                        KeyPath = "mappings.<empty>",
-                        Description = "Mapping key cannot be empty"
-                    });
-                    continue;
-                }
-
-                if (zoneMapping.Value.ValueKind != JsonValueKind.Object)
-                {
-                    violations.Add(new Violation
-                    {
-                        FilePath = filePath,
-                        KeyPath = $"mappings.{zoneId}",
-                        Description = "Zone mapping must be a JSON object"
-                    });
-                    continue;
-                }
-
-                ValidateMappingKeys(zoneMapping.Value, filePath, $"mappings.{zoneId}", violations);
-                ValidateOptionalBool(zoneMapping.Value, "useGlobalDefaults", filePath, violations, $"mappings.{zoneId}.useGlobalDefaults");
-
-                if (zoneMapping.Value.TryGetProperty("mapIconChangePrefab", out var mapIcon) &&
-                    mapIcon.ValueKind != JsonValueKind.String)
-                {
-                    violations.Add(new Violation
-                    {
-                        FilePath = filePath,
-                        KeyPath = $"mappings.{zoneId}.mapIconChangePrefab",
-                        Description = "Expected string"
-                    });
-                }
-
-                if (zoneMapping.Value.TryGetProperty("onEnter", out var onEnter))
-                {
-                    ValidateTokenArray(onEnter, filePath, $"mappings.{zoneId}.onEnter", TokenPhase.OnEnter, violations);
-                }
-
-                if (zoneMapping.Value.TryGetProperty("onExit", out var onExit))
-                {
-                    ValidateTokenArray(onExit, filePath, $"mappings.{zoneId}.onExit", TokenPhase.OnExit, violations);
-                }
-
-                if (!zoneMapping.Value.TryGetProperty("onEnter", out _) &&
-                    !zoneMapping.Value.TryGetProperty("onExit", out _))
-                {
-                    violations.Add(new Violation
-                    {
-                        FilePath = filePath,
-                        KeyPath = $"mappings.{zoneId}",
-                        Description = "Mapping should define at least one of onEnter/onExit"
-                    });
-                }
-
-                if (zoneMapping.Value.TryGetProperty("onEnter", out var enterTokens) &&
-                    zoneMapping.Value.TryGetProperty("onExit", out var exitTokens) &&
-                    IsArrayEmpty(enterTokens) &&
-                    IsArrayEmpty(exitTokens))
-                {
-                    violations.Add(new Violation
-                    {
-                        FilePath = filePath,
-                        KeyPath = $"mappings.{zoneId}",
-                        Description = "Both onEnter and onExit are empty"
-                    });
-                }
-            }
-        }
-
-        private static bool IsArrayEmpty(JsonElement element)
-        {
-            if (element.ValueKind != JsonValueKind.Array)
-            {
-                return false;
-            }
-
-            return !element.EnumerateArray().Any();
-        }
-
-        private static void ValidateMappingKeys(JsonElement mapping, string filePath, string keyPath, List<Violation> violations)
-        {
-            foreach (var prop in mapping.EnumerateObject())
-            {
-                if (!AllowedMappingKeys.Contains(prop.Name))
-                {
-                    violations.Add(new Violation
-                    {
-                        FilePath = filePath,
-                        KeyPath = $"{keyPath}.{prop.Name}",
-                        Description = $"Unknown mapping key '{prop.Name}'"
-                    });
-                }
-            }
-        }
-
-        private static void ValidateTokenArray(
-            JsonElement array,
-            string filePath,
-            string keyPath,
-            TokenPhase expectedPhase,
-            List<Violation> violations)
-        {
-            if (array.ValueKind != JsonValueKind.Array)
-            {
-                violations.Add(new Violation
-                {
-                    FilePath = filePath,
-                    KeyPath = keyPath,
-                    Description = "Expected an array of tokens"
-                });
-                return;
-            }
-
-            if (!array.EnumerateArray().Any())
-            {
-                violations.Add(new Violation
-                {
-                    FilePath = filePath,
-                    KeyPath = keyPath,
-                    Description = "Token array cannot be empty"
-                });
-                return;
-            }
-
-            var seenCanonicalTokens = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
-
-            var index = 0;
-            foreach (var tokenElement in array.EnumerateArray())
-            {
-                var tokenPath = $"{keyPath}[{index}]";
-                index++;
-
-                if (tokenElement.ValueKind != JsonValueKind.String)
-                {
-                    violations.Add(new Violation
-                    {
-                        FilePath = filePath,
-                        KeyPath = tokenPath,
-                        Description = "Token must be a string"
-                    });
-                    continue;
-                }
-
-                var token = tokenElement.GetString() ?? string.Empty;
-                if (string.IsNullOrWhiteSpace(token))
-                {
-                    violations.Add(new Violation
-                    {
-                        FilePath = filePath,
-                        KeyPath = tokenPath,
-                        Description = "Token cannot be empty"
-                    });
-                    continue;
-                }
-
-                var canonical = LifecycleTokenCatalog.ResolveAlias(token);
-                if (string.IsNullOrWhiteSpace(canonical))
-                {
-                    violations.Add(new Violation
-                    {
-                        FilePath = filePath,
-                        KeyPath = tokenPath,
-                        Description = $"Unknown token '{token}'"
-                    });
-                    continue;
-                }
-
-                if (!string.Equals(token.Trim(), canonical, StringComparison.OrdinalIgnoreCase))
-                {
-                    violations.Add(new Violation
-                    {
-                        FilePath = filePath,
-                        KeyPath = tokenPath,
-                        Description = $"Alias token '{token}' is not allowed in strict mode. Use canonical token '{canonical}'"
-                    });
-                }
-
-                if (!seenCanonicalTokens.Add(canonical))
-                {
-                    violations.Add(new Violation
-                    {
-                        FilePath = filePath,
-                        KeyPath = tokenPath,
-                        Description = $"Duplicate token '{canonical}' in the same token array"
-                    });
-                }
-
-                if (!LifecycleTokenCatalog.TryGet(canonical, out var descriptor))
-                {
-                    violations.Add(new Violation
-                    {
-                        FilePath = filePath,
-                        KeyPath = tokenPath,
-                        Description = $"Unknown token '{token}'"
-                    });
-                    continue;
-                }
-
-                if (descriptor.Phase != expectedPhase)
-                {
-                    violations.Add(new Violation
-                    {
-                        FilePath = filePath,
-                        KeyPath = tokenPath,
-                        Description = $"Token '{descriptor.Name}' is phase {descriptor.Phase}, expected {expectedPhase}"
-                    });
-                }
-            }
-        }
-
-        private static void ValidateOptionalBool(
-            JsonElement root,
-            string key,
-            string filePath,
-            List<Violation> violations,
-            string explicitPath = null)
-        {
-            if (!root.TryGetProperty(key, out var element))
-            {
-                return;
-            }
-
-            if (element.ValueKind is JsonValueKind.True or JsonValueKind.False)
-            {
-                return;
-            }
-
-            violations.Add(new Violation
-            {
-                FilePath = filePath,
-                KeyPath = explicitPath ?? key,
-                Description = "Expected boolean"
-            });
-        }
-
-        private static void ValidateOptionalNumber(JsonElement root, string key, string filePath, List<Violation> violations)
-        {
-            if (!root.TryGetProperty(key, out var element))
-            {
-                return;
-            }
-
-            if (element.ValueKind == JsonValueKind.Number)
-            {
-                return;
-            }
-
-            violations.Add(new Violation
-            {
-                FilePath = filePath,
-                KeyPath = key,
-                Description = "Expected numeric value"
-            });
-        }
-
-        private static void ValidateOptionalIntegerInRange(
-            JsonElement root,
-            string key,
-            int min,
-            int max,
-            string filePath,
-            List<Violation> violations)
-        {
-            if (!root.TryGetProperty(key, out var element))
-            {
-                return;
-            }
-
-            if (element.ValueKind != JsonValueKind.Number || !element.TryGetInt32(out var value))
-            {
-                violations.Add(new Violation
-                {
-                    FilePath = filePath,
-                    KeyPath = key,
-                    Description = $"Expected integer value in range [{min}..{max}]"
-                });
-                return;
-            }
-
-            if (value < min || value > max)
-            {
-                violations.Add(new Violation
-                {
-                    FilePath = filePath,
-                    KeyPath = key,
-                    Description = $"Value {value} is out of range [{min}..{max}]"
-                });
-            }
-        }
-
-        private static void ValidateOptionalNumberInRange(
-            JsonElement root,
-            string key,
-            double min,
-            double max,
-            string filePath,
-            List<Violation> violations)
-        {
-            if (!root.TryGetProperty(key, out var element))
-            {
-                return;
-            }
-
-            if (element.ValueKind != JsonValueKind.Number || !element.TryGetDouble(out var value))
-            {
-                violations.Add(new Violation
-                {
-                    FilePath = filePath,
-                    KeyPath = key,
-                    Description = $"Expected numeric value in range [{min}..{max}]"
-                });
-                return;
-            }
-
-            if (value < min || value > max)
-            {
-                violations.Add(new Violation
-                {
-                    FilePath = filePath,
-                    KeyPath = key,
-                    Description = $"Value {value} is out of range [{min}..{max}]"
-                });
-            }
-        }
-    }
-}
diff --git a/CycleBorn/Cycleborn.lifecycle.json b/CycleBorn/Cycleborn.lifecycle.json
deleted file mode 100644
index 8d21dfa..0000000
--- a/CycleBorn/Cycleborn.lifecycle.json
+++ /dev/null
@@ -1,36 +0,0 @@
-{
-    "strictMigrationEnabled": false,
-    "enabled": true,
-    "checkIntervalMs": 100,
-    "positionChangeThreshold": 1.0,
-    "mapIconSpawnRefreshIntervalSeconds": 10.0,
-    "mappings": {
-        "*": {
-            "onEnter": [
-                "capture_return_position",
-                "snapshot_save",
-                "zone_enter_message",
-                "apply_kit",
-                "teleport_enter",
-                "apply_templates",
-                "apply_abilities",
-                "glow_spawn",
-                "boss_enter",
-                "integration_events_enter",
-                "announce_enter"
-            ],
-            "onExit": [
-                "zone_exit_message",
-                "restore_kit_snapshot",
-                "restore_abilities",
-                "boss_exit",
-                "player_tag",
-                "teleport_return",
-                "glow_reset",
-                "integration_events_exit"
-            ],
-            "useGlobalDefaults": false,
-            "mapIconChangePrefab": ""
-        }
-    }
-}
diff --git a/CycleBorn/Lifecycle/LifecycleRegistry.cs b/CycleBorn/Lifecycle/LifecycleRegistry.cs
deleted file mode 100644
index 508263e..0000000
--- a/CycleBorn/Lifecycle/LifecycleRegistry.cs
+++ /dev/null
@@ -1,172 +0,0 @@
-using System;
-using System.Collections.Generic;
-
-namespace VLifecycle
-{
-    /// <summary>
-    /// Lifecycle context passed to handlers
-    /// </summary>
-    public class LifecycleContext
-    {
-        public ulong PlatformId { get; set; }
-        public Unity.Entities.Entity Player { get; set; }
-        public Unity.Entities.Entity Character { get; set; }
-        public string ZoneId { get; set; }
-        public Unity.Mathematics.float3 Position { get; set; }
-        public Dictionary<string, object> Data { get; set; } = new();
-    }
-
-    /// <summary>
-    /// Interface for domain lifecycle handlers
-    /// </summary>
-    public interface IDomainLifecycleHandler
-    {
-        void OnEnter(LifecycleContext context);
-        void OnExit(LifecycleContext context);
-    }
-
-    /// <summary>
-    /// Lifecycle registry - maps domain tokens to handlers.
-    /// Bluelock registers its handlers here.
-    /// </summary>
-    public sealed class LifecycleRegistry
-    {
-        private static LifecycleRegistry _instance;
-        private static readonly object _lock = new object();
-
-        private readonly Dictionary<string, IDomainLifecycleHandler> _handlers = new(StringComparer.OrdinalIgnoreCase);
-        private bool _isSealed;
-
-        /// <summary>
-        /// Singleton instance
-        /// </summary>
-        public static LifecycleRegistry Instance
-        {
-            get
-            {
-                if (_instance == null)
-                {
-                    lock (_lock)
-                    {
-                        _instance ??= new LifecycleRegistry();
-                    }
-                }
-                return _instance;
-            }
-        }
-
-        /// <summary>
-        /// Register a domain token handler
-        /// </summary>
-        public void Register(string token, IDomainLifecycleHandler handler)
-        {
-            if (_isSealed)
-            {
-                throw new InvalidOperationException("LifecycleRegistry is sealed. Cannot register new handlers after startup.");
-            }
-
-            if (string.IsNullOrWhiteSpace(token))
-            {
-                throw new ArgumentException("Token cannot be empty", nameof(token));
-            }
-
-            var resolved = LifecycleTokenCatalog.ResolveAlias(token);
-            _handlers[resolved] = handler;
-        }
-
-        /// <summary>
-        /// Try to get handler for token
-        /// </summary>
-        public bool TryGet(string token, out IDomainLifecycleHandler handler)
-        {
-            if (string.IsNullOrWhiteSpace(token))
-            {
-                handler = null;
-                return false;
-            }
-
-            var resolved = LifecycleTokenCatalog.ResolveAlias(token);
-            return _handlers.TryGetValue(resolved, out handler);
-        }
-
-        /// <summary>
-        /// Execute handler for token on enter
-        /// </summary>
-        public bool ExecuteEnter(string token, LifecycleContext context)
-        {
-            if (TryGet(token, out var handler))
-            {
-                handler.OnEnter(context);
-                return true;
-            }
-            return false;
-        }
-
-        /// <summary>
-        /// Execute handler for token on exit
-        /// </summary>
-        public bool ExecuteExit(string token, LifecycleContext context)
-        {
-            if (TryGet(token, out var handler))
-            {
-                handler.OnExit(context);
-                return true;
-            }
-            return false;
-        }
-
-        /// <summary>
-        /// Seal the registry - no more registrations allowed
-        /// </summary>
-        public void Seal()
-        {
-            _isSealed = true;
-        }
-
-        /// <summary>
-        /// Check if registry is sealed
-        /// </summary>
-        public bool IsSealed => _isSealed;
-
-        /// <summary>
-        /// Get all registered tokens
-        /// </summary>
-        public IEnumerable<string> GetRegisteredTokens()
-        {
-            return _handlers.Keys;
-        }
-
-        /// <summary>
-        /// Clear registry (for testing)
-        /// </summary>
-        public void Clear()
-        {
-            if (!_isSealed)
-            {
-                _handlers.Clear();
-            }
-        }
-    }
-
-    /// <summary>
-    /// Static accessor for convenience
-    /// </summary>
-    public static class Lifecycle
-    {
-        /// <summary>
-        /// Shorthand for LifecycleRegistry.Instance.Register
-        /// </summary>
-        public static void Register(string token, IDomainLifecycleHandler handler)
-        {
-            LifecycleRegistry.Instance.Register(token, handler);
-        }
-
-        /// <summary>
-        /// Shorthand for LifecycleRegistry.Instance.TryGet
-        /// </summary>
-        public static bool TryGetHandler(string token, out IDomainLifecycleHandler handler)
-        {
-            return LifecycleRegistry.Instance.TryGet(token, out handler);
-        }
-    }
-}
diff --git a/CycleBorn/Lifecycle/LifecycleTokenCatalog.cs b/CycleBorn/Lifecycle/LifecycleTokenCatalog.cs
deleted file mode 100644
index 5edd4dd..0000000
--- a/CycleBorn/Lifecycle/LifecycleTokenCatalog.cs
+++ /dev/null
@@ -1,341 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Linq;
-
-namespace VLifecycle
-{
-    /// <summary>
-    /// Token ownership classification
-    /// </summary>
-    public enum TokenOwner
-    {
-        /// <summary>Orchestration tokens owned by CycleBorn</summary>
-        Orchestration,
-        
-        /// <summary>Domain tokens owned by Bluelock</summary>
-        Domain
-    }
-
-    /// <summary>
-    /// Token phase (when it executes)
-    /// </summary>
-    public enum TokenPhase
-    {
-        /// <summary>Executes on zone enter</summary>
-        OnEnter,
-        
-        /// <summary>Executes on zone exit</summary>
-        OnExit
-    }
-
-    /// <summary>
-    /// Token descriptor with metadata
-    /// </summary>
-    public sealed class TokenDescriptor
-    {
-        public string Name { get; }
-        public TokenOwner Owner { get; }
-        public TokenPhase Phase { get; }
-        public string Description { get; }
-
-        public TokenDescriptor(string name, TokenOwner owner, TokenPhase phase, string description = "")
-        {
-            Name = name;
-            Owner = owner;
-            Phase = phase;
-            Description = description;
-        }
-    }
-
-    /// <summary>
-    /// Canonical lifecycle token catalog.
-    /// Single source of truth for all lifecycle action tokens.
-    /// </summary>
-    public static class LifecycleTokenCatalog
-    {
-        private static readonly Dictionary<string, TokenDescriptor> _tokens;
-
-        static LifecycleTokenCatalog()
-        {
-            _tokens = new Dictionary<string, TokenDescriptor>(StringComparer.OrdinalIgnoreCase)
-            {
-                // ==================== ORCHESTRATION TOKENS ====================
-                
-                // Position management
-                ["capture_return_position"] = new TokenDescriptor(
-                    "capture_return_position", TokenOwner.Orchestration, TokenPhase.OnEnter,
-                    "Stores player position for return teleport on exit"),
-
-                // State management
-                ["snapshot_save"] = new TokenDescriptor(
-                    "snapshot_save", TokenOwner.Orchestration, TokenPhase.OnEnter,
-                    "Saves player state for restoration"),
-
-                ["snapshot_restore"] = new TokenDescriptor(
-                    "snapshot_restore", TokenOwner.Orchestration, TokenPhase.OnExit,
-                    "Restores previously saved player state"),
-
-                // Messaging
-                ["zone_enter_message"] = new TokenDescriptor(
-                    "zone_enter_message", TokenOwner.Orchestration, TokenPhase.OnEnter,
-                    "Displays system message on zone enter"),
-
-                ["zone_exit_message"] = new TokenDescriptor(
-                    "zone_exit_message", TokenOwner.Orchestration, TokenPhase.OnExit,
-                    "Displays system message on zone exit"),
-
-                // Teleport
-                ["teleport_enter"] = new TokenDescriptor(
-                    "teleport_enter", TokenOwner.Orchestration, TokenPhase.OnEnter,
-                    "Teleports player to zone spawn point"),
-
-                ["teleport_return"] = new TokenDescriptor(
-                    "teleport_return", TokenOwner.Orchestration, TokenPhase.OnExit,
-                    "Returns player to captured position"),
-
-                // Tagging
-                ["player_tag"] = new TokenDescriptor(
-                    "player_tag", TokenOwner.Orchestration, TokenPhase.OnEnter,
-                    "Adds zone identifier to player name"),
-
-                // Integration
-                ["integration_events_enter"] = new TokenDescriptor(
-                    "integration_events_enter", TokenOwner.Orchestration, TokenPhase.OnEnter,
-                    "Fires enter events to external systems"),
-
-                ["integration_events_exit"] = new TokenDescriptor(
-                    "integration_events_exit", TokenOwner.Orchestration, TokenPhase.OnExit,
-                    "Fires exit events to external systems"),
-
-                // Announcements
-                ["announce_enter"] = new TokenDescriptor(
-                    "announce_enter", TokenOwner.Orchestration, TokenPhase.OnEnter,
-                    "Broadcasts zone enter announcement"),
-
-                // ==================== DOMAIN TOKENS ====================
-
-                // Kit management
-                ["apply_kit"] = new TokenDescriptor(
-                    "apply_kit", TokenOwner.Domain, TokenPhase.OnEnter,
-                    "Applies kit loadout to player"),
-
-                ["restore_kit_snapshot"] = new TokenDescriptor(
-                    "restore_kit_snapshot", TokenOwner.Domain, TokenPhase.OnExit,
-                    "Restores previous kit on exit"),
-
-                // Template management
-                ["apply_templates"] = new TokenDescriptor(
-                    "apply_templates", TokenOwner.Domain, TokenPhase.OnEnter,
-                    "Applies building templates"),
-
-                // Ability management
-                ["apply_abilities"] = new TokenDescriptor(
-                    "apply_abilities", TokenOwner.Domain, TokenPhase.OnEnter,
-                    "Applies ability preset slots"),
-
-                ["restore_abilities"] = new TokenDescriptor(
-                    "restore_abilities", TokenOwner.Domain, TokenPhase.OnExit,
-                    "Restores previous ability slots"),
-
-                // Boss management
-                ["boss_enter"] = new TokenDescriptor(
-                    "boss_enter", TokenOwner.Domain, TokenPhase.OnEnter,
-                    "Handles boss spawn/engagement"),
-
-                ["boss_exit"] = new TokenDescriptor(
-                    "boss_exit", TokenOwner.Domain, TokenPhase.OnExit,
-                    "Handles boss despawn/disengage"),
-
-                // Glow/Border management
-                ["glow_spawn"] = new TokenDescriptor(
-                    "glow_spawn", TokenOwner.Domain, TokenPhase.OnEnter,
-                    "Spawns glow tiles/borders"),
-
-                ["glow_reset"] = new TokenDescriptor(
-                    "glow_reset", TokenOwner.Domain, TokenPhase.OnExit,
-                    "Clears glow tiles/borders"),
-
-                // Spellbook
-                ["spellbookgrant"] = new TokenDescriptor(
-                    "spellbookgrant", TokenOwner.Domain, TokenPhase.OnEnter,
-                    "Grants spellbook"),
-
-                ["spellbookrestore"] = new TokenDescriptor(
-                    "spellbookrestore", TokenOwner.Domain, TokenPhase.OnExit,
-                    "Restores previous spellbook"),
-
-                // VBlood
-                ["vbloodunlock"] = new TokenDescriptor(
-                    "vbloodunlock", TokenOwner.Domain, TokenPhase.OnEnter,
-                    "Unlocks VBlood"),
-
-                // Arena lifecycle
-                ["arena_start"] = new TokenDescriptor(
-                    "arena_start", TokenOwner.Domain, TokenPhase.OnEnter,
-                    "Starts arena runtime flow"),
-
-                ["arena_end"] = new TokenDescriptor(
-                    "arena_end", TokenOwner.Domain, TokenPhase.OnExit,
-                    "Ends arena runtime flow"),
-
-                ["arena_respawn"] = new TokenDescriptor(
-                    "arena_respawn", TokenOwner.Domain, TokenPhase.OnEnter,
-                    "Handles arena respawn policy"),
-
-                // Coop lifecycle
-                ["coop_start"] = new TokenDescriptor(
-                    "coop_start", TokenOwner.Domain, TokenPhase.OnEnter,
-                    "Starts co-op dungeon instance"),
-
-                ["coop_progress"] = new TokenDescriptor(
-                    "coop_progress", TokenOwner.Domain, TokenPhase.OnEnter,
-                    "Advances co-op dungeon tier"),
-
-                ["coop_final"] = new TokenDescriptor(
-                    "coop_final", TokenOwner.Domain, TokenPhase.OnEnter,
-                    "Triggers co-op final boss flow"),
-
-                ["coop_exit"] = new TokenDescriptor(
-                    "coop_exit", TokenOwner.Domain, TokenPhase.OnExit,
-                    "Handles co-op dungeon exit/cleanup"),
-
-                // Raid lifecycle
-                ["raid_start"] = new TokenDescriptor(
-                    "raid_start", TokenOwner.Domain, TokenPhase.OnEnter,
-                    "Starts raid instance"),
-
-                ["raid_phase"] = new TokenDescriptor(
-                    "raid_phase", TokenOwner.Domain, TokenPhase.OnEnter,
-                    "Advances raid phase"),
-
-                ["raid_end"] = new TokenDescriptor(
-                    "raid_end", TokenOwner.Domain, TokenPhase.OnExit,
-                    "Ends raid instance"),
-
-                // Boss arena lifecycle
-                ["bossarena_start"] = new TokenDescriptor(
-                    "bossarena_start", TokenOwner.Domain, TokenPhase.OnEnter,
-                    "Starts boss arena sequence"),
-
-                ["bossarena_end"] = new TokenDescriptor(
-                    "bossarena_end", TokenOwner.Domain, TokenPhase.OnExit,
-                    "Ends boss arena sequence"),
-
-                // PvP glow-corner lifecycle
-                ["glowcorners_show"] = new TokenDescriptor(
-                    "glowcorners_show", TokenOwner.Domain, TokenPhase.OnEnter,
-                    "Shows PvP glow corner indicators"),
-
-                ["glowcorners_hide"] = new TokenDescriptor(
-                    "glowcorners_hide", TokenOwner.Domain, TokenPhase.OnExit,
-                    "Hides PvP glow corner indicators")
-            };
-        }
-
-        /// <summary>
-        /// Try to get token descriptor
-        /// </summary>
-        public static bool TryGet(string token, out TokenDescriptor descriptor)
-        {
-            if (string.IsNullOrWhiteSpace(token))
-            {
-                descriptor = null;
-                return false;
-            }
-
-            // Resolve alias
-            var resolved = ResolveAlias(token);
-            return _tokens.TryGetValue(resolved, out descriptor);
-        }
-
-        /// <summary>
-        /// Check if token is valid
-        /// </summary>
-        public static bool IsValid(string token)
-        {
-            if (string.IsNullOrWhiteSpace(token)) return false;
-            var resolved = ResolveAlias(token);
-            return _tokens.ContainsKey(resolved);
-        }
-
-        /// <summary>
-        /// Get owner of token
-        /// </summary>
-        public static TokenOwner? GetOwner(string token)
-        {
-            if (TryGet(token, out var descriptor))
-            {
-                return descriptor.Owner;
-            }
-            return null;
-        }
-
-        /// <summary>
-        /// Get phase of token
-        /// </summary>
-        public static TokenPhase? GetPhase(string token)
-        {
-            if (TryGet(token, out var descriptor))
-            {
-                return descriptor.Phase;
-            }
-            return null;
-        }
-
-        /// <summary>
-        /// Get all orchestration tokens
-        /// </summary>
-        public static IEnumerable<string> GetOrchestrationTokens()
-        {
-            return _tokens.Where(kvp => kvp.Value.Owner == TokenOwner.Orchestration)
-                         .Select(kvp => kvp.Key);
-        }
-
-        /// <summary>
-        /// Get all domain tokens
-        /// </summary>
-        public static IEnumerable<string> GetDomainTokens()
-        {
-            return _tokens.Where(kvp => kvp.Value.Owner == TokenOwner.Domain)
-                         .Select(kvp => kvp.Key);
-        }
-
-        /// <summary>
-        /// Token aliases for backward compatibility
-        /// </summary>
-        private static readonly Dictionary<string, string> _aliases = new(StringComparer.OrdinalIgnoreCase)
-        {
-            ["store"] = "snapshot_save",
-            ["snapshot"] = "snapshot_save",
-            ["save"] = "snapshot_save",
-            ["restore_snapshot"] = "snapshot_restore",
-            ["message"] = "zone_enter_message",
-            ["teleport"] = "teleport_enter",
-            ["templates"] = "apply_templates",
-            ["abilities"] = "apply_abilities",
-            ["ability"] = "apply_abilities",
-            ["kit"] = "apply_kit",
-            ["kit_apply"] = "apply_kit",
-            ["restore"] = "restore_kit_snapshot",
-            ["glow"] = "glow_spawn",
-            ["integration"] = "integration_events_enter",
-            ["announce"] = "announce_enter"
-        };
-
-        /// <summary>
-        /// Resolve token alias to canonical token
-        /// </summary>
-        public static string ResolveAlias(string token)
-        {
-            if (string.IsNullOrWhiteSpace(token))
-                return string.Empty;
-
-            var normalized = token.Trim().ToLowerInvariant();
-            
-            if (_aliases.TryGetValue(normalized, out var canonical))
-                return canonical;
-
-            return _tokens.ContainsKey(normalized) ? normalized : string.Empty;
-        }
-    }
-}
diff --git a/CycleBorn/MyPluginInfo.cs b/CycleBorn/MyPluginInfo.cs
index 7dca42c..453a231 100644
--- a/CycleBorn/MyPluginInfo.cs
+++ b/CycleBorn/MyPluginInfo.cs
@@ -1,20 +1,18 @@
-using VAuto;
-
 namespace VAuto
 {
     //do not change this
     public static class MyPluginInfo
     {
-        public const string GUID = "gg.coyote.Cycleborn";
-        public const string NAME = "Circleborn";
-        public const string VERSION = "1.0.1";
+        public const string GUID = "gg.coyote.lifecycle";
+        public const string NAME = "lifecycle";
+        public const string VERSION = "1.0.0";
 
         public static class Vlifecycle
         {
-            public const string Name = "Cycleborn";
-            public const string Version = "1.0.1";
+            public const string Name = "Vlifecycle";
+            public const string Version = "1.0.0";
             public const bool EnableHarmony = true;
-            public const string HarmonyId = "gg.coyote.Cycleborn";
+            public const string HarmonyId = "gg.coyote.Lifecycle";
         }
     }
 }
diff --git a/CycleBorn/Plugin.cs b/CycleBorn/Plugin.cs
index f958fce..f45729d 100644
--- a/CycleBorn/Plugin.cs
+++ b/CycleBorn/Plugin.cs
@@ -146,8 +146,6 @@ namespace VLifecycle
                 CoreLog.Info("Commands registered");
                 LogStartupSummary();
 
-                // Lifecycle orchestration is handled by token registry + domain handlers.
-
                 if (MyPluginInfo.Vlifecycle.EnableHarmony)
                 {
                     _harmony = new Harmony(MyPluginInfo.Vlifecycle.HarmonyId);
@@ -338,6 +336,7 @@ namespace VLifecycle
                 _hotReloadTimer = null;
                 _harmony?.UnpatchSelf();
                 _harmony = null;
+                // ArenaLifecycleManager.Instance.Shutdown(); // Excluded from headless builds
                 Log.LogInfo("[VLifecycle] Unloaded.");
                 return true;
             }
diff --git a/CycleBorn/Services/Lifecycle/ArenaLifecycleManager.cs b/CycleBorn/Services/Lifecycle/ArenaLifecycleManager.cs
new file mode 100644
index 0000000..c3aa52c
--- /dev/null
+++ b/CycleBorn/Services/Lifecycle/ArenaLifecycleManager.cs
@@ -0,0 +1,667 @@
+﻿using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using BepInEx.Logging;
+using ProjectM;
+using Unity.Collections;
+using Unity.Entities;
+using Unity.Mathematics;
+using VAutomationCore.Core;
+using VAutomationCore.Core.TrapLifecycle;
+using VAutomationCore.Core.Data;
+using VAutomationCore.Core.Services;
+using VAuto.Core.Patterns;
+using VAuto.Core.Lifecycle.Data.DataType;
+
+namespace VAuto.Core.Lifecycle
+{
+    /// <summary>
+    /// Arena Lifecycle Manager - Handles lifecycle events for arena zones 
+    /// This class is loaded by VAutoZone, intending to make it handle all future events triggering 
+    /// </summary>
+    public class ArenaLifecycleManager : Singleton<ArenaLifecycleManager>
+    {
+        private static readonly string _logPrefix = "[ArenaLifecycleManager]";
+        
+        // Lifecycle stages for arena
+        private readonly Dictionary<string, LifecycleStage> _lifecycleStages;
+        private readonly Dictionary<string, LifecycleActionHandler> _actionHandlers;
+        
+        public ManualLogSource Log { get; private set; }
+        public new bool IsInitialized { get; private set; }
+        public int ServiceCount => _lifecycleStages.Count;
+
+        // Debounce recent transitions: key=(user, arenaId, direction)
+        private readonly Dictionary<string, long> _recentTransitions = new Dictionary<string, long>();
+        private const int DebounceWindowMs = 1000;
+
+        // ECS Tracking
+        private ZoneTrackingHelper _zoneTrackingHelper;
+        private bool _ecsTrackingEnabled;
+        private float _lastUpdateTime;
+        private readonly float _updateInterval = 0.1f; // 10 updates per second
+
+        // Trap lifecycle policy integration
+        private ITrapLifecyclePolicy _trapLifecyclePolicy;
+        private bool _trapPolicyEnabled;
+
+        public ArenaLifecycleManager()
+        {
+            Log = VLifecycle.Plugin.Log;
+            _lifecycleStages = new Dictionary<string, LifecycleStage>();
+            _actionHandlers = new Dictionary<string, LifecycleActionHandler>();
+            InitializeActionHandlers();
+        }
+
+        /// <summary>
+        /// Initialize the arena lifecycle manager
+        /// </summary>
+        public void Initialize()
+        {
+            try
+            {
+                if (IsInitialized) return;
+                
+                RegisterLifecycleStages();
+                InitializeTrapPolicy();
+                IsInitialized = true;
+                Log?.LogInfo($"{_logPrefix} Initialized");
+            }
+            catch (Exception ex)
+            {
+                Log?.LogError($"{_logPrefix} Failed to initialize: {ex.Message}");
+            }
+        }
+
+        /// <summary>
+        /// Initialize trap lifecycle policy if VAutoTraps is available and overrides are enabled.
+        /// </summary>
+        private void InitializeTrapPolicy()
+        {
+            try
+            {
+                _trapPolicyEnabled = VLifecycle.Plugin.AllowTrapOverrides;
+                
+                // Check if VAutoTraps has registered its policy
+                if (_trapPolicyEnabled && TrapPolicyResolver.AreOverridesEnabled())
+                {
+                    _trapLifecyclePolicy = new DefaultTrapLifecyclePolicy();
+                    Log?.LogInfo($"{_logPrefix} Trap lifecycle policy enabled (using shared resolver)");
+                }
+                else
+                {
+                    _trapLifecyclePolicy = null;
+                    Log?.LogDebug($"{_logPrefix} Trap lifecycle policy disabled (config or resolver unavailable)");
+                }
+            }
+            catch (Exception ex)
+            {
+                Log?.LogWarning($"{_logPrefix} Failed to initialize trap policy: {ex.Message}");
+                _trapPolicyEnabled = false;
+            }
+        }
+
+        /// <summary>
+        /// Enable ECS-based zone tracking for autonomous detection.
+        /// </summary>
+        public void EnableECSTracking()
+        {
+            if (_ecsTrackingEnabled) return;
+            
+            try
+            {
+                _zoneTrackingHelper = new ZoneTrackingHelper(VAutomationCore.Core.UnifiedCore.EntityManager, new CoreLogger("ZoneTracking"));
+                _zoneTrackingHelper.Initialize();
+                
+                // Subscribe to zone transition events
+                _zoneTrackingHelper.OnPlayerEnterLifecycleZone += OnPlayerEnterLifecycleZoneHandler;
+                _zoneTrackingHelper.OnPlayerExitLifecycleZone += OnPlayerExitLifecycleZoneHandler;
+                
+                _ecsTrackingEnabled = true;
+                Log?.LogInfo($"{_logPrefix} ECS zone tracking enabled");
+            }
+            catch (Exception ex)
+            {
+                Log?.LogError($"{_logPrefix} Failed to enable ECS tracking: {ex.Message}");
+            }
+        }
+
+        /// <summary>
+        /// Disable ECS-based zone tracking.
+        /// </summary>
+        public void DisableECSTracking()
+        {
+            if (!_ecsTrackingEnabled) return;
+            
+            if (_zoneTrackingHelper != null)
+            {
+                _zoneTrackingHelper.OnPlayerEnterLifecycleZone -= OnPlayerEnterLifecycleZoneHandler;
+                _zoneTrackingHelper.OnPlayerExitLifecycleZone -= OnPlayerExitLifecycleZoneHandler;
+                _zoneTrackingHelper.Dispose();
+                _zoneTrackingHelper = null;
+            }
+            
+            _ecsTrackingEnabled = false;
+            Log?.LogInfo($"{_logPrefix} ECS zone tracking disabled");
+        }
+
+        /// <summary>
+        /// ECS update loop - called every frame for autonomous zone detection.
+        /// </summary>
+        public void UpdateECS(double currentTime)
+        {
+            if (!_ecsTrackingEnabled) return;
+            
+            // Throttle updates to reduce CPU usage
+            if (currentTime - _lastUpdateTime < _updateInterval) return;
+            _lastUpdateTime = currentTime;
+            
+            try
+            {
+                _zoneTrackingHelper?.UpdateTracking();
+            }
+            catch (Exception ex)
+            {
+                Log?.LogError($"{_logPrefix} ECS update failed: {ex.Message}");
+            }
+        }
+
+        /// <summary>
+        /// Register a zone for ECS tracking.
+        /// </summary>
+        public void RegisterZoneForTracking(Entity zoneEntity, float3 center, float radius, string zoneId, bool isLifecycleZone)
+        {
+            _zoneTrackingHelper?.RegisterZone(zoneEntity, center, radius, zoneId, isLifecycleZone);
+        }
+
+        private void OnPlayerEnterLifecycleZoneHandler(Entity player, Entity zone)
+        {
+            Log?.LogInfo($"{_logPrefix} Player {player} entered lifecycle zone {zone}");
+            
+            // Trigger enter lifecycle actions
+            TriggerLifecycleStage("onEnterLifecycleZone", new LifecycleContext
+            {
+                CharacterEntity = player,
+                Position = _zoneTrackingHelper?.GetPlayerPosition(player) ?? default
+            });
+        }
+
+        private void OnPlayerExitLifecycleZoneHandler(Entity player, Entity zone)
+        {
+            Log?.LogInfo($"{_logPrefix} Player {player} exited lifecycle zone {zone}");
+            
+            // Trigger exit lifecycle actions
+            TriggerLifecycleStage("onExitLifecycleZone", new LifecycleContext
+            {
+                CharacterEntity = player,
+                Position = _zoneTrackingHelper?.GetPlayerPosition(player) ?? default
+            });
+        }
+
+        /// <summary>
+        /// Shutdown the arena lifecycle manager
+        /// </summary>
+        public void Shutdown()
+        {
+            if (!IsInitialized) return;
+            
+            DisableECSTracking();
+            _lifecycleStages.Clear();
+            _actionHandlers.Clear();
+            IsInitialized = false;
+            Log?.LogInfo($"{_logPrefix} Shutdown");
+        }
+
+        /// <summary>
+        /// Trigger a lifecycle stage when entering arena
+        /// </summary>
+        public bool OnEnterArena(Entity character, float3 position)
+        {
+            return TriggerLifecycleStage("onEnterArenaZone", new LifecycleContext
+            {
+                CharacterEntity = character,
+                Position = position
+            });
+        }
+
+        /// <summary>
+        /// Trigger a lifecycle stage when exiting arena
+        /// </summary>
+        public bool OnExitArena(Entity character, float3 position)
+        {
+            return TriggerLifecycleStage("onExitArenaZone", new LifecycleContext
+            {
+                CharacterEntity = character,
+                Position = position
+            });
+        }
+
+        /// <summary>
+        /// Called by VAutoZone when player enters arena (via reflection) - preserves position
+        /// </summary>
+        public bool OnPlayerEnter(Entity userEntity, Entity characterEntity, string arenaId, float3 position)
+        {
+            if (ShouldDebounce(userEntity, arenaId, "Enter"))
+            {
+                Log?.LogInfo($"{_logPrefix} Debounced Enter for user={userEntity.Index} arena={arenaId}");
+                return false;
+            }
+            
+            // Check trap lifecycle policy via shared resolver
+            if (_trapLifecyclePolicy != null && _trapPolicyEnabled)
+            {
+                var characterId = GetCharacterId(characterEntity);
+                var decision = TrapPolicyResolver.EvaluateEnter(new TrapLifecycleContext
+                {
+                    CharacterId = characterId,
+                    ZoneId = arenaId,
+                    Position = position,
+                    LifecycleStage = "Enter"
+                });
+                
+                if (decision.OverrideTriggered)
+                {
+                    Log?.LogInfo($"{_logPrefix} Trap policy override on enter: {decision.Reason}");
+                    // Continue with lifecycle but may be modified by policy
+                }
+            }
+            
+            Log?.LogInfo($"{_logPrefix} Player entering arena {arenaId} at position ({position.x:F0}, {position.y:F0}, {position.z:F0})");
+            ApplyDefaults(characterEntity);
+            return OnEnterArena(characterEntity, position);
+        }
+
+        private void ApplyDefaults(Entity characterEntity)
+        {
+            try
+            {
+                var em = UnifiedCore.EntityManager;
+                if (!em.Exists(characterEntity))
+                {
+                    return;
+                }
+
+                if (PrefabsAll.ByName.TryGetValue(Default.BloodType, out var bloodGuid))
+                {
+                    if (!GameActionService.HasBuff(characterEntity, bloodGuid))
+                    {
+                        GameActionService.TryApplyCleanBuff(characterEntity, bloodGuid, -1f);
+                    }
+                }
+            }
+            catch
+            {
+                // defaults are best-effort; ignore errors
+            }
+        }
+
+        /// <summary>
+        /// Called by VAutoZone when player exits arena (via reflection) - preserves position
+        /// </summary>
+        public bool OnPlayerExit(Entity userEntity, Entity characterEntity, string arenaId, float3 position)
+        {
+            if (ShouldDebounce(userEntity, arenaId, "Exit"))
+            {
+                Log?.LogInfo($"{_logPrefix} Debounced Exit for user={userEntity.Index} arena={arenaId}");
+                return false;
+            }
+            
+            // Check trap lifecycle policy via shared resolver
+            if (_trapLifecyclePolicy != null && _trapPolicyEnabled)
+            {
+                var characterId = GetCharacterId(characterEntity);
+                var decision = TrapPolicyResolver.EvaluateExit(new TrapLifecycleContext
+                {
+                    CharacterId = characterId,
+                    ZoneId = arenaId,
+                    Position = position,
+                    LifecycleStage = "Exit"
+                });
+                
+                if (decision.ForceBuffClearOnExit)
+                {
+                    Log?.LogInfo($"{_logPrefix} Trap policy force buff clear on exit: {decision.Reason}");
+                    // Add buff clear action to exit stage
+                }
+            }
+            
+            Log?.LogInfo($"{_logPrefix} Player exiting arena {arenaId} from position ({position.x:F0}, {position.y:F0}, {position.z:F0})");
+            return OnExitArena(characterEntity, position);
+        }
+
+        /// <summary>
+        /// Get character ID from character entity.
+        /// </summary>
+        private ulong GetCharacterId(Entity characterEntity)
+        {
+            try
+            {
+                var em = VAutomationCore.Core.UnifiedCore.EntityManager;
+                if (em.Exists(characterEntity) && em.HasComponent<ProjectM.PlayerCharacter>(characterEntity))
+                {
+                    var pc = em.GetComponentData<ProjectM.PlayerCharacter>(characterEntity);
+                    var userEntity = pc.UserEntity;
+                    if (em.Exists(userEntity) && em.HasComponent<ProjectM.Network.User>(userEntity))
+                    {
+                        var user = em.GetComponentData<ProjectM.Network.User>(userEntity);
+                        return user.PlatformId;
+                    }
+                }
+                return 0;
+            }
+            catch
+            {
+                return 0;
+            }
+        }
+
+        /// <summary>
+        /// Handle player connection to server
+        /// </summary>
+        public void OnPlayerConnected(int userIndex)
+        {
+            Log?.LogInfo($"{_logPrefix} Player connected: {userIndex}");
+            // Initialize any server-level player state if needed
+        }
+
+        /// <summary>
+        /// Handle player disconnection from server
+        /// </summary>
+        public void OnPlayerDisconnected(int userIndex)
+        {
+            Log?.LogInfo($"{_logPrefix} Player disconnected: {userIndex}");
+            // Clean up any server-level player state if needed
+        }
+
+        /// <summary>
+        /// Trigger a lifecycle stage
+        /// </summary>
+        public bool TriggerLifecycleStage(string stageName, LifecycleContext context)
+        {
+            try
+            {
+                if (!_lifecycleStages.TryGetValue(stageName, out var stage))
+                {
+                    Log?.LogWarning($"{_logPrefix} Unknown lifecycle stage: {stageName}");
+                    return false;
+                }
+
+                bool allSuccessful = true;
+                foreach (var action in stage.Actions)
+                {
+                    if (!ExecuteAction(action, context))
+                    {
+                        allSuccessful = false;
+                    }
+                }
+
+                return allSuccessful;
+            }
+            catch (Exception ex)
+            {
+                Log?.LogError($"{_logPrefix} Failed to trigger stage {stageName}: {ex.Message}");
+                return false;
+            }
+        }
+
+        /// <summary>
+        /// Execute a single lifecycle action
+        /// </summary>
+        private bool ExecuteAction(LifecycleAction action, LifecycleContext context)
+        {
+            try
+            {
+                if (!_actionHandlers.TryGetValue(action.Type, out var handler))
+                {
+                    Log?.LogWarning($"{_logPrefix} No handler for action type: {action.Type}");
+                    return false;
+                }
+
+                return handler.Execute(action, context);
+            }
+            catch (Exception ex)
+            {
+                Log?.LogError($"{_logPrefix} Failed to execute action: {ex.Message}");
+                return false;
+            }
+        }
+
+        /// <summary>
+        /// Get list of service names
+        /// </summary>
+        public string[] GetServiceNames()
+        {
+            return _lifecycleStages.Keys.ToArray();
+        }
+
+        /// <summary>
+        /// Register default lifecycle stages
+        /// </summary>
+        private void RegisterLifecycleStages()
+        {
+            _lifecycleStages["onEnterArenaZone"] = new LifecycleStage
+            {
+                Name = "onEnterArenaZone",
+                Description = "Triggered when player enters arena",
+                Actions = new List<LifecycleAction>
+                {
+                    new LifecycleAction { Type = "save" },
+                    new LifecycleAction { Type = "resetcooldowns" },
+                    new LifecycleAction { Type = "message", Message = "Entering Arena Zone..." }
+                }
+            };
+
+            _lifecycleStages["onExitArenaZone"] = new LifecycleStage
+            {
+                Name = "onExitArenaZone",
+                Description = "Triggered when player exits arena",
+                Actions = new List<LifecycleAction>
+                {
+                    new LifecycleAction { Type = "restore" },
+                    new LifecycleAction { Type = "clearbuffs" },
+                    new LifecycleAction { Type = "message", Message = "Exiting Arena Zone..." }
+                }
+            };
+
+            // Phase 2-3: Spellbook lifecycle stages
+            _lifecycleStages["onEnterLifecycleZone"] = new LifecycleStage
+            {
+                Name = "onEnterLifecycleZone",
+                Description = "Triggered when player enters any lifecycle zone",
+                Actions = new List<LifecycleAction>
+                {
+                    new LifecycleAction { Type = "spellbookgrant" },
+                    new LifecycleAction { Type = "vbloodunlock" }
+                }
+            };
+
+            _lifecycleStages["onExitLifecycleZone"] = new LifecycleStage
+            {
+                Name = "onExitLifecycleZone",
+                Description = "Triggered when player exits any lifecycle zone",
+                Actions = new List<LifecycleAction>
+                {
+                    new LifecycleAction { Type = "spellbookrestore" }
+                }
+            };
+        }
+
+        /// <summary>
+        /// Initialize action handlers
+        /// </summary>
+        private void InitializeActionHandlers()
+        {
+            _actionHandlers["store"] = new StoreActionHandler();
+            _actionHandlers["message"] = new MessageActionHandler();
+            
+            // State management handlers
+            _actionHandlers["save"] = new SavePlayerStateHandler();
+            _actionHandlers["restore"] = new RestorePlayerStateHandler();
+            _actionHandlers["buff"] = new ApplyBuffHandler();
+            _actionHandlers["clearbuffs"] = new ClearBuffsHandler();
+            _actionHandlers["removeunequip"] = new RemoveUnequipHandler();
+            _actionHandlers["resetcooldowns"] = new ResetCooldownsHandler();
+            _actionHandlers["teleport"] = new TeleportHandler();
+            _actionHandlers["gameplayevent"] = new CreateGameplayEventHandler();
+            
+            // Phase 2-3: Automation handlers
+            _actionHandlers["vbloodunlock"] = new AutoVBloodUnlockHandler();
+            _actionHandlers["spellbookgrant"] = new AutoSpellbookGrantHandler();
+        }
+
+        #region Test Methods
+
+        /// <summary>
+        /// Run self-test on all lifecycle components
+        /// </summary>
+        public Dictionary<string, bool> SelfTest()
+        {
+            var results = new Dictionary<string, bool>();
+            
+            // Test initialization
+            results["Initialized"] = IsInitialized;
+            
+            // Test stages registered
+            results["StagesRegistered"] = _lifecycleStages.Count > 0;
+            
+            // Test action handlers
+            results["ActionHandlers"] = _actionHandlers.Count > 0;
+            
+            // Test each handler type
+            foreach (var handler in _actionHandlers)
+            {
+                results[$"Handler_{handler.Key}"] = handler.Value != null;
+            }
+            
+            // Test stage execution (without actual actions)
+            try
+            {
+                var testContext = new LifecycleContext
+                {
+                    CharacterEntity = Entity.Null,
+                    Position = float3.zero
+                };
+                results["StageExecution"] = true;
+            }
+            catch
+            {
+                results["StageExecution"] = false;
+            }
+            
+            return results;
+        }
+
+        /// <summary>
+        /// Add a test action to a stage
+        /// </summary>
+        public bool AddTestAction(string stageName, LifecycleAction action)
+        {
+            if (!_lifecycleStages.TryGetValue(stageName, out var stage))
+            {
+                Log?.LogWarning($"{_logPrefix} Cannot add action - stage not found: {stageName}");
+                return false;
+            }
+            
+            stage.Actions.Add(action);
+            Log?.LogInfo($"{_logPrefix} Added test action to {stageName}: {action.Type}");
+            return true;
+        }
+
+        /// <summary>
+        /// Clear all actions from a stage
+        /// </summary>
+        public bool ClearStageActions(string stageName)
+        {
+            if (!_lifecycleStages.TryGetValue(stageName, out var stage))
+            {
+                Log?.LogWarning($"{_logPrefix} Cannot clear - stage not found: {stageName}");
+                return false;
+            }
+            
+            var count = stage.Actions.Count;
+            stage.Actions.Clear();
+            Log?.LogInfo($"{_logPrefix} Cleared {count} actions from {stageName}");
+            return true;
+        }
+
+        /// <summary>
+        /// Get stage details for debugging
+        /// </summary>
+        public Dictionary<string, object> GetStageDetails(string stageName)
+        {
+            var details = new Dictionary<string, object>();
+            
+            if (_lifecycleStages.TryGetValue(stageName, out var stage))
+            {
+                details["Name"] = stage.Name;
+                details["Description"] = stage.Description;
+                details["ActionCount"] = stage.Actions.Count;
+                
+                var actionTypes = stage.Actions.Select(a => a.Type).ToList();
+                details["ActionTypes"] = actionTypes;
+            }
+            else
+            {
+                details["Error"] = "Stage not found";
+            }
+            
+            return details;
+        }
+
+        /// <summary>
+        /// Get all registered stages and their action counts
+        /// </summary>
+        public Dictionary<string, int> GetAllStageActionCounts()
+        {
+            return _lifecycleStages.ToDictionary(
+                s => s.Key,
+                s => s.Value.Actions.Count
+            );
+        }
+
+        #endregion
+
+        private bool ShouldDebounce(Entity userEntity, string arenaId, string direction)
+        {
+            try
+            {
+                var key = $"{userEntity.Index}:{arenaId}:{direction}";
+                var now = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
+                if (_recentTransitions.TryGetValue(key, out var last))
+                {
+                    var dt = now - last;
+                    if (dt >= 0 && dt < DebounceWindowMs)
+                    {
+                        return true;
+                    }
+                }
+                _recentTransitions[key] = now;
+                return false;
+            }
+            catch
+            {
+                return false;
+            }
+        }
+    }
+
+    /// <summary>
+    /// Default trap lifecycle policy that uses the shared TrapPolicyResolver.
+    /// VLifecycle uses this to check if VAutoTraps has registered overrides.
+    /// </summary>
+    internal class DefaultTrapLifecyclePolicy : ITrapLifecyclePolicy
+    {
+        public bool IsEnabled => TrapPolicyResolver.AreOverridesEnabled();
+
+        public TrapLifecycleDecision OnBeforeLifecycleEnter(TrapLifecycleContext ctx)
+        {
+            return TrapPolicyResolver.EvaluateEnter(ctx);
+        }
+
+        public TrapLifecycleDecision OnBeforeLifecycleExit(TrapLifecycleContext ctx)
+        {
+            return TrapPolicyResolver.EvaluateExit(ctx);
+        }
+    }
+}
diff --git a/CycleBorn/Services/Lifecycle/ConnectionEventPatches.cs b/CycleBorn/Services/Lifecycle/ConnectionEventPatches.cs
new file mode 100644
index 0000000..66536f7
--- /dev/null
+++ b/CycleBorn/Services/Lifecycle/ConnectionEventPatches.cs
@@ -0,0 +1,139 @@
+using System;
+using System.Reflection;
+using HarmonyLib;
+using ProjectM;
+using ProjectM.Network;
+using Stunlock.Network;
+using VampireCommandFramework;
+using Unity.Mathematics;
+using VAuto.Core.Lifecycle;
+
+namespace VLifecycle.Services.Lifecycle
+{
+    /// <summary>
+    /// Handles user connection/disconnection events for cleanup and lifecycle management.
+    /// </summary>
+    public static class ConnectionEventPatches
+    {
+        private static bool _isInitialized = false;
+        private static Harmony _harmony;
+        private static readonly string _logPrefix = "[ConnectionEventPatches]";
+        
+        // Cache the NetEndPointToUserIndex field for performance
+        private static FieldInfo _netEndPointToUserIndexField;
+
+        public static void Initialize()
+        {
+            if (_isInitialized) return;
+
+            // Try to get the internal field via reflection
+            try {
+                var bootstrapType = typeof(ServerBootstrapSystem);
+                _netEndPointToUserIndexField = bootstrapType.GetField("_NetEndPointToUserIndex", 
+                    BindingFlags.NonPublic | BindingFlags.Instance);
+                if (_netEndPointToUserIndexField != null)
+                {
+                    Plugin.Log.LogInfo($"{_logPrefix} Found _NetEndPointToUserIndex field via reflection");
+                }
+                else
+                {
+                    Plugin.Log.LogWarning($"{_logPrefix} _NetEndPointToUserIndex field not found - connection events will be skipped");
+                }
+            } catch (Exception ex) {
+                Plugin.Log.LogWarning($"{_logPrefix} Failed to get _NetEndPointToUserIndex: {ex.Message}");
+            }
+
+            _harmony = new Harmony("gg.coyote.Vlifecycle.ConnectionEvents");
+            _harmony.PatchAll(typeof(ConnectionEventPatches));
+            _isInitialized = true;
+
+            Plugin.Log.LogInfo($"{_logPrefix} Initialized");
+        }
+
+        public static void Dispose()
+        {
+            _harmony?.UnpatchSelf();
+            _isInitialized = false;
+        }
+
+        /// <summary>
+        /// Handles player connection events.
+        /// </summary>
+        [HarmonyPatch(typeof(ServerBootstrapSystem), nameof(ServerBootstrapSystem.OnUserConnected))]
+        public static class OnUserConnectedPatch
+        {
+            [HarmonyPostfix]
+            public static void Postfix(ServerBootstrapSystem __instance, NetConnectionId netConnectionId)
+            {
+                try
+                {
+                    var userIndex = GetUserIndex(__instance, netConnectionId);
+                    if (userIndex.HasValue)
+                    {
+                        ArenaLifecycleManager.Instance.OnPlayerConnected(userIndex.Value);
+                    }
+                    else
+                    {
+                        Plugin.Log.LogDebug($"{_logPrefix} OnUserConnected: could not resolve user index for {netConnectionId}");
+                    }
+                }
+                catch (Exception ex)
+                {
+                    Plugin.Log?.LogError($"{_logPrefix} OnUserConnected Error: {ex.Message}");
+                }
+            }
+        }
+
+        /// <summary>
+        /// Handles player disconnection events.
+        /// </summary>
+        [HarmonyPatch(typeof(ServerBootstrapSystem), nameof(ServerBootstrapSystem.OnUserDisconnected))]
+        public static class OnUserDisconnectedPatch
+        {
+            [HarmonyPostfix]
+            public static void Postfix(ServerBootstrapSystem __instance, NetConnectionId netConnectionId)
+            {
+                try
+                {
+                    var userIndex = GetUserIndex(__instance, netConnectionId);
+                    if (userIndex.HasValue)
+                    {
+                        ArenaLifecycleManager.Instance.OnPlayerDisconnected(userIndex.Value);
+                    }
+                    else
+                    {
+                        Plugin.Log.LogDebug($"{_logPrefix} OnUserDisconnected: could not resolve user index for {netConnectionId}");
+                    }
+                }
+                catch (Exception ex)
+                {
+                    Plugin.Log?.LogError($"{_logPrefix} OnUserDisconnected Error: {ex.Message}");
+                }
+            }
+        }
+
+        /// <summary>
+        /// Try to get user index from NetConnectionId using reflection.
+        /// Returns null if the field is not available.
+        /// </summary>
+        private static int? GetUserIndex(ServerBootstrapSystem instance, NetConnectionId connectionId)
+        {
+            if (_netEndPointToUserIndexField == null)
+                return null;
+
+            try
+            {
+                var dictionary = _netEndPointToUserIndexField.GetValue(instance) as System.Collections.IDictionary;
+                if (dictionary != null && dictionary.Contains(connectionId))
+                {
+                    return (int)dictionary[connectionId];
+                }
+            }
+            catch (Exception ex)
+            {
+                Plugin.Log?.LogWarning($"{_logPrefix} Failed to get user index: {ex.Message}");
+            }
+            return null;
+        }
+    }
+}
diff --git a/CycleBorn/Services/Lifecycle/EnhancedArenaSnapshotLifecycleService.cs b/CycleBorn/Services/Lifecycle/EnhancedArenaSnapshotLifecycleService.cs
new file mode 100644
index 0000000..109690d
--- /dev/null
+++ b/CycleBorn/Services/Lifecycle/EnhancedArenaSnapshotLifecycleService.cs
@@ -0,0 +1,321 @@
+﻿using System;
+using System.Collections.Generic;
+using BepInEx.Logging;
+using ProjectM.Network;
+using Unity.Entities;
+using Unity.Mathematics;
+using VAuto.Core.Lifecycle;
+
+namespace VAuto.Core.Lifecycle
+{
+    public interface IEnhancedArenaSnapshotService
+    {
+        System.Threading.Tasks.Task CreateSnapshotAsync(Entity user, Entity character, string arenaId, string tag);
+        System.Threading.Tasks.Task DeleteSnapshotAsync(string characterId, string arenaId, string tag);
+        System.Threading.Tasks.Task CleanupArenaSnapshotsAsync(string arenaId);
+    }
+
+    internal sealed class EnhancedArenaSnapshotServiceStub : IEnhancedArenaSnapshotService
+    {
+        private readonly ManualLogSource _log;
+        public EnhancedArenaSnapshotServiceStub(ManualLogSource log) { _log = log; }
+        public System.Threading.Tasks.Task CreateSnapshotAsync(Entity user, Entity character, string arenaId, string tag)
+        {
+            _log?.LogInfo($"[EnhancedArenaSnapshot] (stub) CreateSnapshot char={character.Index} arena={arenaId} tag={tag}");
+            return System.Threading.Tasks.Task.CompletedTask;
+        }
+        public System.Threading.Tasks.Task DeleteSnapshotAsync(string characterId, string arenaId, string tag)
+        {
+            _log?.LogInfo($"[EnhancedArenaSnapshot] (stub) DeleteSnapshot charId={characterId} arena={arenaId} tag={tag}");
+            return System.Threading.Tasks.Task.CompletedTask;
+        }
+        public System.Threading.Tasks.Task CleanupArenaSnapshotsAsync(string arenaId)
+        {
+            _log?.LogInfo($"[EnhancedArenaSnapshot] (stub) CleanupSnapshots arena={arenaId}");
+            return System.Threading.Tasks.Task.CompletedTask;
+        }
+    }
+
+    /// <summary>
+    /// Lifecycle service for EnhancedArenaSnapshotService.
+    /// Handles snapshot creation on arena entry and deletion on arena exit.
+    /// </summary>
+    public class EnhancedArenaSnapshotLifecycleService : IArenaLifecycleService
+    {
+        // Exposed for integration tests to assert snapshot calls
+        public static EnhancedArenaSnapshotLifecycleService Instance { get; set; }
+
+        public bool IsInitialized { get; private set; }
+        public ManualLogSource Log { get; private set; }
+        
+        private readonly Dictionary<Entity, string> _playerArenaMap = new();
+        private readonly Dictionary<Entity, Entity> _userCharacterMap = new();
+        private readonly Dictionary<string, string> _activeTags = new(); // key=(characterId,arenaId)
+        private IEnhancedArenaSnapshotService _snapshotService;
+
+        /// <summary>
+        /// Initialize the snapshot lifecycle service
+        /// </summary>
+        public void Initialize(ManualLogSource logger)
+        {
+            try
+            {
+                Log = logger;
+                _snapshotService ??= new EnhancedArenaSnapshotServiceStub(Log);
+                IsInitialized = true;
+                Instance = this;
+                Log?.LogInfo("[EnhancedArenaSnapshotLifecycleService] Initialized snapshot lifecycle service");
+            }
+            catch (Exception ex)
+            {
+                Log?.LogError($"[EnhancedArenaSnapshotLifecycleService] Failed to initialize: {ex.Message}");
+                throw;
+            }
+        }
+
+        /// <summary>
+        /// Cleanup the snapshot lifecycle service
+        /// </summary>
+        public void Cleanup()
+        {
+            try
+            {
+                _playerArenaMap.Clear();
+                _userCharacterMap.Clear();
+                IsInitialized = false;
+                Instance = null;
+                Log?.LogInfo("[EnhancedArenaSnapshotLifecycleService] Cleaned up snapshot lifecycle service");
+            }
+            catch (Exception ex)
+            {
+                Log?.LogError($"[EnhancedArenaSnapshotLifecycleService] Failed to cleanup: {ex.Message}");
+            }
+        }
+
+        /// <summary>
+        /// Called when player enters arena - CREATE SNAPSHOT
+        /// </summary>
+        public virtual bool OnPlayerEnter(Entity user, Entity character, string arenaId)
+        {
+            try
+            {
+                if (!ValidateState())
+                {
+                    Log?.LogWarning("[EnhancedArenaSnapshotLifecycleService] Service not initialized, cannot handle player enter");
+                    return false;
+                }
+
+                Log?.LogInfo($"[EnhancedArenaSnapshotLifecycleService] Player entering arena {arenaId} - creating snapshot");
+
+                // Store arena mapping for exit
+                _playerArenaMap[user] = arenaId;
+                _userCharacterMap[user] = character;
+
+                // Build CharacterId and Tag
+                var characterId = GetCharacterId(user);
+                var tag = BuildSnapshotTag(characterId, arenaId);
+                _activeTags[$"{characterId}:{arenaId}"] = tag;
+                Log?.LogInfo($"[EnhancedArenaSnapshot] Tag generated tag={tag} char={characterId} arena={arenaId}");
+
+                // Create snapshot via service
+                _snapshotService.CreateSnapshotAsync(user, character, arenaId, tag).GetAwaiter().GetResult();
+                Log?.LogInfo($"[EnhancedArenaSnapshotLifecycleService] ✅ Snapshot created successfully for arena entry");
+
+                // Emit CreateGameplayEvent (Enter)
+                Log?.LogInfo($"[EnhancedArenaSnapshot] CreateGameplayEvent Enter arena={arenaId} char={characterId} tag={tag}");
+                return true;
+            }
+            catch (Exception ex)
+            {
+                Log?.LogError($"[EnhancedArenaSnapshotLifecycleService] Error in OnPlayerEnter: {ex.Message}");
+                return false;
+            }
+        }
+
+        /// <summary>
+        /// Called when player exits arena - DELETE SNAPSHOT
+        /// </summary>
+        public virtual bool OnPlayerExit(Entity user, Entity character, string arenaId)
+        {
+            try
+            {
+                if (!ValidateState())
+                {
+                    Log?.LogWarning("[EnhancedArenaSnapshotLifecycleService] Service not initialized, cannot handle player exit");
+                    return true; // Exit should not fail
+                }
+
+                // Use stored arenaId if available
+                if (_playerArenaMap.TryGetValue(user, out var storedArenaId))
+                {
+                    arenaId = storedArenaId;
+                    _playerArenaMap.Remove(user);
+                }
+
+                // Get character from stored mapping if not provided
+                if (character == Entity.Null && _userCharacterMap.TryGetValue(user, out var storedCharacter))
+                {
+                    character = storedCharacter;
+                    _userCharacterMap.Remove(user);
+                }
+
+                Log?.LogInfo($"[EnhancedArenaSnapshotLifecycleService] Player exiting arena {arenaId} - deleting snapshot");
+
+                // Get character ID for snapshot deletion
+                var characterId = GetCharacterId(user);
+
+                // Determine Tag
+                var key = $"{characterId}:{arenaId}";
+                if (!_activeTags.TryGetValue(key, out var tag) || string.IsNullOrEmpty(tag))
+                {
+                    tag = BuildSnapshotTag(characterId, arenaId);
+                    Log?.LogWarning($"[EnhancedArenaSnapshot] No prior Tag on Exit; generated tag={tag} char={characterId} arena={arenaId}");
+                }
+                else
+                {
+                    _activeTags.Remove(key);
+                }
+
+                // Delete/restore snapshot via service
+                _snapshotService.DeleteSnapshotAsync(characterId, arenaId, tag).GetAwaiter().GetResult();
+                Log?.LogInfo($"[EnhancedArenaSnapshotLifecycleService] ✅ Snapshot deletion/restoration completed for arena exit");
+
+                // Emit CreateGameplayEvent (Exit)
+                Log?.LogInfo($"[EnhancedArenaSnapshot] CreateGameplayEvent Exit arena={arenaId} char={characterId} tag={tag}");
+                return true;
+            }
+            catch (Exception ex)
+            {
+                Log?.LogError($"[EnhancedArenaSnapshotLifecycleService] Error in OnPlayerExit: {ex.Message}");
+                return false;
+            }
+        }
+
+        /// <summary>
+        /// Called when arena lifecycle starts
+        /// </summary>
+        public bool OnArenaStart(string arenaId)
+        {
+            try
+            {
+                if (!ValidateState()) return true;
+                
+                Log?.LogInfo($"[EnhancedArenaSnapshotLifecycleService] Arena {arenaId} started - no action needed for snapshots");
+                return true;
+            }
+            catch (Exception ex)
+            {
+                Log?.LogError($"[EnhancedArenaSnapshotLifecycleService] Error in OnArenaStart: {ex.Message}");
+                return false;
+            }
+        }
+
+        /// <summary>
+        /// Called when arena lifecycle ends
+        /// </summary>
+        public bool OnArenaEnd(string arenaId)
+        {
+            try
+            {
+                if (!ValidateState()) return true;
+                
+                Log?.LogInfo($"[EnhancedArenaSnapshotLifecycleService] Arena {arenaId} ended - cleaning up all snapshots");
+                
+                // Clean up all snapshots for this arena
+                CleanupArenaSnapshots(arenaId);
+                
+                return true;
+            }
+            catch (Exception ex)
+            {
+                Log?.LogError($"[EnhancedArenaSnapshotLifecycleService] Error in OnArenaEnd: {ex.Message}");
+                return false;
+            }
+        }
+
+        #region Private Helper Methods
+
+        private bool ValidateState()
+        {
+            return IsInitialized && Log != null;
+        }
+
+        private string GetCharacterId(Entity user)
+        {
+            try
+            {
+                var em = VAutomationCore.Core.UnifiedCore.EntityManager;
+                if (em == null)
+                {
+                    Log?.LogWarning("[EnhancedArenaSnapshotLifecycleService] EntityManager not available");
+                    return user.Index.ToString();
+                }
+
+                if (em.TryGetComponentData(user, out User userData))
+                {
+                    return userData.PlatformId.ToString();
+                }
+
+                Log?.LogWarning("[EnhancedArenaSnapshotLifecycleService] Could not get user data");
+                return user.Index.ToString();
+            }
+            catch (Exception ex)
+            {
+                Log?.LogError($"[EnhancedArenaSnapshotLifecycleService] Error getting character ID: {ex.Message}");
+                return user.Index.ToString();
+            }
+        }
+
+        private bool AsyncCreateSnapshot(Entity user, Entity character, string arenaId)
+        {
+            // TODO: Replace with actual EnhancedArenaSnapshotService.CreateSnapshot call
+            // This is a placeholder for the async implementation
+            try
+            {
+                // Example: return EnhancedArenaSnapshotService.CreateSnapshotAsync(user, character, arenaId).Result;
+                
+                // For now, create a PlayerLifecycleEvent and log
+                var lifecycleEvent = new PlayerLifecycleEvent
+                {
+                    UserEntity = user,
+                    CharacterEntity = character,
+                    ArenaId = arenaId,
+                    EventType = PlayerLifecycleEventType.Enter,
+                    Timestamp = DateTime.UtcNow,
+                    EventData = { { "Method", "AsyncCreateSnapshot" } }
+                };
+                
+                Log?.LogInfo($"[EnhancedArenaSnapshotLifecycleService] Created event for arena entry snapshot");
+                return true;
+            }
+            catch (Exception ex)
+            {
+                Log?.LogError($"[EnhancedArenaSnapshotLifecycleService] AsyncCreateSnapshot failed: {ex.Message}");
+                return false;
+            }
+        }
+
+        private void AsyncDeleteSnapshot(string characterId, string arenaId)
+        {
+            // TODO: Replace with actual EnhancedArenaSnapshotService.DeleteSnapshotAsync call
+            // This is a placeholder for the async implementation
+            try
+            {
+                // Example: EnhancedArenaSnapshotService.DeleteSnapshotAsync(characterId, arenaId);
+                
+                Log?.LogInfo($"[EnhancedArenaSnapshotLifecycleService] Initiated async delete for snapshot: character={characterId}, arena={arenaId}");
+            }
+            catch (Exception ex)
+            {
+                Log?.LogError($"[EnhancedArenaSnapshotLifecycleService] AsyncDeleteSnapshot failed: {ex.Message}");
+            }
+        }
+
+        private string BuildSnapshotTag(string characterId, string arenaId)
+        {
+            return $"{characterId}:{arenaId}:{DateTimeOffset.UtcNow.ToUnixTimeSeconds()}";
+        }
+
+        #endregion
+    }
+}
diff --git a/CycleBorn/Services/Lifecycle/Handlers/ArenaTracker.cs b/CycleBorn/Services/Lifecycle/Handlers/ArenaTracker.cs
new file mode 100644
index 0000000..72ae37f
--- /dev/null
+++ b/CycleBorn/Services/Lifecycle/Handlers/ArenaTracker.cs
@@ -0,0 +1,115 @@
+using System.Collections.Generic;
+using System.Linq;
+using BepInEx.Logging;
+using Unity.Entities;
+using VAuto.Core;
+
+namespace VAuto.Core.Lifecycle.Handlers
+{
+    /// <summary>
+    /// Tracks arena state including pending bosses and player arena status.
+    /// Used by patch handlers to determine if player is currently in arena.
+    /// </summary>
+    public static class ArenaTracker
+    {
+        private static readonly List<Entity> _pendingBosses = new();
+        private static readonly HashSet<string> _activeArenas = new();
+        private static ManualLogSource _log;
+
+        public static bool IsAnyPlayerInArena => _activeArenas.Count > 0;
+
+        /// <summary>
+        /// Initialize the tracker
+        /// </summary>
+        public static void Initialize(ManualLogSource logger)
+        {
+            _log = logger;
+            _pendingBosses.Clear();
+            _activeArenas.Clear();
+            _log?.LogInfo("[ArenaTracker] Initialized");
+        }
+
+        /// <summary>
+        /// Cleanup the tracker
+        /// </summary>
+        public static void Cleanup()
+        {
+            _pendingBosses.Clear();
+            _activeArenas.Clear();
+            _log?.LogInfo("[ArenaTracker] Cleaned up");
+        }
+
+        /// <summary>
+        /// Register a pending boss spawn
+        /// </summary>
+        public static void AddPendingBoss(Entity bossEntity)
+        {
+            if (!_pendingBosses.Contains(bossEntity))
+            {
+                _pendingBosses.Add(bossEntity);
+                _log?.LogDebug($"[ArenaTracker] Added pending boss");
+            }
+        }
+
+        /// <summary>
+        /// Remove a boss from pending list
+        /// </summary>
+        public static void RemovePendingBoss(Entity bossEntity)
+        {
+            _pendingBosses.Remove(bossEntity);
+        }
+
+        /// <summary>
+        /// Clear all pending bosses
+        /// </summary>
+        public static void ClearPendingBosses()
+        {
+            _pendingBosses.Clear();
+            _log?.LogInfo("[ArenaTracker] Cleared all pending bosses");
+        }
+
+        /// <summary>
+        /// Mark an arena as active
+        /// </summary>
+        public static void RegisterArena(string arenaId)
+        {
+            _activeArenas.Add(arenaId);
+            _log?.LogInfo($"[ArenaTracker] Arena registered: {arenaId}");
+        }
+
+        /// <summary>
+        /// Unregister an arena
+        /// </summary>
+        public static void UnregisterArena(string arenaId)
+        {
+            _activeArenas.Remove(arenaId);
+            _log?.LogInfo($"[ArenaTracker] Arena unregistered: {arenaId}");
+        }
+
+        /// <summary>
+        /// Clear a specific arena and its pending bosses
+        /// </summary>
+        public static void ClearArena(string arenaId)
+        {
+            _activeArenas.Remove(arenaId);
+            ClearPendingBosses();
+            _log?.LogInfo($"[ArenaTracker] Arena cleared: {arenaId}");
+        }
+
+        /// <summary>
+        /// Get all pending boss entities
+        /// </summary>
+        public static IReadOnlyList<Entity> GetPendingBosses()
+        {
+            return _pendingBosses.ToList().AsReadOnly();
+        }
+
+        /// <summary>
+        /// Check if an entity is a pending boss
+        /// </summary>
+        public static bool IsPendingBoss(Entity entity)
+        {
+            return _pendingBosses.Contains(entity);
+        }
+    }
+}
diff --git a/CycleBorn/Services/Lifecycle/Handlers/ArenaUnlockLifecycleService.cs b/CycleBorn/Services/Lifecycle/Handlers/ArenaUnlockLifecycleService.cs
new file mode 100644
index 0000000..fc558d7
--- /dev/null
+++ b/CycleBorn/Services/Lifecycle/Handlers/ArenaUnlockLifecycleService.cs
@@ -0,0 +1,173 @@
+using System.Collections.Generic;
+using BepInEx.Logging;
+using Unity.Entities;
+using VAuto.Core.Lifecycle;
+
+namespace VAuto.Core.Lifecycle.Handlers
+{
+    /// <summary>
+    /// Lifecycle service that orchestrates all unlock/reset handlers when player enters or leaves arena.
+    /// This service enables full endgame sandbox mode during arena sessions.
+    /// </summary>
+    public class ArenaUnlockLifecycleService : IArenaLifecycleService
+    {
+        private readonly List<LifecycleActionHandler> _enterHandlers = new();
+        private readonly List<LifecycleActionHandler> _exitHandlers = new();
+        private ManualLogSource _log;
+
+        public bool IsInitialized { get; private set; }
+
+        /// <summary>
+        /// Initialize the arena unlock lifecycle service
+        /// </summary>
+        public void Initialize(ManualLogSource logger)
+        {
+            _log = logger;
+            
+            // ENTRY CHAIN - Execute when player enters arena
+            _enterHandlers.Add(new SavePlayerStateHandler());
+            _enterHandlers.Add(new ResetCooldownsHandler());
+            _enterHandlers.Add(new ClearBuffsHandler());
+            _enterHandlers.Add(new PlayerEndgameUnlockHandler());
+            _enterHandlers.Add(new UnlockMenusHandler());
+            _enterHandlers.Add(new BoostStatsHandler());
+            
+            // Phase 2-3: Automation Handlers
+            _enterHandlers.Add(new AutoVBloodUnlockHandler());
+            _enterHandlers.Add(new AutoSpellbookGrantHandler());
+            
+            _enterHandlers.Add(new ApplyBuffHandler { BuffId = "ArenaReady" });
+            _enterHandlers.Add(new TeleportHandler { Position = new Unity.Mathematics.float3(-1000, 5, -500) });
+            _enterHandlers.Add(new MessageActionHandler { Message = "Entering Arena — All powers unlocked!" });
+            _enterHandlers.Add(new CreateGameplayEventHandler { EventPrefab = "ArenaEnterComplete" });
+
+            // EXIT CHAIN - Execute when player exits arena
+            _exitHandlers.Add(new ClearBuffsHandler());
+            _exitHandlers.Add(new LockMenusHandler());
+            _exitHandlers.Add(new PlayerEndgameLockHandler());
+            
+            _exitHandlers.Add(new RestorePlayerStateHandler());
+            _exitHandlers.Add(new MessageActionHandler { Message = "Exiting Arena — Restoring Progression..." });
+            _exitHandlers.Add(new CreateGameplayEventHandler { EventPrefab = "ArenaExitComplete" });
+
+            IsInitialized = true;
+            _log?.LogInfo("[ArenaUnlockLifecycleService] Initialized with unlock/reset handler chains");
+        }
+
+        /// <summary>
+        /// Cleanup the service
+        /// </summary>
+        public void Cleanup()
+        {
+            _enterHandlers.Clear();
+            _exitHandlers.Clear();
+            IsInitialized = false;
+            _log?.LogInfo("[ArenaUnlockLifecycleService] Cleaned up");
+        }
+
+        /// <summary>
+        /// Called when player enters arena - Execute all unlock handlers
+        /// </summary>
+        public bool OnPlayerEnter(Entity user, Entity character, string arenaId)
+        {
+            if (!ValidateState())
+            {
+                _log?.LogWarning("[ArenaUnlockLifecycleService] Service not initialized");
+                return false;
+            }
+
+            _log?.LogInfo($"[ArenaUnlockLifecycleService] Player entering arena {arenaId}");
+
+            var context = new LifecycleContext
+            {
+                UserEntity = user,
+                CharacterEntity = character,
+                ArenaId = arenaId,
+                StoredData = new Dictionary<string, object>()
+            };
+
+            foreach (var handler in _enterHandlers)
+            {
+                try
+                {
+                    var action = new LifecycleAction { ActionType = LifecycleActionType.Custom };
+                    handler.Execute(action, context);
+                }
+                catch (System.Exception ex)
+                {
+                    _log?.LogError($"[ArenaUnlockLifecycleService] Error in enter handler: {ex.Message}");
+                }
+            }
+
+            _log?.LogInfo($"[ArenaUnlockLifecycleService] ✅ Arena entry unlocks complete");
+            return true;
+        }
+
+        /// <summary>
+        /// Called when player exits arena - Execute all reset handlers
+        /// </summary>
+        public bool OnPlayerExit(Entity user, Entity character, string arenaId)
+        {
+            if (!ValidateState())
+            {
+                _log?.LogWarning("[ArenaUnlockLifecycleService] Service not initialized");
+                return true; // Don't fail exit
+            }
+
+            _log?.LogInfo($"[ArenaUnlockLifecycleService] Player exiting arena {arenaId}");
+
+            var context = new LifecycleContext
+            {
+                UserEntity = user,
+                CharacterEntity = character,
+                ArenaId = arenaId,
+                StoredData = new Dictionary<string, object>()
+            };
+
+            foreach (var handler in _exitHandlers)
+            {
+                try
+                {
+                    var action = new LifecycleAction { ActionType = LifecycleActionType.Custom };
+                    handler.Execute(action, context);
+                }
+                catch (System.Exception ex)
+                {
+                    _log?.LogError($"[ArenaUnlockLifecycleService] Error in exit handler: {ex.Message}");
+                }
+            }
+
+            _log?.LogInfo($"[ArenaUnlockLifecycleService] ✅ Arena exit resets complete");
+            return true;
+        }
+
+        /// <summary>
+        /// Called when arena lifecycle starts
+        /// </summary>
+        public bool OnArenaStart(string arenaId)
+        {
+            _log?.LogInfo($"[ArenaUnlockLifecycleService] Arena {arenaId} started");
+            return true;
+        }
+
+        /// <summary>
+        /// Called when arena lifecycle ends
+        /// </summary>
+        public bool OnArenaEnd(string arenaId)
+        {
+            _log?.LogInfo($"[ArenaUnlockLifecycleService] Arena {arenaId} ended");
+            ArenaTracker.ClearArena(arenaId);
+            return true;
+        }
+
+        // Unused interface methods
+        public bool OnBuildStart(Entity u, string s, string a) => true;
+        public bool OnBuildComplete(Entity u, string s, string a) => true;
+        public bool OnBuildDestroy(Entity u, string s, string a) => true;
+
+        private bool ValidateState()
+        {
+            return IsInitialized && _log != null;
+        }
+    }
+}
diff --git a/CycleBorn/Services/Lifecycle/Handlers/AutoSpellbookGrantHandler.cs b/CycleBorn/Services/Lifecycle/Handlers/AutoSpellbookGrantHandler.cs
new file mode 100644
index 0000000..698c2ea
--- /dev/null
+++ b/CycleBorn/Services/Lifecycle/Handlers/AutoSpellbookGrantHandler.cs
@@ -0,0 +1,193 @@
+using System;
+using Unity.Entities;
+using VAuto.Core.Lifecycle;
+
+namespace VAuto.Core.Lifecycle.Handlers
+{
+    /// <summary>
+    /// Result enum for spellbook granting operations.
+    /// </summary>
+    public enum GrantResult
+    {
+        Success,
+        InventoryFull,
+        AlreadyOwned,
+        Failed
+    }
+
+    /// <summary>
+    /// Handles automatic spellbook granting on zone transitions.
+    /// Implements LifecycleActionHandler interface.
+    /// </summary>
+    public class AutoSpellbookGrantHandler : LifecycleActionHandler
+    {
+        private const string LogSource = "AutoSpellbookGrantHandler";
+        
+        /// <summary>
+        /// Priority for grant requests (lower = higher priority).
+        /// </summary>
+        public int Priority { get; set; } = 0;
+        
+        /// <summary>
+        /// Behavior when inventory is full.
+        /// </summary>
+        public InventoryOverflowBehavior OverflowBehavior { get; set; } = InventoryOverflowBehavior.DropExisting;
+
+        /// <summary>
+        /// Behavior when inventory is full.
+        /// </summary>
+        public enum InventoryOverflowBehavior
+        {
+            DropExisting,
+            FailGracefully,
+            CreateMail
+        }
+
+        /// <summary>
+        /// Default constructor.
+        /// </summary>
+        public AutoSpellbookGrantHandler()
+        {
+        }
+
+        /// <summary>
+        /// Executes the spellbook grant action for the given context.
+        /// </summary>
+        /// <param name="action">The lifecycle action containing grant parameters.</param>
+        /// <param name="context">The lifecycle context containing player entity information.</param>
+        /// <returns>True if grant was successful.</returns>
+        public bool Execute(LifecycleAction action, LifecycleContext context)
+        {
+            if (action.Type != "SpellbookGrant")
+            {
+                VLifecycle.Plugin.Log?.LogDebug($"[{LogSource}] Ignoring action type: {action.Type}");
+                return false;
+            }
+
+            var em = VAutomationCore.Core.UnifiedCore.EntityManager;
+            var character = context.CharacterEntity;
+
+            if (character == Entity.Null)
+            {
+                VLifecycle.Plugin.Log?.LogWarning($"[{LogSource}] Character entity is null");
+                return false;
+            }
+
+            try
+            {
+                // Get spellbook ID from action
+                if (string.IsNullOrEmpty(action.ConfigId))
+                {
+                    VLifecycle.Plugin.Log?.LogWarning($"[{LogSource}] No spellbook ID specified in action");
+                    return false;
+                }
+
+                // Grant spellbook
+                var result = GrantSpellbook(character, action.ConfigId, em);
+                
+                VLifecycle.Plugin.Log?.LogInfo($"[{LogSource}] Spellbook grant result: {result}");
+                return result == GrantResult.Success;
+            }
+            catch (Exception ex)
+            {
+                VLifecycle.Plugin.Log?.LogError($"[{LogSource}] Exception: {ex.Message}");
+                return false;
+            }
+        }
+
+        /// <summary>
+        /// Grants a spellbook to the player.
+        /// </summary>
+        private GrantResult GrantSpellbook(Entity character, string spellbookId, EntityManager em)
+        {
+            // Check if player already has the spellbook
+            if (PlayerAlreadyHasSpellbook(character, spellbookId, em))
+            {
+                VLifecycle.Plugin.Log?.LogDebug($"[{LogSource}] Player already has spellbook: {spellbookId}");
+                return GrantResult.AlreadyOwned;
+            }
+
+            // Check inventory space
+            if (!HasInventorySpace(character, em))
+            {
+                VLifecycle.Plugin.Log?.LogWarning($"[{LogSource}] Inventory full for spellbook: {spellbookId}");
+                
+                switch (OverflowBehavior)
+                {
+                    case InventoryOverflowBehavior.FailGracefully:
+                        return GrantResult.InventoryFull;
+                    case InventoryOverflowBehavior.CreateMail:
+                        // TODO: Create mail with spellbook
+                        return GrantResult.InventoryFull;
+                    default:
+                        break;
+                }
+            }
+
+            try
+            {
+                // Grant spellbook using game API
+                // This is a placeholder - actual implementation would use the game's item granting API
+                VLifecycle.Plugin.Log?.LogInfo($"[{LogSource}] Granting spellbook: {spellbookId}");
+                
+                return GrantResult.Success;
+            }
+            catch (Exception ex)
+            {
+                VLifecycle.Plugin.Log?.LogError($"[{LogSource}] Grant failed: {ex.Message}");
+                return GrantResult.Failed;
+            }
+        }
+
+        /// <summary>
+        /// Checks if player already has a spellbook.
+        /// </summary>
+        private bool PlayerAlreadyHasSpellbook(Entity character, string spellbookId, EntityManager em)
+        {
+            if (!em.HasComponent<Inventory>(character))
+            {
+                return false;
+            }
+
+            var items = em.GetBuffer<InventoryItem>(character);
+            
+            foreach (var item in items)
+            {
+                if (item.ItemEntity == Entity.Null) continue;
+                
+                // Check if item matches spellbook ID
+                // This is a placeholder - actual implementation would compare item GUIDs
+            }
+            
+            return false;
+        }
+
+        /// <summary>
+        /// Checks if player has inventory space.
+        /// </summary>
+        private bool HasInventorySpace(Entity character, EntityManager em)
+        {
+            if (!em.HasComponent<Inventory>(character))
+            {
+                return false;
+            }
+
+            var inventory = em.GetComponentData<Inventory>(character);
+            var items = em.GetBuffer<InventoryItem>(character);
+            
+            return items.Length < inventory.MaxSlots;
+        }
+
+        /// <summary>
+        /// Creates a spellbook grant lifecycle action.
+        /// </summary>
+        public static LifecycleAction CreateSpellbookGrantAction(string spellbookId)
+        {
+            return new LifecycleAction
+            {
+                Type = "SpellbookGrant",
+                ConfigId = spellbookId
+            };
+        }
+    }
+}
diff --git a/CycleBorn/Services/Lifecycle/Handlers/AutoVBloodUnlockHandler.cs b/CycleBorn/Services/Lifecycle/Handlers/AutoVBloodUnlockHandler.cs
new file mode 100644
index 0000000..3420bf8
--- /dev/null
+++ b/CycleBorn/Services/Lifecycle/Handlers/AutoVBloodUnlockHandler.cs
@@ -0,0 +1,149 @@
+using System;
+using Unity.Entities;
+using VAuto.Core.Lifecycle;
+
+namespace VAuto.Core.Lifecycle.Handlers
+{
+    /// <summary>
+    /// Result enum for VBlood unlock operations.
+    /// </summary>
+    public enum UnlockResult
+    {
+        Success,
+        AlreadyUnlocked,
+        Failed,
+        ConditionsNotMet
+    }
+
+    /// <summary>
+    /// Handles automatic VBlood boss unlocks.
+    /// Implements existing LifecycleActionHandler interface.
+    /// </summary>
+    public class AutoVBloodUnlockHandler : LifecycleActionHandler
+    {
+        private const string LogSource = "AutoVBloodUnlockHandler";
+        
+        /// <summary>
+        /// Cooldown in seconds between unlock operations.
+        /// </summary>
+        public float CooldownSeconds { get; set; } = 60f;
+        
+        /// <summary>
+        /// Whether to force unlock regardless of conditions.
+        /// </summary>
+        public bool ForceUnlockOverride { get; set; } = false;
+        
+        /// <summary>
+        /// Priority for unlock requests (lower = higher priority).
+        /// </summary>
+        public int UnlockPriority { get; set; } = 0;
+        
+        private float _lastUnlockTime;
+
+        /// <summary>
+        /// Default constructor.
+        /// </summary>
+        public AutoVBloodUnlockHandler()
+        {
+        }
+
+        /// <summary>
+        /// Executes the VBlood unlock action for the given context.
+        /// </summary>
+        /// <param name="action">The lifecycle action containing unlock parameters.</param>
+        /// <param name="context">The lifecycle context containing player entity information.</param>
+        /// <returns>True if unlock was successful.</returns>
+        public bool Execute(LifecycleAction action, LifecycleContext context)
+        {
+            if (!string.Equals(action.Type, "vbloodunlock", StringComparison.OrdinalIgnoreCase))
+            {
+                VLifecycle.Plugin.Log?.LogDebug($"[{LogSource}] Ignoring action type: {action.Type}");
+                return false;
+            }
+
+            var em = VAutomationCore.Core.UnifiedCore.EntityManager;
+            var user = context.UserEntity;
+
+            if (user == Entity.Null)
+            {
+                VLifecycle.Plugin.Log?.LogWarning($"[{LogSource}] User entity is null");
+                return false;
+            }
+
+            try
+            {
+                // Check cooldown
+                if (CooldownSeconds > 0 && (float)(DateTime.UtcNow - _lastUnlockTime).TotalSeconds < CooldownSeconds)
+                {
+                    VLifecycle.Plugin.Log?.LogDebug($"[{LogSource}] Unlock cooldown active");
+                    return false;
+                }
+
+                // Check conditions or use force override
+                if (!ForceUnlockOverride && !AreUnlockConditionsMet(user, em))
+                {
+                    VLifecycle.Plugin.Log?.LogDebug($"[{LogSource}] Unlock conditions not met");
+                    return false;
+                }
+
+                // Perform unlock
+                var result = UnlockVBloods(user, em);
+                
+                if (result == UnlockResult.Success)
+                {
+                    _lastUnlockTime = DateTime.UtcNow;
+                    VLifecycle.Plugin.Log?.LogInfo($"[{LogSource}] ✅ VBlood unlock completed successfully");
+                }
+                
+                return result == UnlockResult.Success;
+            }
+            catch (Exception ex)
+            {
+                VLifecycle.Plugin.Log?.LogError($"[{LogSource}] Exception: {ex.Message}");
+                return false;
+            }
+        }
+
+        /// <summary>
+        /// Checks if unlock conditions are met for the player.
+        /// </summary>
+        private bool AreUnlockConditionsMet(Entity user, EntityManager em)
+        {
+            // Check if player is in valid zone for unlocks
+            // This is a placeholder - actual implementation would check zone membership
+            return true;
+        }
+
+        /// <summary>
+        /// Unlocks VBlood content for the player using SandboxUnlockUtility.
+        /// </summary>
+        private UnlockResult UnlockVBloods(Entity user, EntityManager em)
+        {
+            try
+            {
+                // Route unlock to DebugEventBridge for proper backup/restore support
+                VAuto.Core.Services.DebugEventBridge.OnPlayerIsInZone(user);
+                
+                VLifecycle.Plugin.Log?.LogInfo($"[{LogSource}] VBlood unlocks applied via DebugEventBridge");
+                return UnlockResult.Success;
+            }
+            catch (Exception ex)
+            {
+                VLifecycle.Plugin.Log?.LogError($"[{LogSource}] Unlock failed: {ex.Message}");
+                return UnlockResult.Failed;
+            }
+        }
+
+        /// <summary>
+        /// Creates a VBlood unlock lifecycle action.
+        /// </summary>
+        public static LifecycleAction CreateVBloodUnlockAction(bool forceOverride = false, int priority = 0)
+        {
+            return new LifecycleAction
+            {
+                Type = "VBloodUnlock",
+                ConfigId = forceOverride ? "force" : null
+            };
+        }
+    }
+}
diff --git a/CycleBorn/Services/Lifecycle/Handlers/BoostStatsHandler.cs b/CycleBorn/Services/Lifecycle/Handlers/BoostStatsHandler.cs
new file mode 100644
index 0000000..277ac4a
--- /dev/null
+++ b/CycleBorn/Services/Lifecycle/Handlers/BoostStatsHandler.cs
@@ -0,0 +1,114 @@
+using Unity.Entities;
+using ProjectM;
+using VAutomationCore.Core;
+
+namespace VAuto.Core.Lifecycle.Handlers
+{
+    /// <summary>
+    /// Overwrites character stats to maximum values for arena sandbox mode.
+    /// Boosts: Health, Level, GearLevel, Blood Quality, Resistances.
+    /// </summary>
+    public class BoostStatsHandler : LifecycleActionHandler
+    {
+        private const string LogSource = "BoostStatsHandler";
+
+        public bool Execute(LifecycleAction action, LifecycleContext context)
+        {
+            var em = VAutomationCore.Core.UnifiedCore.EntityManager;
+            var character = context.CharacterEntity;
+
+            if (character == Entity.Null)
+            {
+                VAutoLogger.LogWarning($"[{LogSource}] Character entity is null");
+                return false;
+            }
+
+            try
+            {
+                // Max health
+                if (em.HasComponent<Health>(character))
+                {
+                    var health = em.GetComponentData<Health>(character);
+                    health.Value = 9999f;
+                    health.MaxHealth = 9999f;
+                    em.SetComponentData(character, health);
+                    VAutoLogger.LogInfo($"[{LogSource}] Health maxed to 9999");
+                }
+
+                // Max level/gear level
+                if (em.HasComponent<UnitLevel>(character))
+                {
+                    var level = em.GetComponentData<UnitLevel>(character);
+                    level.GearLevel = 99;
+                    level.Level = 80;
+                    em.SetComponentData(character, level);
+                    VAutoLogger.LogInfo($"[{LogSource}] Level/GearLevel maxed");
+                }
+
+                // Max blood quality
+                if (em.HasComponent<Blood>(character))
+                {
+                    var blood = em.GetComponentData<Blood>(character);
+                    blood.Quality = 100f;
+                    em.SetComponentData(character, blood);
+                    VAutoLogger.LogInfo($"[{LogSource}] Blood quality maxed to 100");
+                }
+
+                // Max resistances
+                if (em.HasComponent<Resistances>(character))
+                {
+                    var resist = em.GetComponentData<Resistances>(character);
+                    resist.SunResistance = 100f;
+                    resist.FireResistance = 100f;
+                    resist.HolyResistance = 100f;
+                    resist.DecayResistance = 100f;
+                    resist.BleedResistance = 100f;
+                    em.SetComponentData(character, resist);
+                    VAutoLogger.LogInfo($"[{LogSource}] All resistances maxed");
+                }
+
+                // Max physical damage/defense if components exist
+                TryBoostCombatStats(character, em);
+
+                VAutoLogger.LogInfo($"[{LogSource}] ✅ All stats boosted for arena");
+                return true;
+            }
+            catch (System.Exception ex)
+            {
+                VAutoLogger.LogException(ex);
+                VAutoLogger.LogError($"[{LogSource}] Failed: {ex.Message}");
+                return false;
+            }
+        }
+
+        private void TryBoostCombatStats(Entity character, EntityManager em)
+        {
+            // Physical Damage
+            if (em.HasComponent<PhysicalDamage>(character))
+            {
+                var dmg = em.GetComponentData<PhysicalDamage>(character);
+                dmg.Value = 5000f;
+                em.SetComponentData(character, dmg);
+            }
+
+            // Weapon Damage
+            if (em.HasComponent<WeaponDamage>(character))
+            {
+                var wdmg = em.GetComponentData<WeaponDamage>(character);
+                wdmg.BaseDamage = 5000f;
+                wdmg.BonusDamage = 5000f;
+                em.SetComponentData(character, wdmg);
+            }
+
+            // Armor/Defense
+            if (em.HasComponent<Armor>(character))
+            {
+                var armor = em.GetComponentData<Armor>(character);
+                armor.Value = 5000f;
+                em.SetComponentData(character, armor);
+            }
+
+            VAutoLogger.LogDebug($"[{LogSource}] Combat stats boosted");
+        }
+    }
+}
diff --git a/CycleBorn/Services/Lifecycle/Handlers/PatchBuffSystemSpawnServer.cs b/CycleBorn/Services/Lifecycle/Handlers/PatchBuffSystemSpawnServer.cs
new file mode 100644
index 0000000..3d822dc
--- /dev/null
+++ b/CycleBorn/Services/Lifecycle/Handlers/PatchBuffSystemSpawnServer.cs
@@ -0,0 +1,109 @@
+using HarmonyLib;
+using ProjectM;
+using ProjectM.Gameplay.Systems;
+using Unity.Entities;
+using Unity.Collections;
+using static VAutomationCore.Core.UnifiedCore;
+
+using System;
+
+namespace VAuto.Core.Lifecycle.Handlers
+{
+    /// <summary>
+    /// Non-destructive patch for VBlood feed suppression.
+    /// Instead of destroying entities, we tag sandboxed players and schedule delayed despawn.
+    /// </summary>
+    [HarmonyPatch(typeof(BuffSystem_Spawn_Server))]
+    public static class PatchBuffSystemSpawnServer
+    {
+        private const string LogSource = "PatchBuffSystemSpawnServer";
+
+        // Prefab GUIDs for VBlood feeds (example placeholders)
+        private static readonly int FEED_BOSS_03_COMPLETE_TRIGGER = 123456;
+        private static readonly int FEED_BOSS_04_COMPLETE_AREA_TRIGGER = 789012;
+
+        [HarmonyPrefix]
+        [HarmonyPatch("OnUpdate")]
+        public static void Prefix(BuffSystem_Spawn_Server __instance)
+        {
+            try
+            {
+                if (!ArenaTracker.IsAnyPlayerInArena) return;
+                var em = UnifiedCore.EntityManager;
+                if (em == null) return;
+
+                // Safely iterate spawn queue
+                using (var entities = __instance._SpawnQueue.ToEntityArray(Allocator.Temp))
+                {
+                    foreach (var spawnEntity in entities)
+                    {
+                        if (!em.Exists(spawnEntity)) continue;
+                        if (!em.HasComponent<PrefabGUID>(spawnEntity)) continue;
+                        
+                        var guid = em.GetComponentData<PrefabGUID>(spawnEntity).GuidHash;
+                        
+                        if (guid == FEED_BOSS_03_COMPLETE_TRIGGER || 
+                            guid == FEED_BOSS_04_COMPLETE_AREA_TRIGGER)
+                        {
+                            if (!em.HasComponent<FromCharacter>(spawnEntity)) continue;
+                            var playerEntity = em.GetComponentData<FromCharacter>(spawnEntity).Character;
+                            
+                            // Non-Destructive Tagging
+                            if (!em.HasComponent<SandboxModeTag>(playerEntity))
+                            {
+                                var steamId = DebugEventBridge.Instance.GetSteamId(playerEntity);
+                                em.AddComponentData(playerEntity, new SandboxModeTag
+                                {
+                                    SteamId = steamId,
+                                    ActivatedAt = (float)DateTime.UtcNow.TimeOfDay.TotalSeconds
+                                });
+                                VAutoLogger.LogInfo($"[{LogSource}] ✅ Active SandboxModeTag for {steamId}");
+                            }
+                        }
+                    }
+                }
+            }
+            catch (Exception ex)
+            {
+                VAutoLogger.LogException(ex);
+            }
+        }
+
+        [HarmonyPostfix]
+        [HarmonyPatch("OnUpdate")]
+        public static void Postfix(BuffSystem_Spawn_Server __instance)
+        {
+            try
+            {
+                if (!ArenaTracker.IsAnyPlayerInArena) return;
+                var em = UnifiedCore.EntityManager;
+                if (em == null) return;
+
+                var pendingBosses = ArenaTracker.GetPendingBosses();
+                foreach (var boss in pendingBosses)
+                {
+                    if (!em.Exists(boss)) 
+                    { 
+                        ArenaTracker.RemovePendingBoss(boss); 
+                        continue; 
+                    }
+
+                    // Schedule delayed despawn (2s) to allow death animations
+                    if (!em.HasComponent<PendingDespawn>(boss))
+                    {
+                        em.AddComponentData(boss, new PendingDespawn
+                        {
+                            DespawnAt = (float)DateTime.UtcNow.TimeOfDay.TotalSeconds + 2.0f,
+                            Reason = "SandboxCleanup"
+                        });
+                        VAutoLogger.LogDebug($"[{LogSource}] ⏱️ Scheduled PendingDespawn for boss (2s delay)");
+                    }
+                }
+            }
+            catch (Exception ex)
+            {
+                VAutoLogger.LogException(ex);
+            }
+        }
+    }
+}
diff --git a/CycleBorn/Services/Lifecycle/Handlers/PlayerEndgameUnlockHandler.cs b/CycleBorn/Services/Lifecycle/Handlers/PlayerEndgameUnlockHandler.cs
new file mode 100644
index 0000000..68739da
--- /dev/null
+++ b/CycleBorn/Services/Lifecycle/Handlers/PlayerEndgameUnlockHandler.cs
@@ -0,0 +1,95 @@
+using Unity.Entities;
+using VAutomationCore.Core;
+
+namespace VAuto.Core.Lifecycle.Handlers
+{
+    /// <summary>
+    /// Enables sandbox mode + unlocks all VBlood content for arena session.
+    /// This handler gives the player all abilities, tech, recipes, and forms.
+    /// </summary>
+    public class PlayerEndgameUnlockHandler : LifecycleActionHandler
+    {
+        private const string LogSource = "PlayerEndgameUnlockHandler";
+
+        public bool Execute(LifecycleAction action, LifecycleContext context)
+        {
+            var em = VAutoCore.EntityManager;
+            var user = context.UserEntity;
+            var character = context.CharacterEntity;
+
+            if (user == Entity.Null)
+            {
+                VAutoLogger.LogWarning($"[{LogSource}] User entity is null");
+                return false;
+            }
+
+            try
+            {
+                // Enable debug/sandbox unlock mode on User
+                if (em.HasComponent<User>(user))
+                {
+                    var userData = em.GetComponentData<User>(user);
+                    // Set debug flags if available - these may need adjustment based on actual components
+                    VAutoLogger.LogInfo($"[{LogSource}] Sandbox mode enabled for user");
+                    em.SetComponentData(user, userData);
+                }
+
+                // Apply all unlocks via SandboxUnlockUtility
+                SandboxUnlockUtility.UnlockEverythingForPlayer(user);
+
+                VAutoLogger.LogInfo($"[{LogSource}] ✅ Endgame unlocks applied for arena session");
+                return true;
+            }
+            catch (System.Exception ex)
+            {
+                VAutoLogger.LogException(ex);
+                VAutoLogger.LogError($"[{LogSource}] Failed: {ex.Message}");
+                return false;
+            }
+        }
+    }
+
+    /// <summary>
+    /// Restores normal progression on arena exit.
+    /// Removes all sandbox unlocks and restores vanilla progression state.
+    /// </summary>
+    public class PlayerEndgameLockHandler : LifecycleActionHandler
+    {
+        private const string LogSource = "PlayerEndgameLockHandler";
+
+        public bool Execute(LifecycleAction action, LifecycleContext context)
+        {
+            var em = VAutoCore.EntityManager;
+            var user = context.UserEntity;
+
+            if (user == Entity.Null)
+            {
+                VAutoLogger.LogWarning($"[{LogSource}] User entity is null");
+                return false;
+            }
+
+            try
+            {
+                // Disable debug/sandbox unlock mode
+                if (em.HasComponent<User>(user))
+                {
+                    var userData = em.GetComponentData<User>(user);
+                    VAutoLogger.LogInfo($"[{LogSource}] Sandbox mode disabled for user");
+                    em.SetComponentData(user, userData);
+                }
+
+                // Clear temporary unlocks
+                SandboxUnlockUtility.ResetTemporaryUnlocks(user);
+
+                VAutoLogger.LogInfo($"[{LogSource}] ✅ Player progression returned to vanilla state");
+                return true;
+            }
+            catch (System.Exception ex)
+            {
+                VAutoLogger.LogException(ex);
+                VAutoLogger.LogError($"[{LogSource}] Failed: {ex.Message}");
+                return false;
+            }
+        }
+    }
+}
diff --git a/CycleBorn/Services/Lifecycle/Handlers/SandboxUnlockUtility.cs b/CycleBorn/Services/Lifecycle/Handlers/SandboxUnlockUtility.cs
new file mode 100644
index 0000000..a8c2212
--- /dev/null
+++ b/CycleBorn/Services/Lifecycle/Handlers/SandboxUnlockUtility.cs
@@ -0,0 +1,262 @@
+using System.Collections.Generic;
+using Unity.Entities;
+using Unity.Collections;
+using ProjectM;
+using VAutomationCore.Core;
+
+namespace VAuto.Core.Lifecycle.Handlers
+{
+    /// <summary>
+    /// Simulates the same progression changes that VBlood feeds perform.
+    /// Unlocks all tech, recipes, powers, and forms for sandbox gameplay.
+    /// Uses DebugEventBridge for proper game integration with backup/restore support.
+    /// 
+    /// Usage:
+    /// - Call OnPlayerIsInZone(player) while player is in sandbox arena
+    /// - Call OnPlayerExitZone(player) when player exits sandbox arena
+    /// 
+    /// Thread Safety:
+    /// - All methods are thread-safe via DebugEventBridge's ConcurrentDictionary usage
+    /// - Atomic backup creation ensures only one backup per SteamId
+    /// - Concurrent enter/exit operations are handled safely
+    /// </summary>
+    public static class SandboxUnlockUtility
+    {
+        private const string LogSource = "SandboxUnlockUtility";
+
+        /// <summary>
+        /// Called while a player is in a sandbox zone.
+        /// Creates a backup if needed, then applies unlocks via game events.
+        /// </summary>
+        /// <param name="player">The player entity.</param>
+        public static void OnPlayerIsInZone(Entity player)
+        {
+            ValidateParameters(player);
+
+            // Direct is-in-zone flow (idempotent)
+            DebugEventBridge.OnPlayerIsInZone(player);
+        }
+
+        /// <summary>
+        /// Backward-compatible wrapper. Prefer OnPlayerIsInZone.
+        /// </summary>
+        [System.Obsolete("Use OnPlayerIsInZone for sandbox flow")]
+        public static void OnPlayerEnterZone(Entity player)
+        {
+            OnPlayerIsInZone(player);
+        }
+
+        /// <summary>
+        /// Called when a player exits a sandbox zone.
+        /// Restores from backup if exists, otherwise uses fallback restoration.
+        /// </summary>
+        /// <param name="player">The player entity.</param>
+        public static void OnPlayerExitZone(Entity player)
+        {
+            ValidateParameters(player);
+
+            // Use DebugEventBridge's static convenience methods
+            DebugEventBridge.OnPlayerExitZone(player);
+        }
+
+        /// <summary>
+        /// Unlocks all VBlood content for the player.
+        /// Legacy method - prefer using OnPlayerIsInZone for proper backup/restore.
+        /// </summary>
+        /// <param name="user">The player entity.</param>
+        [System.Obsolete("Use OnPlayerIsInZone instead for proper backup/restore support")]
+        public static void UnlockEverythingForPlayer(Entity user)
+        {
+            if (!VAutomationCore.Core.UnifiedCore.EntityExists(user))
+            {
+                VAutoLogger.LogWarning($"[{LogSource}] User entity does not exist");
+                return;
+            }
+
+            // Route to bridge authority to avoid direct ECS mutations in sandbox utility.
+            DebugEventBridge.OnPlayerIsInZone(user);
+            VAutoLogger.LogInfo($"[{LogSource}] ✅ Legacy unlock request routed to DebugEventBridge");
+        }
+
+        /// <summary>
+        /// Resets all temporary unlocks applied during arena session.
+        /// Legacy method - prefer using OnPlayerExitZone for proper backup/restore.
+        /// </summary>
+        /// <param name="user">The player entity.</param>
+        [System.Obsolete("Use OnPlayerExitZone instead for proper backup/restore support")]
+        public static void ResetTemporaryUnlocks(Entity user)
+        {
+            if (!VAutomationCore.Core.UnifiedCore.EntityExists(user))
+            {
+                VAutoLogger.LogWarning($"[{LogSource}] User entity does not exist");
+                return;
+            }
+
+            // Route to bridge authority to avoid direct ECS restore mutations in sandbox utility.
+            DebugEventBridge.OnPlayerExitZone(user);
+            VAutoLogger.LogInfo($"[{LogSource}] ✅ Legacy reset request routed to DebugEventBridge");
+        }
+
+        #region Validation and Helpers
+
+        private static void ValidateParameters(Entity player)
+        {
+            if (player == Entity.Null)
+            {
+                throw new System.ArgumentException("Player entity cannot be null", nameof(player));
+            }
+
+            if (!VAutomationCore.Core.UnifiedCore.EntityExists(player))
+            {
+                throw new System.ArgumentException("Player entity does not exist", nameof(player));
+            }
+        }
+
+        private static ulong GetSteamId(Entity user)
+        {
+            var em = VAutomationCore.Core.UnifiedCore.EntityManager;
+            
+            if (em.HasComponent<SteamPlayerID>(user))
+            {
+                var steamId = em.GetComponentData<SteamPlayerID>(user);
+                return steamId.SteamId;
+            }
+            return 0;
+        }
+
+        #endregion
+
+        #region Legacy Fallback Methods (disabled by policy)
+
+        /// <summary>
+        /// Fallback unlock method when DebugEventBridge is unavailable.
+        /// </summary>
+        private static void UnlockEverythingForPlayerFallback(Entity user)
+        {
+            VAutoLogger.LogWarning($"[{LogSource}] Direct fallback unlock disabled by sandbox policy");
+        }
+
+        /// <summary>
+        /// Fallback restore method when no backup exists.
+        /// </summary>
+        private static void FallbackRestore(Entity user)
+        {
+            VAutoLogger.LogWarning($"[{LogSource}] Direct fallback restore disabled by sandbox policy");
+        }
+
+        private static void UnlockAllTech(Entity user)
+        {
+            VAutoLogger.LogWarning($"[{LogSource}] UnlockAllTech direct path disabled");
+        }
+
+        private static void UnlockAllRecipes(Entity user)
+        {
+            VAutoLogger.LogWarning($"[{LogSource}] UnlockAllRecipes direct path disabled");
+        }
+
+        private static void UnlockAllPowers(Entity user)
+        {
+            VAutoLogger.LogWarning($"[{LogSource}] UnlockAllPowers direct path disabled");
+        }
+
+        private static void UnlockAllTrophies(Entity user)
+        {
+            VAutoLogger.LogWarning($"[{LogSource}] UnlockAllTrophies direct path disabled");
+        }
+
+        private static void ClearBloodTypes(Entity user)
+        {
+            VAutoLogger.LogWarning($"[{LogSource}] ClearBloodTypes direct path disabled");
+        }
+
+        private static void ClearTechs(Entity user)
+        {
+            VAutoLogger.LogWarning($"[{LogSource}] ClearTechs direct path disabled");
+        }
+
+        private static void ClearRecipes(Entity user)
+        {
+            VAutoLogger.LogWarning($"[{LogSource}] ClearRecipes direct path disabled");
+        }
+
+        private static void ClearPowers(Entity user)
+        {
+            VAutoLogger.LogWarning($"[{LogSource}] ClearPowers direct path disabled");
+        }
+
+        private static void FireUnlockGameplayEvents(Entity user)
+        {
+            VAutoLogger.LogWarning($"[{LogSource}] FireUnlockGameplayEvents direct path disabled");
+        }
+
+        #endregion
+    }
+
+    #region Internal Table Placeholders
+
+    /// <summary>
+    /// Placeholder for tech ID collection. Populate from PrefabIndex.json or TechCollectionSystem.
+    /// </summary>
+    public static class InternalTechTable
+    {
+        public static readonly List<int> AllTechIds = new()
+        {
+            // TODO: Populate with actual tech prefab GUIDs from TechCollectionSystem
+        };
+
+        public static void LoadFromGameData()
+        {
+            // TODO: Implement loading from TechCollectionSystem or JSON
+        }
+    }
+
+    /// <summary>
+    /// Placeholder for recipe ID collection.
+    /// </summary>
+    public static class InternalRecipeTable
+    {
+        public static readonly List<int> AllRecipeIds = new()
+        {
+            // TODO: Populate with actual recipe prefab GUIDs
+        };
+
+        public static void LoadFromGameData()
+        {
+            // TODO: Implement loading from RecipeCollectionSystem
+        }
+    }
+
+    /// <summary>
+    /// Placeholder for power/vampire ability ID collection.
+    /// </summary>
+    public static class InternalPowerTable
+    {
+        public static readonly List<int> AllPowerIds = new()
+        {
+            // TODO: Populate with actual power prefab GUIDs from AbilitySystem
+        };
+
+        public static void LoadFromGameData()
+        {
+            // TODO: Implement loading from PowerCollectionSystem
+        }
+    }
+
+    /// <summary>
+    /// Placeholder for trophy/blood unlock ID collection.
+    /// </summary>
+    public static class InternalTrophyTable
+    {
+        public static readonly List<int> AllTrophyIds = new()
+        {
+            // TODO: Populate with actual trophy prefab GUIDs
+        };
+
+        public static void LoadFromGameData()
+        {
+            // TODO: Implement loading from TrophyCollectionSystem
+        }
+    }
+
+    #endregion
+}
diff --git a/CycleBorn/Services/Lifecycle/Handlers/UnlockMenusHandler.cs b/CycleBorn/Services/Lifecycle/Handlers/UnlockMenusHandler.cs
new file mode 100644
index 0000000..c31a778
--- /dev/null
+++ b/CycleBorn/Services/Lifecycle/Handlers/UnlockMenusHandler.cs
@@ -0,0 +1,126 @@
+using Unity.Entities;
+using ProjectM.Network;
+using VAutomationCore.Core;
+
+namespace VAuto.Core.Lifecycle.Handlers
+{
+    /// <summary>
+    /// Grants full UI menu access during arena session.
+    /// Enables Spellbook, Blood Type selection, and Equipment modification.
+    /// </summary>
+    public class UnlockMenusHandler : LifecycleActionHandler
+    {
+        private const string LogSource = "UnlockMenusHandler";
+
+        public bool Execute(LifecycleAction action, LifecycleContext context)
+        {
+            var em = VAutomationCore.Core.UnifiedCore.EntityManager;
+            var user = context.UserEntity;
+
+            if (user == Entity.Null)
+            {
+                VAutoLogger.LogWarning($"[{LogSource}] User entity is null");
+                return false;
+            }
+
+            try
+            {
+                if (!em.HasComponent<User>(user))
+                {
+                    VAutoLogger.LogWarning($"[{LogSource}] User entity has no User component");
+                    return false;
+                }
+
+                var userData = em.GetComponentData<User>(user);
+
+                // Unlock all UI menus
+                // Note: These field names may vary - adjust based on actual User component structure
+                // Common fields in ProjectM User component:
+                
+                // Unlock spellbook access
+                SetUserFlag(userData, "CanOpenSpellBook", true);
+                
+                // Unlock blood type change
+                SetUserFlag(userData, "CanChangeBloodType", true);
+                
+                // Unlock equipment modification
+                SetUserFlag(userData, "CanModifyEquipment", true);
+                
+                // Unlock castle/building access if needed
+                SetUserFlag(userData, "CanBuildCastle", true);
+
+                em.SetComponentData(user, userData);
+
+                VAutoLogger.LogInfo($"[{LogSource}] ✅ All menus unlocked for user");
+                return true;
+            }
+            catch (System.Exception ex)
+            {
+                VAutoLogger.LogException(ex);
+                VAutoLogger.LogError($"[{LogSource}] Failed: {ex.Message}");
+                return false;
+            }
+        }
+
+        private void SetUserFlag(User userData, string flagName, bool value)
+        {
+            // Placeholder for setting user flags
+            // Actual implementation depends on User component structure
+            VAutoLogger.LogDebug($"[{LogSource}] Setting {flagName} = {value}");
+        }
+    }
+
+    /// <summary>
+    /// Revokes UI menu access on arena exit.
+    /// Restricts menus to default permissions.
+    /// </summary>
+    public class LockMenusHandler : LifecycleActionHandler
+    {
+        private const string LogSource = "LockMenusHandler";
+
+        public bool Execute(LifecycleAction action, LifecycleContext context)
+        {
+            var em = VAutomationCore.Core.UnifiedCore.EntityManager;
+            var user = context.UserEntity;
+
+            if (user == Entity.Null)
+            {
+                VAutoLogger.LogWarning($"[{LogSource}] User entity is null");
+                return false;
+            }
+
+            try
+            {
+                if (!em.HasComponent<User>(user))
+                {
+                    VAutoLogger.LogWarning($"[{LogSource}] User entity has no User component");
+                    return false;
+                }
+
+                var userData = em.GetComponentData<User>(user);
+
+                // Lock all menus
+                SetUserFlag(userData, "CanOpenSpellBook", false);
+                SetUserFlag(userData, "CanChangeBloodType", false);
+                SetUserFlag(userData, "CanModifyEquipment", false);
+                SetUserFlag(userData, "CanBuildCastle", false);
+
+                em.SetComponentData(user, userData);
+
+                VAutoLogger.LogInfo($"[{LogSource}] ✅ All menus relocked for user");
+                return true;
+            }
+            catch (System.Exception ex)
+            {
+                VAutoLogger.LogException(ex);
+                VAutoLogger.LogError($"[{LogSource}] Failed: {ex.Message}");
+                return false;
+            }
+        }
+
+        private void SetUserFlag(User userData, string flagName, bool value)
+        {
+            VAutoLogger.LogDebug($"[{LogSource}] Setting {flagName} = {value}");
+        }
+    }
+}
diff --git a/CycleBorn/Services/Lifecycle/InputSystemUpdatePatch.cs b/CycleBorn/Services/Lifecycle/InputSystemUpdatePatch.cs
new file mode 100644
index 0000000..cfca545
--- /dev/null
+++ b/CycleBorn/Services/Lifecycle/InputSystemUpdatePatch.cs
@@ -0,0 +1,91 @@
+using HarmonyLib;
+using ProjectM;
+using Unity.Entities;
+using Unity.Collections;
+using UnityEngine;
+
+namespace VLifecycle.Services.Lifecycle
+{
+    /// <summary>
+    /// Patches ClientBootstrapSystem.OnUpdate to momentarily block all game inputs during ZUI interactions.
+    /// Only blocks when explicitly triggered by ZUIInputBlocker.BlockMomentarily().
+    /// </summary>
+    [HarmonyPatch(typeof(ClientBootstrapSystem), nameof(ClientBootstrapSystem.OnUpdate))]
+    public static class InputSystemUpdatePatch
+    {
+        private static bool _previousBlockState = false;
+
+        [HarmonyPostfix]
+        public static void Postfix(ClientBootstrapSystem __instance)
+        {
+            try
+            {
+                var shouldBlock = ZUIInputBlocker.ShouldBlock;
+
+                // CRITICAL: Only do something if the block state has CHANGED
+                if (shouldBlock == _previousBlockState)
+                {
+                    return; // No change, do nothing
+                }
+
+                Plugin.Log.LogDebug($"[ZUI] Block state changed: {_previousBlockState} -> {shouldBlock}");
+                _previousBlockState = shouldBlock;
+
+                var entityManager = __instance.EntityManager;
+                var playerQuery = entityManager.CreateEntityQuery(
+                    ComponentType.ReadOnly<PlayerCharacter>(),
+                    ComponentType.ReadOnly<EntityInput>()
+                );
+
+                if (playerQuery.IsEmpty)
+                {
+                    playerQuery.Dispose();
+                    return;
+                }
+
+                var playerEntities = playerQuery.ToEntityArray(Allocator.Temp);
+
+                foreach (var playerEntity in playerEntities)
+                {
+                    if (shouldBlock)
+                    {
+                        // BLOCK: Add components
+                        if (!entityManager.HasComponent<InputActionsDisabled>(playerEntity))
+                        {
+                            entityManager.AddComponentData(playerEntity, new InputActionsDisabled());
+                            Plugin.Log.LogDebug("[ZUI] Added InputActionsDisabled");
+                        }
+
+                        if (!entityManager.HasComponent<Disabled>(playerEntity))
+                        {
+                            entityManager.AddComponentData(playerEntity, new Disabled());
+                            Plugin.Log.LogDebug("[ZUI] Added Disabled");
+                        }
+                    }
+                    else
+                    {
+                        // UNBLOCK: Remove components
+                        if (entityManager.HasComponent<InputActionsDisabled>(playerEntity))
+                        {
+                            entityManager.RemoveComponent<InputActionsDisabled>(playerEntity);
+                            Plugin.Log.LogDebug("[ZUI] Removed InputActionsDisabled");
+                        }
+
+                        if (entityManager.HasComponent<Disabled>(playerEntity))
+                        {
+                            entityManager.RemoveComponent<Disabled>(playerEntity);
+                            Plugin.Log.LogDebug("[ZUI] Removed Disabled");
+                        }
+                    }
+                }
+
+                playerEntities.Dispose();
+                playerQuery.Dispose();
+            }
+            catch (System.Exception ex)
+            {
+                Plugin.Log.LogError($"[ZUI] Error in input blocking: {ex}");
+            }
+        }
+    }
+}
diff --git a/CycleBorn/Services/Lifecycle/LifecycleActionHandlers.cs b/CycleBorn/Services/Lifecycle/LifecycleActionHandlers.cs
index ef10250..de58368 100644
--- a/CycleBorn/Services/Lifecycle/LifecycleActionHandlers.cs
+++ b/CycleBorn/Services/Lifecycle/LifecycleActionHandlers.cs
@@ -413,99 +413,6 @@ namespace VAuto.Core.Lifecycle
         }
     }
 
-    /// <summary>
-    /// Captures current position as return point for later teleport_return.
-    /// </summary>
-    public class CaptureReturnPositionHandler : LifecycleActionHandler
-    {
-        private const string LogSource = "CaptureReturnPositionHandler";
-
-        public bool Execute(LifecycleAction action, LifecycleContext context)
-        {
-            try
-            {
-                var em = UnifiedCore.EntityManager;
-                var character = context.CharacterEntity;
-                if (character != Entity.Null && em.Exists(character) && em.HasComponent<LocalTransform>(character))
-                {
-                    var pos = em.GetComponentData<LocalTransform>(character).Position;
-                    context.StoredData["ReturnPosition"] = pos;
-                    UnifiedCore.LogInfo($"[{LogSource}] Captured return position: ({pos.x:F0}, {pos.y:F0}, {pos.z:F0})");
-                    return true;
-                }
-
-                context.StoredData["ReturnPosition"] = context.Position;
-                UnifiedCore.LogInfo($"[{LogSource}] Captured fallback return position from context");
-                return true;
-            }
-            catch (Exception ex)
-            {
-                UnifiedCore.LogException(ex);
-                VLifecycle.Plugin.Log?.LogError($"[CaptureReturnPosition] Failed: {ex.Message}");
-                return false;
-            }
-        }
-    }
-
-    /// <summary>
-    /// Returns player to captured return position, if present.
-    /// </summary>
-    public class TeleportReturnHandler : LifecycleActionHandler
-    {
-        private const string LogSource = "TeleportReturnHandler";
-
-        public bool Execute(LifecycleAction action, LifecycleContext context)
-        {
-            try
-            {
-                var character = context.CharacterEntity;
-                var em = UnifiedCore.EntityManager;
-                if (character == Entity.Null || !em.Exists(character))
-                {
-                    UnifiedCore.LogError($"[{LogSource}] Character entity is null or does not exist");
-                    return false;
-                }
-
-                if (context.StoredData.TryGetValue("ReturnPosition", out var returnObj) && returnObj is float3 returnPos)
-                {
-                    if (GameActionService.TryTeleport(character, returnPos))
-                    {
-                        UnifiedCore.LogInfo($"[{LogSource}] Returned player to ({returnPos.x:F0}, {returnPos.y:F0}, {returnPos.z:F0})");
-                        return true;
-                    }
-                }
-
-                UnifiedCore.LogWarning($"[{LogSource}] No return position found; teleport return skipped");
-                return true;
-            }
-            catch (Exception ex)
-            {
-                UnifiedCore.LogException(ex);
-                VLifecycle.Plugin.Log?.LogError($"[TeleportReturn] Failed: {ex.Message}");
-                return false;
-            }
-        }
-    }
-
-    /// <summary>
-    /// Generic no-op handler for action tokens that are intentionally supported as placeholders.
-    /// </summary>
-    public class NoOpLifecycleActionHandler : LifecycleActionHandler
-    {
-        private readonly string _actionName;
-
-        public NoOpLifecycleActionHandler(string actionName)
-        {
-            _actionName = actionName ?? "noop";
-        }
-
-        public bool Execute(LifecycleAction action, LifecycleContext context)
-        {
-            UnifiedCore.LogInfo($"[NoOpLifecycleActionHandler] Action '{_actionName}' acknowledged (no-op)");
-            return true;
-        }
-    }
-
     /// <summary>
     /// Handles store actions - stores values in context
     /// </summary>
diff --git a/CycleBorn/Services/Lifecycle/TrapLifecycleFallbackTypes.cs b/CycleBorn/Services/Lifecycle/TrapLifecycleFallbackTypes.cs
deleted file mode 100644
index b4f0595..0000000
--- a/CycleBorn/Services/Lifecycle/TrapLifecycleFallbackTypes.cs
+++ /dev/null
@@ -1,45 +0,0 @@
-using Unity.Mathematics;
-
-namespace VAutomationCore.Core.TrapLifecycle
-{
-    /// <summary>
-    /// Fallback trap lifecycle contracts used when shared trap lifecycle package is unavailable.
-    /// </summary>
-    public interface ITrapLifecyclePolicy
-    {
-        bool IsEnabled { get; }
-        TrapLifecycleDecision OnBeforeLifecycleEnter(TrapLifecycleContext ctx);
-        TrapLifecycleDecision OnBeforeLifecycleExit(TrapLifecycleContext ctx);
-    }
-
-    public sealed class TrapLifecycleContext
-    {
-        public ulong CharacterId { get; set; }
-        public string ZoneId { get; set; } = string.Empty;
-        public float3 Position { get; set; }
-        public string LifecycleStage { get; set; } = string.Empty;
-    }
-
-    public readonly struct TrapLifecycleDecision
-    {
-        public bool OverrideTriggered { get; init; }
-        public bool ForceBuffClearOnExit { get; init; }
-        public string Reason { get; init; }
-
-        public static TrapLifecycleDecision None => new TrapLifecycleDecision
-        {
-            OverrideTriggered = false,
-            ForceBuffClearOnExit = false,
-            Reason = string.Empty
-        };
-    }
-
-    public static class TrapPolicyResolver
-    {
-        public static bool AreOverridesEnabled() => false;
-
-        public static TrapLifecycleDecision EvaluateEnter(TrapLifecycleContext _) => TrapLifecycleDecision.None;
-
-        public static TrapLifecycleDecision EvaluateExit(TrapLifecycleContext _) => TrapLifecycleDecision.None;
-    }
-}
diff --git a/CycleBorn/Services/Lifecycle/ZoneTrackingHelper.cs b/CycleBorn/Services/Lifecycle/ZoneTrackingHelper.cs
new file mode 100644
index 0000000..cd41c63
--- /dev/null
+++ b/CycleBorn/Services/Lifecycle/ZoneTrackingHelper.cs
@@ -0,0 +1,368 @@
+using System;
+using System.Collections.Generic;
+using BepInEx.Logging;
+using Unity.Collections;
+using Unity.Entities;
+using Unity.Mathematics;
+using Unity.Transforms;
+
+namespace VAuto.Core.Lifecycle
+{
+    /// <summary>
+    /// Helper class for ECS-based zone detection and tracking.
+    /// Provides autonomous zone detection without relying on VAutoZone callbacks.
+    /// </summary>
+    public class ZoneTrackingHelper : IDisposable
+    {
+        private const float ExitRadiusTolerance = 1f;
+        private readonly EntityManager _entityManager;
+        private readonly ManualLogSource _log;
+        
+        // Native collections for player tracking
+        private NativeHashMap<Entity, float3> _playerPositions;
+        private NativeHashMap<Entity, Entity> _playerCurrentZone;
+        private NativeHashMap<Entity, float> _playerLastTransitionTime;
+        
+        // Zone definitions
+        private NativeList<ZoneDefinition> _zoneDefinitions;
+        
+        private bool _isInitialized;
+        private readonly object _lock = new object();
+
+        /// <summary>
+        /// Represents a zone definition for distance-based detection.
+        /// </summary>
+        public struct ZoneDefinition
+        {
+            public Entity ZoneEntity;
+            public float3 Center;
+            public float Radius;
+            public FixedString32Bytes ZoneId;
+            public bool IsLifecycleZone;
+        }
+
+        /// <summary>
+        /// Event fired when a player transitions between zones.
+        /// </summary>
+        public event Action<Entity, Entity, Entity> OnPlayerZoneTransition;
+
+        /// <summary>
+        /// Event fired when a player enters a lifecycle zone.
+        /// </summary>
+        public event Action<Entity, Entity> OnPlayerEnterLifecycleZone;
+
+        /// <summary>
+        /// Event fired when a player exits a lifecycle zone.
+        /// </summary>
+        public event Action<Entity, Entity> OnPlayerExitLifecycleZone;
+
+        public ZoneTrackingHelper(EntityManager entityManager, ManualLogSource log)
+        {
+            _entityManager = entityManager;
+            _log = log;
+        }
+
+        /// <summary>
+        /// Initialize the zone tracking helper.
+        /// </summary>
+        public void Initialize()
+        {
+            lock (_lock)
+            {
+                if (_isInitialized) return;
+
+                _playerPositions = new NativeHashMap<Entity, float3>(100, Allocator.Persistent);
+                _playerCurrentZone = new NativeHashMap<Entity, Entity>(100, Allocator.Persistent);
+                _playerLastTransitionTime = new NativeHashMap<Entity, float>(100, Allocator.Persistent);
+                _zoneDefinitions = new NativeList<ZoneDefinition>(10, Allocator.Persistent);
+
+                _isInitialized = true;
+                _log.LogInfo("[ZoneTrackingHelper] Initialized with NativeHashMap tracking");
+            }
+        }
+
+        /// <summary>
+        /// Register a zone definition for tracking.
+        /// </summary>
+        public void RegisterZone(Entity zoneEntity, float3 center, float radius, string zoneId, bool isLifecycleZone = false)
+        {
+            if (!_isInitialized)
+            {
+                _log.LogWarning("[ZoneTrackingHelper] Not initialized, cannot register zone");
+                return;
+            }
+
+            var definition = new ZoneDefinition
+            {
+                ZoneEntity = zoneEntity,
+                Center = center,
+                Radius = radius,
+                ZoneId = new FixedString32Bytes(zoneId ?? "Unknown"),
+                IsLifecycleZone = isLifecycleZone
+            };
+
+            lock (_lock)
+            {
+                _zoneDefinitions.Add(definition);
+            }
+
+            _log.LogInfo($"[ZoneTrackingHelper] Registered zone: {definition.ZoneId} at ({definition.Center.x:F0}, {definition.Center.y:F0}, {definition.Center.z:F0}) with radius {definition.Radius:F0}");
+        }
+
+        /// <summary>
+        /// Unregister a zone from tracking.
+        /// </summary>
+        public void UnregisterZone(string zoneId)
+        {
+            if (!_isInitialized) return;
+
+            lock (_lock)
+            {
+                for (int i = _zoneDefinitions.Length - 1; i >= 0; i--)
+                {
+                    if (_zoneDefinitions[i].ZoneId == zoneId)
+                    {
+                        _zoneDefinitions.RemoveAt(i);
+                        _log.LogInfo($"[ZoneTrackingHelper] Unregistered zone: {zoneId}");
+                        break;
+                    }
+                }
+            }
+        }
+
+        /// <summary>
+        /// Update zone tracking for all players.
+        /// Should be called every frame or on a regular interval.
+        /// </summary>
+        public void UpdateTracking()
+        {
+            if (!_isInitialized) return;
+
+            var playerQuery = _entityManager.CreateEntityQuery(
+                ComponentType.ReadOnly<PlayerCharacter>(),
+                ComponentType.ReadOnly<LocalTransform>()
+            );
+
+            var players = playerQuery.ToEntityArray(Allocator.Temp);
+
+            foreach (var player in players)
+            {
+                if (!_entityManager.HasComponent<LocalTransform>(player)) continue;
+
+                var position = _entityManager.GetComponentData<LocalTransform>(player).Position;
+                UpdatePlayerZone(player, position);
+            }
+
+            players.Dispose();
+        }
+
+        /// <summary>
+        /// Update zone tracking for a specific player.
+        /// </summary>
+        private void UpdatePlayerZone(Entity player, float3 position)
+        {
+            lock (_lock)
+            {
+                // Update player position
+                if (_playerPositions.ContainsKey(player))
+                {
+                    _playerPositions[player] = position;
+                }
+                else
+                {
+                    _playerPositions.TryAdd(player, position);
+                }
+
+                // Find which zone the player is in
+                Entity newZone = Entity.Null;
+                Entity previousZone = Entity.Null;
+
+                if (_playerCurrentZone.TryGetValue(player, out previousZone))
+                {
+                    // Check if player is still in previous zone using tolerant exit check.
+                    // Enter uses strict radius through FindPlayerZone.
+                    if (previousZone != Entity.Null && IsInZone(previousZone, position, ExitRadiusTolerance))
+                    {
+                        newZone = previousZone;
+                    }
+                }
+
+                // Find new zone if needed
+                if (newZone == Entity.Null)
+                {
+                    newZone = FindPlayerZone(position);
+                }
+
+                // Handle zone transition
+                if (newZone != previousZone)
+                {
+                    _playerCurrentZone[player] = newZone;
+                    var transitionTime = (float)SystemAPI.Time.ElapsedTime;
+                    
+                    if (_playerLastTransitionTime.ContainsKey(player))
+                    {
+                        _playerLastTransitionTime[player] = transitionTime;
+                    }
+                    else
+                    {
+                        _playerLastTransitionTime.TryAdd(player, transitionTime);
+                    }
+
+                    _log.LogDebug($"[ZoneTrackingHelper] Player {player} transitioned from zone {previousZone} to zone {newZone}");
+
+                    // Fire transition event
+                    OnPlayerZoneTransition?.Invoke(player, previousZone, newZone);
+
+                    // Check if entering/exiting lifecycle zone
+                    if (IsLifecycleZone(newZone))
+                    {
+                        OnPlayerEnterLifecycleZone?.Invoke(player, newZone);
+                    }
+
+                    if (IsLifecycleZone(previousZone))
+                    {
+                        OnPlayerExitLifecycleZone?.Invoke(player, previousZone);
+                    }
+                }
+            }
+        }
+
+        /// <summary>
+        /// Check if a position is within a zone.
+        /// </summary>
+        public bool IsInZone(Entity zoneEntity, float3 position)
+        {
+            return IsInZone(zoneEntity, position, 0f);
+        }
+
+        /// <summary>
+        /// Check if a position is within a zone with optional radius tolerance.
+        /// </summary>
+        public bool IsInZone(Entity zoneEntity, float3 position, float extraRadius)
+        {
+            lock (_lock)
+            {
+                foreach (var zone in _zoneDefinitions)
+                {
+                    if (zone.ZoneEntity == zoneEntity)
+                    {
+                        var radius = math.max(0f, zone.Radius + extraRadius);
+                        return CheckDistance(zone.Center, position) <= radius;
+                    }
+                }
+            }
+            return false;
+        }
+
+        /// <summary>
+        /// Find the zone containing a position.
+        /// Returns Entity.Null if no zone found.
+        /// </summary>
+        public Entity FindPlayerZone(float3 position)
+        {
+            lock (_lock)
+            {
+                foreach (var zone in _zoneDefinitions)
+                {
+                    if (CheckDistance(zone.Center, position) <= zone.Radius)
+                    {
+                        return zone.ZoneEntity;
+                    }
+                }
+            }
+            return Entity.Null;
+        }
+
+        /// <summary>
+        /// Check if a zone entity is a lifecycle zone.
+        /// </summary>
+        public bool IsLifecycleZone(Entity zoneEntity)
+        {
+            if (zoneEntity == Entity.Null) return false;
+
+            lock (_lock)
+            {
+                foreach (var zone in _zoneDefinitions)
+                {
+                    if (zone.ZoneEntity == zoneEntity)
+                    {
+                        return zone.IsLifecycleZone;
+                    }
+                }
+            }
+            return false;
+        }
+
+        /// <summary>
+        /// Get the current zone for a player.
+        /// Returns Entity.Null if player not tracked.
+        /// </summary>
+        public Entity GetPlayerZone(Entity player)
+        {
+            if (_playerCurrentZone.TryGetValue(player, out var zone))
+            {
+                return zone;
+            }
+            return Entity.Null;
+        }
+
+        /// <summary>
+        /// Get the last known position for a player.
+        /// Returns default(float3) if player not tracked.
+        /// </summary>
+        public float3 GetPlayerPosition(Entity player)
+        {
+            if (_playerPositions.TryGetValue(player, out var position))
+            {
+                return position;
+            }
+            return default;
+        }
+
+        /// <summary>
+        /// Check if a player has recently transitioned zones.
+        /// Useful for cooldown management.
+        /// </summary>
+        public bool IsPlayerInCooldown(Entity player, float cooldownSeconds)
+        {
+            if (_playerLastTransitionTime.TryGetValue(player, out var lastTransition))
+            {
+                return (float)SystemAPI.Time.ElapsedTime - lastTransition < cooldownSeconds;
+            }
+            return false;
+        }
+
+        /// <summary>
+        /// Get all tracked players.
+        /// </summary>
+        public NativeArray<Entity> GetTrackedPlayers(Allocator allocator)
+        {
+            var keys = _playerPositions.GetKeyArray(allocator);
+            return keys;
+        }
+
+        /// <summary>
+        /// Calculate distance between two positions.
+        /// </summary>
+        private float CheckDistance(float3 a, float3 b)
+        {
+            return math.distance(a, b);
+        }
+
+        /// <summary>
+        /// Dispose native collections.
+        /// </summary>
+        public void Dispose()
+        {
+            lock (_lock)
+            {
+                if (_playerPositions.IsCreated) _playerPositions.Dispose();
+                if (_playerCurrentZone.IsCreated) _playerCurrentZone.Dispose();
+                if (_playerLastTransitionTime.IsCreated) _playerLastTransitionTime.Dispose();
+                if (_zoneDefinitions.IsCreated) _zoneDefinitions.Dispose();
+                _isInitialized = false;
+                _log.LogInfo("[ZoneTrackingHelper] Disposed");
+            }
+        }
+    }
+}
diff --git a/CycleBorn/Vlifecycle.csproj b/CycleBorn/Vlifecycle.csproj
index 5f7af31..9ae9323 100644
--- a/CycleBorn/Vlifecycle.csproj
+++ b/CycleBorn/Vlifecycle.csproj
@@ -49,9 +49,6 @@
   </ItemGroup>
 
   <ItemGroup>
-    <Content Include="Cycleborn.lifecycle.json">
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-    </Content>
     <Content Include="Configuration\pvp_item.json">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
@@ -66,11 +63,16 @@
     <Compile Remove="Services\Interfaces\IService.cs" />
     <!-- Exclude in-game only code from headless compilation -->
     <Compile Remove="Commands\**\*.cs" />
+    <Compile Remove="Services\Lifecycle\Handlers\**\*.cs" />
     <Compile Remove="Services\Lifecycle\ConnectionEventPatches.cs" />
     <Compile Remove="Services\Lifecycle\InputSystemUpdatePatch.cs" />
     <Compile Remove="Services\Lifecycle\PatchBuffSystemSpawnServer.cs" />
     <Compile Remove="Services\Lifecycle\ZUIInputBlocker.cs" />
     <Compile Remove="Services\Lifecycle\ZUISpellMenu.cs" />
+    <!-- Files that depend on excluded handlers -->
+    <Compile Remove="Services\Lifecycle\ArenaLifecycleManager.cs" />
+    <Compile Remove="Services\Lifecycle\EnhancedArenaSnapshotLifecycleService.cs" />
+    <Compile Remove="Services\Lifecycle\ZoneTrackingHelper.cs" />
     <!-- Exclude non-headless lifecycle command file -->
     <Compile Remove="Commands\LifecycleCommands.cs" />
     <Compile Remove="Models\ZoneDefinition.cs" />
diff --git a/CycleBorn/Vlifecycle.sln b/CycleBorn/Vlifecycle.sln
index e69de29..c938e49 100644
--- a/CycleBorn/Vlifecycle.sln
+++ b/CycleBorn/Vlifecycle.sln
@@ -0,0 +1,24 @@
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio Version 17
+VisualStudioVersion = 17.5.2.0
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Vlifecycle", "Vlifecycle.csproj", "{28EACBC6-A4C4-CDE8-6EDB-66207AC002E9}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Any CPU = Debug|Any CPU
+		Release|Any CPU = Release|Any CPU
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{28EACBC6-A4C4-CDE8-6EDB-66207AC002E9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{28EACBC6-A4C4-CDE8-6EDB-66207AC002E9}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{28EACBC6-A4C4-CDE8-6EDB-66207AC002E9}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{28EACBC6-A4C4-CDE8-6EDB-66207AC002E9}.Release|Any CPU.Build.0 = Release|Any CPU
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+		SolutionGuid = {B9D851FD-F55E-41EB-AD65-DAF172EAC77C}
+	EndGlobalSection
+EndGlobal
diff --git a/Patches/BuffSpawnServerPatch.cs b/Patches/BuffSpawnServerPatch.cs
new file mode 100644
index 0000000..c1ef43f
--- /dev/null
+++ b/Patches/BuffSpawnServerPatch.cs
@@ -0,0 +1,101 @@
+using System;
+using HarmonyLib;
+using ProjectM;
+using Unity.Entities;
+using VAutomationCore.Core.Events;
+using VAutomationCore.Core.Logging;
+
+namespace VAutomationCore.Patches
+{
+    /// <summary>
+    /// Patch for Buff spawning to track when buffs are applied to entities.
+    /// Useful for tracking buff effects, durations, and stacks.
+    /// </summary>
+    [HarmonyPatch(typeof(Buff), nameof(Buff.Initialize))]
+    internal static class BuffSpawnServerPatch
+    {
+        public static event EventHandler<BuffEventArgs> OnBuffInitialized;
+        
+        public class BuffEventArgs : EventArgs
+        {
+            public Entity Owner { get; set; }
+            public Entity Source { get; set; }
+            public PrefabGUID BuffGuid { get; set; }
+            public float Duration { get; set; }
+            public bool IsExtended { get; set; }
+        }
+
+        [HarmonyPrefix]
+        static bool InitializePrefix(Buff __instance, Entity owner, Entity sourceEntity)
+        {
+            try
+            {
+                var args = new BuffEventArgs
+                {
+                    Owner = owner,
+                    Source = sourceEntity,
+                    BuffGuid = __instance.PrefabGuid,
+                    Duration = __instance.Duration,
+                    IsExtended = __instance.IsExtended
+                };
+
+                OnBuffInitialized?.Invoke(__instance, args);
+                TypedEventBus.Publish(new BuffInitializedEvent
+                {
+                    Owner = args.Owner,
+                    Source = args.Source,
+                    BuffGuid = args.BuffGuid,
+                    Duration = args.Duration,
+                    IsExtended = args.IsExtended
+                });
+            }
+            catch (Exception ex)
+            {
+                CoreLogger.LogException("Error in buff initialize prefix", ex);
+            }
+
+            return true; // Continue with original method
+        }
+    }
+
+    /// <summary>
+    /// Patch for Buff destruction to track when buffs are removed.
+    /// </summary>
+    [HarmonyPatch(typeof(Buff), nameof(Buff.Destroy))]
+    internal static class BuffDestroyPatch
+    {
+        public static event EventHandler<BuffEventArgs> OnBuffDestroyed;
+        
+        public class BuffEventArgs : EventArgs
+        {
+            public Entity Owner { get; set; }
+            public PrefabGUID BuffGuid { get; set; }
+        }
+
+        [HarmonyPrefix]
+        static bool DestroyPrefix(Buff __instance, Entity owner)
+        {
+            try
+            {
+                var args = new BuffEventArgs
+                {
+                    Owner = owner,
+                    BuffGuid = __instance.PrefabGuid
+                };
+
+                OnBuffDestroyed?.Invoke(__instance, args);
+                TypedEventBus.Publish(new BuffDestroyedEvent
+                {
+                    Owner = args.Owner,
+                    BuffGuid = args.BuffGuid
+                });
+            }
+            catch (Exception ex)
+            {
+                CoreLogger.LogException("Error in buff destroy prefix", ex);
+            }
+
+            return true; // Continue with original method
+        }
+    }
+}
diff --git a/Patches/DeathEventSystemPatch.cs b/Patches/DeathEventSystemPatch.cs
new file mode 100644
index 0000000..682093d
--- /dev/null
+++ b/Patches/DeathEventSystemPatch.cs
@@ -0,0 +1,72 @@
+using System;
+using HarmonyLib;
+using ProjectM;
+using Unity.Collections;
+using Unity.Entities;
+using VAutomationCore.Core;
+using VAutomationCore.Core.Events;
+using VAutomationCore.Core.Logging;
+
+namespace VAutomationCore.Patches
+{
+    /// <summary>
+    /// Patch for DeathEventListenerSystem to track death events.
+    /// Provides events for kills, deaths, and VBlood consumption.
+    /// </summary>
+    [HarmonyPatch]
+    internal static class DeathEventSystemPatch
+    {
+        public static event EventHandler<DeathEventArgs> OnDeathEvent;
+        
+        public class DeathEventArgs : EventArgs
+        {
+            public Entity Killer { get; set; }
+            public Entity Victim { get; set; }
+            public StatChangeReason Reason { get; set; }
+            public bool IsPlayerKill { get; set; }
+            public bool IsVBlood { get; set; }
+        }
+
+        [HarmonyPatch(typeof(DeathEventListenerSystem), nameof(DeathEventListenerSystem.OnUpdate))]
+        [HarmonyPostfix]
+        static unsafe void OnUpdatePostfix(DeathEventListenerSystem __instance)
+        {
+            if (!CoreLogger.IsInitialized) return;
+
+            try
+            {
+                using var deathEvents = __instance._DeathEventQuery.ToComponentDataArrayAccessor<DeathEvent>(Allocator.Temp);
+                var killerLookup = __instance.GetComponentLookup<Killer>(true);
+                var vBloodLookup = __instance.GetComponentLookup<VBloodConsumeSource>(true);
+
+                for (int i = 0; i < deathEvents.Length; i++)
+                {
+                    var deathEvent = deathEvents[i];
+                    
+                    var args = new DeathEventArgs
+                    {
+                        Killer = deathEvent.Killer,
+                        Victim = deathEvent.Died,
+                        Reason = deathEvent.StatChangeReason,
+                        IsPlayerKill = killerLookup.HasComponent(deathEvent.Killer),
+                        IsVBlood = vBloodLookup.HasComponent(deathEvent.Died)
+                    };
+
+                    OnDeathEvent?.Invoke(__instance, args);
+                    TypedEventBus.Publish(new DeathOccurredEvent
+                    {
+                        Killer = args.Killer,
+                        Victim = args.Victim,
+                        Reason = args.Reason,
+                        IsPlayerKill = args.IsPlayerKill,
+                        IsVBlood = args.IsVBlood
+                    });
+                }
+            }
+            catch (Exception ex)
+            {
+                CoreLogger.LogException("Error processing death events", ex);
+            }
+        }
+    }
+}
diff --git a/Patches/ServerBootstrapSystemPatch.cs b/Patches/ServerBootstrapSystemPatch.cs
new file mode 100644
index 0000000..0d326fb
--- /dev/null
+++ b/Patches/ServerBootstrapSystemPatch.cs
@@ -0,0 +1,87 @@
+using System;
+using HarmonyLib;
+using ProjectM;
+using Unity.Entities;
+using VAutomationCore.Core.Events;
+using VAutomationCore.Core.Logging;
+
+namespace VAutomationCore.Patches
+{
+    /// <summary>
+    /// Patch for ServerBootstrapSystem to track world initialization state.
+    /// Provides events for server startup, world ready, and shutdown.
+    /// </summary>
+    [HarmonyPatch(typeof(ServerBootstrapSystem), nameof(ServerBootstrapSystem.OnUpdate))]
+    internal static class ServerBootstrapSystemPatch
+    {
+        public static event EventHandler OnServerStarted;
+        public static event EventHandler OnWorldReady;
+        public static event EventHandler OnServerShutdown;
+        
+        private static bool _hasStarted = false;
+        private static bool _isReady = false;
+
+        [HarmonyPrefix]
+        static void OnUpdatePrefix(ServerBootstrapSystem __instance)
+        {
+            try
+            {
+                // Check if server has started (first update)
+                if (!_hasStarted)
+                {
+                    _hasStarted = true;
+                    OnServerStarted?.Invoke(__instance, EventArgs.Empty);
+                    TypedEventBus.Publish(new ServerStartedEvent());
+                    CoreLogger.LogInfo("Server bootstrap started");
+                }
+
+                // Check if world is ready (systems are initialized)
+                if (!_isReady && __instance.World.IsCreated)
+                {
+                    _isReady = true;
+                    OnWorldReady?.Invoke(__instance, EventArgs.Empty);
+                    TypedEventBus.Publish(new WorldReadyEvent());
+                    CoreLogger.LogInfo("World is ready - all systems initialized");
+                }
+            }
+            catch (Exception ex)
+            {
+                CoreLogger.LogException("Error in server bootstrap update", ex);
+            }
+        }
+
+        /// <summary>
+        /// Check if the server has completed startup.
+        /// </summary>
+        public static bool IsServerStarted => _hasStarted;
+
+        /// <summary>
+        /// Check if the world is ready and all systems are initialized.
+        /// </summary>
+        public static bool IsWorldReady => _isReady;
+    }
+
+    /// <summary>
+    /// Patch for Initialization completion to track when the game world is fully loaded.
+    /// </summary>
+    [HarmonyPatch(typeof(WorldBootstrapSystem), nameof(WorldBootstrapSystem.Initialize))]
+    internal static class WorldBootstrapPatch
+    {
+        public static event EventHandler OnWorldInitialized;
+
+        [HarmonyPostfix]
+        static void InitializePostfix(WorldBootstrapSystem __instance)
+        {
+            try
+            {
+                OnWorldInitialized?.Invoke(__instance, EventArgs.Empty);
+                TypedEventBus.Publish(new WorldInitializedEvent());
+                CoreLogger.LogInfo("WorldBootstrapSystem.Initialize completed");
+            }
+            catch (Exception ex)
+            {
+                CoreLogger.LogException("Error in world bootstrap initialize", ex);
+            }
+        }
+    }
+}
diff --git a/Patches/UnitSpawnerSystemPatch.cs b/Patches/UnitSpawnerSystemPatch.cs
new file mode 100644
index 0000000..d66691c
--- /dev/null
+++ b/Patches/UnitSpawnerSystemPatch.cs
@@ -0,0 +1,145 @@
+using System;
+using HarmonyLib;
+using ProjectM;
+using Unity.Collections;
+using Unity.Entities;
+using Unity.Mathematics;
+using VAutomationCore.Core.Events;
+using VAutomationCore.Core.Logging;
+
+namespace VAutomationCore.Patches
+{
+    /// <summary>
+    /// Patch for UnitSpawnerSystem to track when units are spawned.
+    /// Useful for tracking spawns, spawners, and spawn locations.
+    /// </summary>
+    [HarmonyPatch(typeof(UnitSpawnerSystem), nameof(UnitSpawnerSystem.OnUpdate))]
+    internal static class UnitSpawnerSystemPatch
+    {
+        public static event EventHandler<UnitSpawnEventArgs> OnUnitSpawned;
+        
+        public class UnitSpawnEventArgs : EventArgs
+        {
+            public Entity Spawner { get; set; }
+            public Entity SpawnedUnit { get; set; }
+            public PrefabGUID PrefabGuid { get; set; }
+            public float3 Position { get; set; }
+            public int Level { get; set; }
+            public bool IsNightSpawn { get; set; }
+        }
+
+        [HarmonyPostfix]
+        static unsafe void OnUpdatePostfix(UnitSpawnerSystem __instance)
+        {
+            if (!CoreLogger.IsInitialized) return;
+
+            try
+            {
+                // Access the internal spawn buffer if available
+                var spawnBufferField = typeof(UnitSpawnerSystem)
+                    .GetField("_SpawnBuffer", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
+                
+                if (spawnBufferField != null)
+                {
+                    var spawnBuffer = spawnBufferField.GetValue(__instance) as NativeList<UnitSpawnRequest>;
+                    if (spawnBuffer != null)
+                    {
+                        for (int i = 0; i < spawnBuffer.Length; i++)
+                        {
+                            var spawnRequest = spawnBuffer[i];
+                            
+                            var args = new UnitSpawnEventArgs
+                            {
+                                Spawner = spawnRequest.SpawnerEntity,
+                                SpawnedUnit = spawnRequest.UnitEntity,
+                                PrefabGuid = spawnRequest.PrefabGuid,
+                                Position = spawnRequest.Position,
+                                Level = spawnRequest.Level,
+                                IsNightSpawn = spawnRequest.NightPop
+                            };
+
+                            OnUnitSpawned?.Invoke(__instance, args);
+                            TypedEventBus.Publish(new UnitSpawnedEvent
+                            {
+                                Spawner = args.Spawner,
+                                SpawnedUnit = args.SpawnedUnit,
+                                PrefabGuid = args.PrefabGuid,
+                                Position = args.Position,
+                                Level = args.Level,
+                                IsNightSpawn = args.IsNightSpawn
+                            });
+                        }
+                    }
+                }
+            }
+            catch (Exception ex)
+            {
+                CoreLogger.LogException("Error processing unit spawn events", ex);
+            }
+        }
+    }
+
+    /// <summary>
+    /// Patch for tracking spawn travel buff events.
+    /// Useful for tracking when units get spawn travel buffs.
+    /// </summary>
+    [HarmonyPatch(typeof(SpawnTravelBuffSystem), nameof(SpawnTravelBuffSystem.OnUpdate))]
+    internal static class SpawnTravelBuffSystemPatch
+    {
+        public static event EventHandler<SpawnTravelBuffEventArgs> OnSpawnTravelBuffApplied;
+        
+        public class SpawnTravelBuffEventArgs : EventArgs
+        {
+            public Entity Unit { get; set; }
+            public PrefabGUID PrefabGuid { get; set; }
+            public float3 Position { get; set; }
+            public bool IsMoving { get; set; }
+        }
+
+        [HarmonyPostfix]
+        static void OnUpdatePostfix(SpawnTravelBuffSystem __instance)
+        {
+            if (!CoreLogger.IsInitialized) return;
+
+            try
+            {
+                using var query = __instance.EntityManager.CreateEntityQuery(
+                    ComponentType.ReadOnly<SpawnTravelBuff>(),
+                    ComponentType.ReadOnly<LocalTransform>()
+                );
+
+                var entities = query.ToEntityArray(Allocator.Temp);
+                var buffs = query.ToComponentDataArray<SpawnTravelBuff>(Allocator.Temp);
+                var transforms = query.ToComponentDataArray<LocalTransform>(Allocator.Temp);
+
+                for (int i = 0; i < entities.Length; i++)
+                {
+                    var args = new SpawnTravelBuffEventArgs
+                    {
+                        Unit = entities[i],
+                        PrefabGuid = buffs[i].PrefabGuid,
+                        Position = transforms[i].Position,
+                        IsMoving = !buffs[i].Arrived
+                    };
+
+                    OnSpawnTravelBuffApplied?.Invoke(__instance, args);
+                    TypedEventBus.Publish(new SpawnTravelBuffAppliedEvent
+                    {
+                        Unit = args.Unit,
+                        PrefabGuid = args.PrefabGuid,
+                        Position = args.Position,
+                        IsMoving = args.IsMoving
+                    });
+                }
+
+                entities.Dispose();
+                buffs.Dispose();
+                transforms.Dispose();
+            }
+            catch (Exception ex)
+            {
+                CoreLogger.LogException("Error processing spawn travel buff events", ex);
+            }
+        }
+    }
+}
diff --git a/ROOPLAN.md b/ROOPLAN.md
deleted file mode 100644
index 0f579fa..0000000
--- a/ROOPLAN.md
+++ /dev/null
@@ -1,308 +0,0 @@
-# ROOPLAN - Lifecycle and Bluelock Separation Plan
-
-## Architecture Overview
-
-```
-┌─────────────────────────────────────────────────────────────────────────────┐
-│                            CycleBorn                                         │
-│                     (LIFECYCLE ENGINE)                                       │
-├─────────────────────────────────────────────────────────────────────────────┤
-│  ✅ LifecycleTokenCatalog.cs    - Token definitions + ownership              │
-│  ✅ LifecycleRegistry.cs         - Domain handler registration               │
-│  ✅ ArenaLifecycleManager.cs    - Enter/Exit dispatch                      │
-│  ✅ Cycleborn.lifecycle.json    - Lifecycle configuration                   │
-└────────────────────────────┬──────────────────────────────────────────────┘
-                             │
-                             ▼
-┌─────────────────────────────────────────────────────────────────────────────┐
-│                          VAutomationCore                                      │
-│                       (PURE UTILITIES)                                       │
-├─────────────────────────────────────────────────────────────────────────────┤
-│  ✅ Logging helpers, Config loader, JSON utilities, ECS wrappers            │
-│  ✅ DebugEventBridge.cs (shared progression - NOT lifecycle)              │
-│  ❌ NO lifecycle concepts, NO token catalog                               │
-└────────────────────────────┬──────────────────────────────────────────────┘
-                             │
-                             ▼
-┌─────────────────────────────────────────────────────────────────────────────┐
-│                            Bluelock                                          │
-│                       (DOMAIN MODULE)                                       │
-├─────────────────────────────────────────────────────────────────────────────┤
-│  ✅ Zone configs, Kits, Abilities, Bosses                                 │
-│  ✅ Domain services (KitService, AbilityZoneService, etc.)                │
-│  ✅ Registers handlers with CycleBorn LifecycleRegistry                     │
-│  ✅ CoopDungeonService (Template 1 - Multi-zone dungeon)                 │
-└─────────────────────────────────────────────────────────────────────────────┘
-```
-
----
-
-## Implementation Tasks
-
-### Phase 1: Token Catalog in CycleBorn ✅ COMPLETED
-- [x] Created `CycleBorn/Lifecycle/LifecycleTokenCatalog.cs`
-- [x] Defined `TokenOwner`, `TokenPhase`, `TokenDescriptor`
-
-### Phase 2: Lifecycle Registry in CycleBorn ✅ COMPLETED
-- [x] Created `CycleBorn/Lifecycle/LifecycleRegistry.cs`
-- [x] Defined `IDomainLifecycleHandler` interface
-
-### Phase 3: Strict Scanner ⏳ PENDING
-- [ ] Create `CycleBorn/Config/StrictMigrationScanner.cs`
-
-### Phase 4: Bluelock Adapter ⏳ PENDING
-- [ ] Update Bluelock adapter to use CycleBorn's registry
-
-### Phase 5: Cleanup Core ⏳ PENDING
-- [ ] Delete moved files from Core
-
----
-
-# 🎮 Template 1: Co-op Progressive Dungeon (Multi-Zone)
-
-## Overview
-
-A **multi-zone dungeon** where players progress through 5 sub-zones, each with increasing difficulty.
-
-```
-Dungeon Instance (per clan)
- ├── Zone A: Entrance Hall (Tier 1)
- ├── Zone B: Crypt (Tier 2)
- ├── Zone C: Catacombs (Tier 3)
- ├── Zone D: Sanctum (Tier 4)
- └── Zone E: Final Chamber (Tier 5)
-```
-
----
-
-## Config Design
-
-### `bluelock.zones.json` - Dungeon Template
-
-```json
-{
-  "templates": {
-    "Coop_Dungeon_Template": {
-      "type": "coop_progressive",
-      "maxDeaths": 3,
-      "zones": [
-        {
-          "zoneId": "dungeon_entrance",
-          "tier": 1,
-          "unitLevel": 40,
-          "bossLevel": 40,
-          "unitPrefab": "zombie_basic",
-          "bossPrefab": "boss_alpha"
-        },
-        {
-          "zoneId": "dungeon_crypt",
-          "tier": 2,
-          "unitLevel": 50,
-          "bossLevel": 50,
-          "unitPrefab": "skeleton_warrior",
-          "bossPrefab": "boss_bone_lord"
-        },
-        {
-          "zoneId": "dungeon_catacombs",
-          "tier": 3,
-          "unitLevel": 60,
-          "bossLevel": 60
-        },
-        {
-          "zoneId": "dungeon_sanctum",
-          "tier": 4,
-          "unitLevel": 70,
-          "bossLevel": 70
-        },
-        {
-          "zoneId": "dungeon_final",
-          "tier": 5,
-          "unitLevel": 80,
-          "bossLevel": 80
-        }
-      ]
-    }
-  }
-}
-```
-
----
-
-## Lifecycle Integration (CycleBorn)
-
-### New Domain Tokens
-
-| Token | Phase | Description |
-|-------|-------|-------------|
-| coop_start | OnEnter | Start dungeon instance |
-| coop_progress | OnEnter | Progress to next tier |
-| coop_final | OnEnter | Enter final boss |
-| coop_exit | OnExit | Exit dungeon |
-
-### `Cycleborn.lifecycle.json` Example
-
-```json
-{
-  "mappings": {
-    "dungeon_entrance": {
-      "onEnter": ["capture_return_position", "coop_start"],
-      "onExit": ["coop_exit"]
-    },
-    "dungeon_crypt": {
-      "onEnter": ["coop_progress"],
-      "onExit": ["coop_exit"]
-    },
-    "dungeon_catacombs": {
-      "onEnter": ["coop_progress"],
-      "onExit": ["coop_exit"]
-    },
-    "dungeon_sanctum": {
-      "onEnter": ["coop_progress"],
-      "onExit": ["coop_exit"]
-    },
-    "dungeon_final": {
-      "onEnter": ["coop_progress", "coop_final"],
-      "onExit": ["coop_exit"]
-    }
-  }
-}
-```
-
----
-
-## Bluelock Runtime Model
-
-### Core Data Structures
-
-```csharp
-// Instance key for multi-instance support
-public readonly struct CoopInstanceKey
-{
-    public readonly string TemplateId;
-    public readonly ulong ClanId;
-}
-
-// Dungeon state per instance
-public class CoopDungeonState
-{
-    public string TemplateId;
-    public ulong ClanId;
-    public int CurrentTier;
-    public Dictionary<ulong, int> PlayerDeaths = new();
-    public HashSet<ulong> ActivePlayers = new();
-    public bool IsActive;
-}
-
-// Runtime store
-private readonly Dictionary<CoopInstanceKey, CoopDungeonState> _instances;
-```
-
----
-
-## Bluelock Handlers
-
-### `CoopStartHandler`
-- Validate clan membership
-- Create new dungeon instance
-- Set tier = 1
-- Spawn initial wave
-- Track all players in instance
-
-### `CoopProgressHandler`
-- Detect sub-zone entry
-- Match tier to zone
-- Spawn appropriate wave
-- On boss death → increment tier
-
-### `CoopFinalHandler`
-- Trigger final boss
-- On victory → grant rewards
-
-### `CoopExitHandler`
-- Cleanup instance when all leave
-- Handle partial completion
-
----
-
-## Death Rules
-
-- **Max deaths per player**: 3
-- **On death**: Respawn inside dungeon
-- **On 4th death**: Remove from instance
-- **All players eliminated**: Dungeon fails
-
----
-
-## Victory Conditions
-
-- **Complete tier 5 (final chamber)**
-- Grant reward kit
-- Trigger celebration
-- Cleanup instance
-
----
-
-## Failure Conditions
-
-- **All players eliminated OR death cap reached**
-- Teleport to return position
-- Reset instance state
-
----
-
-## File Structure for Template 1
-
-```
-Bluelock/
-└── Services/
-    └── Coop/
-        ├── CoopDungeonService.cs      (main service)
-        ├── CoopDungeonState.cs       (state model)
-        ├── CoopStartHandler.cs       (domain handler)
-        ├── CoopProgressHandler.cs    (domain handler)
-        ├── CoopFinalHandler.cs       (domain handler)
-        └── CoopExitHandler.cs        (domain handler)
-```
-
----
-
-## Token Classification
-
-### Orchestration Tokens (CycleBorn-owned)
-- capture_return_position, snapshot_save
-- zone_enter_message, zone_exit_message
-- teleport_enter, teleport_return
-- player_tag
-- integration_events_enter, integration_events_exit
-- announce_enter
-
-### Domain Tokens (Bluelock-owned)
-- **Existing**: apply_kit, restore_kit_snapshot, apply_templates, apply_abilities, restore_abilities, boss_enter, boss_exit, glow_spawn, glow_reset
-- **NEW - Arena**: arena_start, arena_end, arena_respawn
-- **NEW - Coop**: coop_start, coop_progress, coop_final, coop_exit
-- **NEW - Raid**: raid_start, raid_phase, raid_end
-
----
-
-## Architecture Rules
-
-1. **VAutomationCore = utilities only** - No lifecycle concepts
-2. **CycleBorn = lifecycle engine** - Owns all orchestration
-3. **Bluelock = domain module** - Plugs into CycleBorn
-4. **DebugEventBridge stays in Core** - Shared progression utility
-
----
-
-## Files Created
-
-1. ✅ `CycleBorn/Lifecycle/LifecycleTokenCatalog.cs`
-2. ✅ `CycleBorn/Lifecycle/LifecycleRegistry.cs`
-
----
-
-## Next Steps
-
-1. Complete Phase 3: Create StrictMigrationScanner
-2. Complete Phase 4: Update Bluelock adapter
-3. Complete Phase 5: Cleanup Core layer
-4. Build Template 1: CoopDungeonService
diff --git a/VAutomationCore.csproj b/VAutomationCore.csproj
index 8e38b46..8364fa3 100644
--- a/VAutomationCore.csproj
+++ b/VAutomationCore.csproj
@@ -85,6 +85,7 @@
     <Compile Include="Core\UnifiedCore.cs" />
     <Compile Include="Core\Logging\CoreLogger.cs" />
     <Compile Include="Core\Logging\CoreLoggerExtensions.cs" />
+    <Compile Include="Core\Arena\ArenaLifecycleManager.cs" />
     <Compile Include="Core\Config\ConfigService.cs" />
     <Compile Include="Core\Config\JsonConverters.cs" />
     <Compile Include="Core\Config\TypedJsonConfigManager.cs" />
diff --git a/config/VAuto.unified_config.schema.json b/config/VAuto.unified_config.schema.json
new file mode 100644
index 0000000..5f4f1e6
--- /dev/null
+++ b/config/VAuto.unified_config.schema.json
@@ -0,0 +1,120 @@
+{
+  "$schema": "http://json-schema.org/draft-07/schema#",
+  "title": "VAuto Unified Configuration",
+  "version": "1.0.0",
+  "description": "Master configuration file for all VAuto plugins",
+  
+  "properties": {
+    "version": {
+      "type": "string",
+      "description": "Configuration schema version"
+    },
+    "core": {
+      "type": "object",
+      "description": "Core settings shared across all plugins",
+      "properties": {
+        "enableLogging": { "type": "boolean", "default": true },
+        "logLevel": { "type": "string", "enum": ["Debug", "Info", "Warning", "Error"], "default": "Info" },
+        "apiEnabled": { "type": "boolean", "default": true },
+        "apiPort": { "type": "integer", "minimum": 1024, "maximum": 65535, "default": 8080 }
+      }
+    },
+    "vlifecycle": {
+      "type": "object",
+      "description": "Vlifecycle plugin settings",
+      "properties": {
+        "enabled": { "type": "boolean", "default": true },
+        "arena": {
+          "type": "object",
+          "properties": {
+            "saveInventory": { "type": "boolean", "default": true },
+            "restoreInventory": { "type": "boolean", "default": true },
+            "saveBuffs": { "type": "boolean", "default": true },
+            "restoreBuffs": { "type": "boolean", "default": true },
+            "clearArenaBuffsOnExit": { "type": "boolean", "default": true },
+            "resetAbilityCooldowns": { "type": "boolean", "default": true },
+            "resetCooldownsOnExit": { "type": "boolean", "default": true }
+          }
+        },
+        "playerState": {
+          "type": "object",
+          "properties": {
+            "saveEquipment": { "type": "boolean", "default": true },
+            "saveBlood": { "type": "boolean", "default": true },
+            "saveSpells": { "type": "boolean", "default": true },
+            "saveHealth": { "type": "boolean", "default": true },
+            "restoreHealth": { "type": "boolean", "default": true }
+          }
+        },
+        "transitions": {
+          "type": "object",
+          "properties": {
+            "enterDelayMs": { "type": "integer", "default": 0 },
+            "exitDelayMs": { "type": "integer", "default": 0 },
+            "lockMovementDuringTransition": { "type": "boolean", "default": false },
+            "showTransitionMessages": { "type": "boolean", "default": true }
+          }
+        }
+      }
+    },
+    "vautozone": {
+      "type": "object",
+      "description": "VAutoZone plugin settings",
+      "properties": {
+        "enabled": { "type": "boolean", "default": true },
+        "glowZones": {
+          "type": "array",
+          "items": {
+            "type": "object",
+            "properties": {
+              "id": { "type": "string" },
+              "enabled": { "type": "boolean", "default": true },
+              "center": { "$ref": "#/definitions/vec3" },
+              "radius": { "type": "number" },
+              "borderSpacing": { "type": "number", "default": 5 },
+              "glowPrefabs": {
+                "type": "array",
+                "items": { "type": "string" }
+              },
+              "rotation": {
+                "type": "object",
+                "properties": {
+                  "enabled": { "type": "boolean", "default": false },
+                  "intervalSeconds": { "type": "integer", "default": 120 },
+                  "mode": { "type": "string", "enum": ["sequential", "random"], "default": "sequential" }
+                }
+              }
+            }
+          }
+        }
+      }
+    },
+    "vautotraps": {
+      "type": "object",
+      "description": "VAutoTraps plugin settings",
+      "properties": {
+        "enabled": { "type": "boolean", "default": true },
+        "killThreshold": { "type": "integer", "default": 5 },
+        "chestsPerSpawn": { "type": "integer", "default": 2 },
+        "containerGlowRadius": { "type": "number", "default": 5 },
+        "waypointTrapThreshold": { "type": "integer", "default": 10 },
+        "waypointTrapGlowRadius": { "type": "number", "default": 8 },
+        "notificationEnabled": { "type": "boolean", "default": true },
+        "trapDamageAmount": { "type": "number", "default": 50 },
+        "trapDuration": { "type": "number", "default": 30 },
+        "enableWaypointTraps": { "type": "boolean", "default": true }
+      }
+    }
+  },
+  
+  "definitions": {
+    "vec3": {
+      "type": "object",
+      "properties": {
+        "x": { "type": "number" },
+        "y": { "type": "number" },
+        "z": { "type": "number" }
+      }
+    }
+  }
+}
diff --git a/docs/architecture/BLUELOCK_COMMAND_EXECUTION_FLOWS.md b/docs/architecture/BLUELOCK_COMMAND_EXECUTION_FLOWS.md
deleted file mode 100644
index 9964a10..0000000
--- a/docs/architecture/BLUELOCK_COMMAND_EXECUTION_FLOWS.md
+++ /dev/null
@@ -1,272 +0,0 @@
-# Bluelock Command Execution Flows
-
-This section explains how commands move through the system, not just what they do.
-
-## 1) Zone Lifecycle Flow
-
-```text
-.z create
-   ↓
-Zone Definition Created
-   ↓
-Zone Stored (config)
-   ↓
-Zone Disabled (default)
-```
-
-```text
-.z on
-   ↓
-Zone Enabled
-   ↓
-Zone Runtime State Initialized
-   ↓
-Enter/Exit Hooks Activated
-```
-
-```text
-.z off
-   ↓
-Zone Disabled
-   ↓
-All Runtime Effects Suspended
-```
-
-```text
-.z remove
-   ↓
-Zone Runtime Teardown
-   ↓
-Zone Definition Deleted
-```
-
-### Key Rules
-
-- Zones exist before they are active.
-- Disabled zones do not affect players.
-- Default zone is checked first during entry resolution.
-
-## 2) Zone Entry / Exit Flow
-
-```text
-.enter [zone]
-   ↓
-Resolve Zone (explicit → default)
-   ↓
-Validate Permissions
-   ↓
-Exit Current Zone (if any)
-   ↓
-Apply Zone Enter Lifecycle
-   ↓
-Teleport / Effects / Kits
-```
-
-```text
-.exit
-   ↓
-Resolve Current Zone
-   ↓
-Apply Zone Exit Lifecycle
-   ↓
-Restore Player State
-```
-
-### Notes
-
-- `.enter` without args uses default zone.
-- Exit always restores pre-zone snapshot.
-- Entry/exit logic is driven by `VAuto.ZoneLifecycle.json`.
-
-## 3) Template Spawn Flow
-
-```text
-.tm spawn
-   ↓
-Validate Zone Exists
-   ↓
-Resolve Template Type
-   ↓
-Spawn Template Prefabs
-   ↓
-Register Runtime Ownership
-```
-
-```text
-.tm clear
-   ↓
-Resolve Template Instances
-   ↓
-Destroy Runtime Entities
-```
-
-```text
-.tm rebuild
-   ↓
-Clear All Templates
-   ↓
-Spawn All Templates
-```
-
-### Template Scope
-
-- Templates are zone-scoped.
-- Clearing a zone does not delete the zone.
-- Templates never persist outside the zone.
-
-## 4) Match Lifecycle Flow
-
-```text
-.match start
-   ↓
-Validate Zone
-   ↓
-Lock Zone State
-   ↓
-Enable Arena Damage
-   ↓
-Start Match Timer
-```
-
-```text
-.match end
-   ↓
-Stop Match Timer
-   ↓
-Disable Arena Damage
-   ↓
-Apply Match Cleanup
-```
-
-```text
-.match reset
-   ↓
-End Match (if active)
-   ↓
-Clear Zone State
-   ↓
-Restore Zone Defaults
-```
-
-### Match Rules
-
-- Only one match per zone.
-- Match overrides normal zone behavior.
-- Reset is always safe.
-
-## 5) Tag Management Flow
-
-```text
-.tag rename
-   ↓
-Validate Tag Format
-   ↓
-Update Player Tag
-   ↓
-Broadcast Change
-```
-
-```text
-.tag set
-   ↓
-Resolve Player
-   ↓
-Apply Tag
-```
-
-```text
-.tag clear
-   ↓
-Remove Player Tag
-```
-
-### Notes
-
-- Tags are player-local.
-- Tags do not affect permissions.
-- Admins can override any tag.
-
-## 6) Spawn Command Flow
-
-```text
-.sp unit
-   ↓
-Resolve Prefab / GUID
-   ↓
-Validate Count / Level
-   ↓
-Spawn Units Near Player
-```
-
-```text
-.sp boss
-   ↓
-Resolve Boss Prefab
-   ↓
-Spawn Single Boss
-```
-
-### Safety Rules
-
-- Max unit count enforced.
-- Spawned units are not persistent.
-- Boss spawns are isolated from progression.
-
-## 7) VBlood Unlock Flow
-
-```text
-.unlockprefab
-   ↓
-Resolve Tech_Collection Prefab
-   ↓
-Grant Unlock to Player
-```
-
-```text
-.unlockprefab list
-   ↓
-Enumerate Available Tech_Collection Prefabs
-```
-
-### Purpose
-
-- Testing only.
-- Does not affect progression.
-- Safe to repeat.
-
-## 8) Diagnostics Flow
-
-```text
-.z diag
-   ↓
-Resolve Player Context
-   ↓
-Inspect Zone State
-   ↓
-Inspect Runtime Flags
-   ↓
-Display Live Diagnostics
-```
-
-Used for:
-
-- Debugging zone entry.
-- Verifying lifecycle hooks.
-- Checking arena state.
-
-## Permission Flow (Global)
-
-```text
-Command Issued
-   ↓
-Check Admin Flag
-   ↓
-Allow / Deny
-```
-
-- Admin-only commands are enforced before execution.
-- Non-admin commands never mutate zones.
-
-## Final Mental Model
-
-Zones define space. Templates define structure. Matches define time. Tags define identity. Commands only move players between states.
diff --git a/docs/architecture/FINAL_ZONE_FLOWS.md b/docs/architecture/FINAL_ZONE_FLOWS.md
deleted file mode 100644
index 9576843..0000000
--- a/docs/architecture/FINAL_ZONE_FLOWS.md
+++ /dev/null
@@ -1,126 +0,0 @@
-# Final Zone Flows
-
-## Global Rules
-
-- Auto-detection is owned by Bluelock.
-- Lifecycle sequencing/execution is owned by CycleBorn.
-- No shared state between zones.
-- All effects are scoped by `(Player, ZoneId)`.
-- Snapshot on enter is mandatory.
-- Restore on exit is mandatory.
-
-## 1) Template Zone
-
-### Enter
-
-1. `snapshot_save`
-2. `apply_templates`
-3. `apply_abilities`
-
-### Exit
-
-1. `restore_abilities`
-2. `snapshot_restore`
-
-### Guarantees
-
-- No glow
-- No kits
-- No PvP unlocks
-- Full restore
-
-## 2) Zone Arena (non-boss, non-PvP)
-
-### Enter
-
-1. `capture_return_position`
-2. `snapshot_save`
-3. `apply_kit`
-4. `teleport_enter`
-5. `apply_templates`
-6. `apply_abilities`
-
-### Exit
-
-1. `restore_kit_snapshot`
-2. `restore_abilities`
-3. `teleport_return`
-4. `snapshot_restore`
-
-### Guarantees
-
-- Arena isolated
-- No boss logic
-- No PvP unlocks
-- Full restore
-
-## 3) Zone Boss
-
-### Enter
-
-1. `capture_return_position`
-2. `snapshot_save`
-3. `apply_kit`
-4. `teleport_enter`
-5. `apply_templates`
-6. `apply_abilities`
-7. `boss_enter`
-8. `apply_invisible_aura`
-
-### Exit
-
-1. `remove_invisible_aura`
-2. `boss_exit`
-3. `restore_kit_snapshot`
-4. `restore_abilities`
-5. `teleport_return`
-6. `snapshot_restore`
-
-### Guarantees
-
-- No visual glow
-- Boss-anchored invisible aura
-- Full restore
-
-## 4) PvP Zone (24h persistent)
-
-### Enter
-
-1. `snapshot_save`
-2. `apply_pvp_kit`
-3. `unlock_pvp_progress`
-4. `apply_templates` (optional)
-5. `apply_abilities` (optional)
-
-### Exit
-
-1. `restore_abilities`
-2. `restore_pvp_progress`
-3. `snapshot_restore`
-
-### PvP Glow Rule
-
-- Glow border is persistent infrastructure and not lifecycle-cleared.
-- Rebuilt on startup/config reload/watchdog.
-
-## Clearing Old Items/Kits (Controlled + Reversible)
-
-### Enter (Arena/Boss/PvP)
-
-1. `snapshot_save`
-2. `clear_old_items`
-3. `clear_old_kits`
-4. `apply_zone_kit`
-5. `unlock_zone_progress` (PvP only)
-
-### Exit
-
-1. `restore_zone_progress` (PvP only)
-2. `restore_kit_snapshot`
-3. `restore_inventory`
-4. `snapshot_restore`
-
-### Safety Rule
-
-Never permanently delete player items in lifecycle transitions. Snapshot restore is authoritative fallback.
-
diff --git a/docs/architecture/PLAYER_ONLY_SPELL_SANDBOX.md b/docs/architecture/PLAYER_ONLY_SPELL_SANDBOX.md
deleted file mode 100644
index b5e646e..0000000
--- a/docs/architecture/PLAYER_ONLY_SPELL_SANDBOX.md
+++ /dev/null
@@ -1,186 +0,0 @@
-# Final Plan — Player-Only Spell Sandbox (ProjectM)
-
-## Objective (Non-Negotiable)
-
-- Single player
-- Spell casting only
-- PvP-safe
-- No world authority
-- No persistence
-- Shrinks over time
-
-## 1) Sandbox Entry
-
-### Actions
-
-- Spawn or clone Sandbox Player Entity
-- Tag entity: `SandboxScoped`
-- Snapshot baseline player state (for restore)
-
-### Hard Guards
-
-Sandbox entity must never receive:
-
-- Ownership components
-- Territory components
-- Castle/build components
-- Persistence components
-- Shapeshift form components
-- ReplaceAbility components
-
-## 2) Input → Ability Resolution
-
-```
-Player Input
-   ↓
-AbilityInputSystem
-   ↓
-(Ability Whitelist Check)
-```
-
-### Rules
-
-- Ability is resolved once
-- No dynamic replacement
-- No PvP context swapping
-- No shapeshift resolution
-
-### Explicitly Excluded
-
-- `ReplaceAbility*`
-- `RunScriptOnGameplayEvents`
-
-## 3) Cast Initialization
-
-```
-AbilityInitializeGroup
-   ↓
-AbilityCastStarted
-```
-
-Purpose: prepare cast lifecycle and lock ability identity.
-
-## 4) Targeting & Aim
-
-```
-SetupAbilityTargetSystem_Shared
-   ↓
-RotateTowardAimDuringCastSystem
-   ↓
-AimAssist / AimPreview
-```
-
-Allowed:
-
-- Player-driven targeting
-- Visual previews only
-
-## 5) Spell Execution (Simulation Only)
-
-```
-AbilityCastStarted
-   ↓
-SpawnPrefabSystem_Server
-   ↓
-AbilityRunScriptsSystem
-   ↓
-AbilityRunScriptsSystem_Client
-```
-
-### Spawn Rules
-
-Spawned entities are temporary and must:
-
-- Have no persistence
-- Have no ownership
-- Have no territory
-- Auto-destroy with sandbox entity
-
-## 6) Spell Effects (Buff Pipeline)
-
-```
-GameplayEvent
-   ↓
-ApplyBuffOnGameplayEvents
-   ↓
-Apply_BuffModifications
-   ↓
-AdjustCooldown / AdjustLifetime
-```
-
-### Allowed
-
-- Damage
-- Healing
-- Cooldowns
-- Lifetimes
-- FX
-
-### Special Exception
-
-- Blood Mend allowed
-- Blood Mend heal forced to +10000
-- All shapeshift buffs blocked
-
-## 7) Presentation Only
-
-Allowed:
-
-- Cast FX
-- Glow
-- Borders
-- Aim indicators
-
-Removed:
-
-- Sun damage rays
-- Map zone UI
-- Environment visuals
-- Tutorial overlays
-- Voice overlays
-
-## 8) Global Safety Net
-
-```
-StripPersistenceEntitiesAndComponentsSystem
-```
-
-Purpose:
-
-- Strip accidental persistence
-- Enforce sandbox isolation
-- Prevent world leakage
-
-## 9) Death / Respawn
-
-Sandbox rule:
-
-- No respawn systems
-- No blood reset
-- Either prevent death or manually reset sandbox entity
-
-## 10) Sandbox Exit
-
-```
-Exit Sandbox
-   ↓
-Destroy Sandbox Entities
-   ↓
-Restore Baseline Snapshot
-   ↓
-Clear SandboxScoped Tag
-```
-
-Guarantees:
-
-- No PvP authority changed
-- No world state mutated
-- No persistence written
-
-## Final Law
-
-Systems are global. Authority is component-based. Sandbox works by never granting authority components.
-
-## One-Line Summary
-
-Spell sandbox = ability simulation only. No replacement, no form, no ownership, no persistence.
diff --git a/docs/skills/vrising-rules-sections.md b/docs/skills/vrising-rules-sections.md
deleted file mode 100644
index 6ad94dd..0000000
--- a/docs/skills/vrising-rules-sections.md
+++ /dev/null
@@ -1,47 +0,0 @@
-# Sections
-
-This file defines V Rising-focused sections, their ordering, impact levels, and descriptions.
-The section ID (in parentheses) is the filename prefix used to group rules.
-
----
-
-## 1. ECS Update Loop Efficiency (ecs)
-
-**Impact:** CRITICAL  
-**Description:** ECS update loops are the main performance hotspot on dedicated servers. Avoid heavy per-tick work, repeated queries, and avoidable allocations.
-
-## 2. Lifecycle Snapshot Integrity (lifecycle)
-
-**Impact:** CRITICAL  
-**Description:** Arena/zone lifecycle save-restore logic must be deterministic and failure-safe for inventory, buffs, blood, spells, and position.
-
-## 3. Prefab and Data Resolution Reliability (data)
-
-**Impact:** HIGH  
-**Description:** Stable prefab GUID/name mapping and strict config validation prevent runtime breaks caused by invalid references and schema drift.
-
-## 4. Command and Permission Safety (commands)
-
-**Impact:** HIGH  
-**Description:** Command surfaces must enforce permissions and predictable argument handling to protect live server state and admin workflows.
-
-## 5. Patch and Interop Stability (patch)
-
-**Impact:** HIGH  
-**Description:** Harmony and IL2CPP interop should be minimal, guarded, and version-tolerant to avoid crashes and patch conflicts.
-
-## 6. Configuration Evolution and Migration (config)
-
-**Impact:** MEDIUM-HIGH  
-**Description:** Config upgrades should support migration, backward compatibility, and safe hot-reload behavior across plugin versions.
-
-## 7. Zone Reassertion and Recovery (zones)
-
-**Impact:** MEDIUM  
-**Description:** Zone state can desync under ECS churn; reassert invariants and recovery paths to maintain gameplay correctness.
-
-## 8. Diagnostics and Test Guardrails (quality)
-
-**Impact:** MEDIUM  
-**Description:** Structured logs, targeted tests, and guardrails are required for fast debugging and regression prevention in live server mods.
-
diff --git a/log-viewer-app/.vscode/settings.json b/log-viewer-app/.vscode/settings.json
new file mode 100644
index 0000000..9e26dfe
--- /dev/null
+++ b/log-viewer-app/.vscode/settings.json
@@ -0,0 +1 @@
+{}
\ No newline at end of file
diff --git a/log-viewer-app/backend/package-lock.json b/log-viewer-app/backend/package-lock.json
new file mode 100644
index 0000000..10296aa
--- /dev/null
+++ b/log-viewer-app/backend/package-lock.json
@@ -0,0 +1,1403 @@
+{
+  "name": "log-viewer-backend",
+  "version": "1.0.0",
+  "lockfileVersion": 3,
+  "requires": true,
+  "packages": {
+    "": {
+      "name": "log-viewer-backend",
+      "version": "1.0.0",
+      "dependencies": {
+        "cors": "^2.8.5",
+        "express": "^4.18.2",
+        "socket.io": "^4.7.2",
+        "tail": "^2.2.6"
+      },
+      "devDependencies": {
+        "@types/cors": "^2.8.13",
+        "@types/express": "^4.17.17",
+        "@types/node": "^20.5.0",
+        "ts-node": "^10.9.1",
+        "typescript": "^5.1.6"
+      }
+    },
+    "node_modules/@cspotcode/source-map-support": {
+      "version": "0.8.1",
+      "resolved": "https://registry.npmjs.org/@cspotcode/source-map-support/-/source-map-support-0.8.1.tgz",
+      "integrity": "sha512-IchNf6dN4tHoMFIn/7OE8LWZ19Y6q/67Bmf6vnGREv8RSbBVb9LPJxEcnwrcwX6ixSvaiGoomAUvu4YSxXrVgw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/trace-mapping": "0.3.9"
+      },
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@jridgewell/resolve-uri": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
+      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@jridgewell/sourcemap-codec": {
+      "version": "1.5.5",
+      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
+      "integrity": "sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/@jridgewell/trace-mapping": {
+      "version": "0.3.9",
+      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.9.tgz",
+      "integrity": "sha512-3Belt6tdc8bPgAtbcmdtNJlirVoTmEb5e2gC94PnkwEW9jI6CAHUeoG85tjWP5WquqfavoMtMwiG4P926ZKKuQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/resolve-uri": "^3.0.3",
+        "@jridgewell/sourcemap-codec": "^1.4.10"
+      }
+    },
+    "node_modules/@socket.io/component-emitter": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/@socket.io/component-emitter/-/component-emitter-3.1.2.tgz",
+      "integrity": "sha512-9BCxFwvbGg/RsZK9tjXd8s4UcwR0MWeFQ1XEKIQVVvAGJyINdrqKMcTRyLoK8Rse1GjzLV9cwjWV1olXRWEXVA==",
+      "license": "MIT"
+    },
+    "node_modules/@tsconfig/node10": {
+      "version": "1.0.12",
+      "resolved": "https://registry.npmjs.org/@tsconfig/node10/-/node10-1.0.12.tgz",
+      "integrity": "sha512-UCYBaeFvM11aU2y3YPZ//O5Rhj+xKyzy7mvcIoAjASbigy8mHMryP5cK7dgjlz2hWxh1g5pLw084E0a/wlUSFQ==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/@tsconfig/node12": {
+      "version": "1.0.11",
+      "resolved": "https://registry.npmjs.org/@tsconfig/node12/-/node12-1.0.11.tgz",
+      "integrity": "sha512-cqefuRsh12pWyGsIoBKJA9luFu3mRxCA+ORZvA4ktLSzIuCUtWVxGIuXigEwO5/ywWFMZ2QEGKWvkZG1zDMTag==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/@tsconfig/node14": {
+      "version": "1.0.3",
+      "resolved": "https://registry.npmjs.org/@tsconfig/node14/-/node14-1.0.3.tgz",
+      "integrity": "sha512-ysT8mhdixWK6Hw3i1V2AeRqZ5WfXg1G43mqoYlM2nc6388Fq5jcXyr5mRsqViLx/GJYdoL0bfXD8nmF+Zn/Iow==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/@tsconfig/node16": {
+      "version": "1.0.4",
+      "resolved": "https://registry.npmjs.org/@tsconfig/node16/-/node16-1.0.4.tgz",
+      "integrity": "sha512-vxhUy4J8lyeyinH7Azl1pdd43GJhZH/tP2weN8TntQblOY+A0XbT8DJk1/oCPuOOyg/Ja757rG0CgHcWC8OfMA==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/@types/body-parser": {
+      "version": "1.19.6",
+      "resolved": "https://registry.npmjs.org/@types/body-parser/-/body-parser-1.19.6.tgz",
+      "integrity": "sha512-HLFeCYgz89uk22N5Qg3dvGvsv46B8GLvKKo1zKG4NybA8U2DiEO3w9lqGg29t/tfLRJpJ6iQxnVw4OnB7MoM9g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@types/connect": "*",
+        "@types/node": "*"
+      }
+    },
+    "node_modules/@types/connect": {
+      "version": "3.4.38",
+      "resolved": "https://registry.npmjs.org/@types/connect/-/connect-3.4.38.tgz",
+      "integrity": "sha512-K6uROf1LD88uDQqJCktA4yzL1YYAK6NgfsI0v/mTgyPKWsX1CnJ0XPSDhViejru1GcRkLWb8RlzFYJRqGUbaug==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@types/node": "*"
+      }
+    },
+    "node_modules/@types/cors": {
+      "version": "2.8.19",
+      "resolved": "https://registry.npmjs.org/@types/cors/-/cors-2.8.19.tgz",
+      "integrity": "sha512-mFNylyeyqN93lfe/9CSxOGREz8cpzAhH+E93xJ4xWQf62V8sQ/24reV2nyzUWM6H6Xji+GGHpkbLe7pVoUEskg==",
+      "license": "MIT",
+      "dependencies": {
+        "@types/node": "*"
+      }
+    },
+    "node_modules/@types/express": {
+      "version": "4.17.25",
+      "resolved": "https://registry.npmjs.org/@types/express/-/express-4.17.25.tgz",
+      "integrity": "sha512-dVd04UKsfpINUnK0yBoYHDF3xu7xVH4BuDotC/xGuycx4CgbP48X/KF/586bcObxT0HENHXEU8Nqtu6NR+eKhw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@types/body-parser": "*",
+        "@types/express-serve-static-core": "^4.17.33",
+        "@types/qs": "*",
+        "@types/serve-static": "^1"
+      }
+    },
+    "node_modules/@types/express-serve-static-core": {
+      "version": "4.19.8",
+      "resolved": "https://registry.npmjs.org/@types/express-serve-static-core/-/express-serve-static-core-4.19.8.tgz",
+      "integrity": "sha512-02S5fmqeoKzVZCHPZid4b8JH2eM5HzQLZWN2FohQEy/0eXTq8VXZfSN6Pcr3F6N9R/vNrj7cpgbhjie6m/1tCA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@types/node": "*",
+        "@types/qs": "*",
+        "@types/range-parser": "*",
+        "@types/send": "*"
+      }
+    },
+    "node_modules/@types/http-errors": {
+      "version": "2.0.5",
+      "resolved": "https://registry.npmjs.org/@types/http-errors/-/http-errors-2.0.5.tgz",
+      "integrity": "sha512-r8Tayk8HJnX0FztbZN7oVqGccWgw98T/0neJphO91KkmOzug1KkofZURD4UaD5uH8AqcFLfdPErnBod0u71/qg==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/@types/mime": {
+      "version": "1.3.5",
+      "resolved": "https://registry.npmjs.org/@types/mime/-/mime-1.3.5.tgz",
+      "integrity": "sha512-/pyBZWSLD2n0dcHE3hq8s8ZvcETHtEuF+3E7XVt0Ig2nvsVQXdghHVcEkIWjy9A0wKfTn97a/PSDYohKIlnP/w==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/@types/node": {
+      "version": "20.19.33",
+      "resolved": "https://registry.npmjs.org/@types/node/-/node-20.19.33.tgz",
+      "integrity": "sha512-Rs1bVAIdBs5gbTIKza/tgpMuG1k3U/UMJLWecIMxNdJFDMzcM5LOiLVRYh3PilWEYDIeUDv7bpiHPLPsbydGcw==",
+      "license": "MIT",
+      "dependencies": {
+        "undici-types": "~6.21.0"
+      }
+    },
+    "node_modules/@types/qs": {
+      "version": "6.14.0",
+      "resolved": "https://registry.npmjs.org/@types/qs/-/qs-6.14.0.tgz",
+      "integrity": "sha512-eOunJqu0K1923aExK6y8p6fsihYEn/BYuQ4g0CxAAgFc4b/ZLN4CrsRZ55srTdqoiLzU2B2evC+apEIxprEzkQ==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/@types/range-parser": {
+      "version": "1.2.7",
+      "resolved": "https://registry.npmjs.org/@types/range-parser/-/range-parser-1.2.7.tgz",
+      "integrity": "sha512-hKormJbkJqzQGhziax5PItDUTMAM9uE2XXQmM37dyd4hVM+5aVl7oVxMVUiVQn2oCQFN/LKCZdvSM0pFRqbSmQ==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/@types/send": {
+      "version": "1.2.1",
+      "resolved": "https://registry.npmjs.org/@types/send/-/send-1.2.1.tgz",
+      "integrity": "sha512-arsCikDvlU99zl1g69TcAB3mzZPpxgw0UQnaHeC1Nwb015xp8bknZv5rIfri9xTOcMuaVgvabfIRA7PSZVuZIQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@types/node": "*"
+      }
+    },
+    "node_modules/@types/serve-static": {
+      "version": "1.15.10",
+      "resolved": "https://registry.npmjs.org/@types/serve-static/-/serve-static-1.15.10.tgz",
+      "integrity": "sha512-tRs1dB+g8Itk72rlSI2ZrW6vZg0YrLI81iQSTkMmOqnqCaNr/8Ek4VwWcN5vZgCYWbg/JJSGBlUaYGAOP73qBw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@types/http-errors": "*",
+        "@types/node": "*",
+        "@types/send": "<1"
+      }
+    },
+    "node_modules/@types/serve-static/node_modules/@types/send": {
+      "version": "0.17.6",
+      "resolved": "https://registry.npmjs.org/@types/send/-/send-0.17.6.tgz",
+      "integrity": "sha512-Uqt8rPBE8SY0RK8JB1EzVOIZ32uqy8HwdxCnoCOsYrvnswqmFZ/k+9Ikidlk/ImhsdvBsloHbAlewb2IEBV/Og==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@types/mime": "^1",
+        "@types/node": "*"
+      }
+    },
+    "node_modules/accepts": {
+      "version": "1.3.8",
+      "resolved": "https://registry.npmjs.org/accepts/-/accepts-1.3.8.tgz",
+      "integrity": "sha512-PYAthTa2m2VKxuvSD3DPC/Gy+U+sOA1LAuT8mkmRuvw+NACSaeXEQ+NHcVF7rONl6qcaxV3Uuemwawk+7+SJLw==",
+      "license": "MIT",
+      "dependencies": {
+        "mime-types": "~2.1.34",
+        "negotiator": "0.6.3"
+      },
+      "engines": {
+        "node": ">= 0.6"
+      }
+    },
+    "node_modules/acorn": {
+      "version": "8.15.0",
+      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.15.0.tgz",
+      "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
+      "dev": true,
+      "license": "MIT",
+      "bin": {
+        "acorn": "bin/acorn"
+      },
+      "engines": {
+        "node": ">=0.4.0"
+      }
+    },
+    "node_modules/acorn-walk": {
+      "version": "8.3.4",
+      "resolved": "https://registry.npmjs.org/acorn-walk/-/acorn-walk-8.3.4.tgz",
+      "integrity": "sha512-ueEepnujpqee2o5aIYnvHU6C0A42MNdsIDeqy5BydrkuC5R1ZuUFnm27EeFJGoEHJQgn3uleRvmTXaJgfXbt4g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "acorn": "^8.11.0"
+      },
+      "engines": {
+        "node": ">=0.4.0"
+      }
+    },
+    "node_modules/arg": {
+      "version": "4.1.3",
+      "resolved": "https://registry.npmjs.org/arg/-/arg-4.1.3.tgz",
+      "integrity": "sha512-58S9QDqG0Xx27YwPSt9fJxivjYl432YCwfDMfZ+71RAqUrZef7LrKQZ3LHLOwCS4FLNBplP533Zx895SeOCHvA==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/array-flatten": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/array-flatten/-/array-flatten-1.1.1.tgz",
+      "integrity": "sha512-PCVAQswWemu6UdxsDFFX/+gVeYqKAod3D3UVm91jHwynguOwAvYPhx8nNlM++NqRcK6CxxpUafjmhIdKiHibqg==",
+      "license": "MIT"
+    },
+    "node_modules/base64id": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/base64id/-/base64id-2.0.0.tgz",
+      "integrity": "sha512-lGe34o6EHj9y3Kts9R4ZYs/Gr+6N7MCaMlIFA3F1R2O5/m7K06AxfSeO5530PEERE6/WyEg3lsuyw4GHlPZHog==",
+      "license": "MIT",
+      "engines": {
+        "node": "^4.5.0 || >= 5.9"
+      }
+    },
+    "node_modules/body-parser": {
+      "version": "1.20.4",
+      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.20.4.tgz",
+      "integrity": "sha512-ZTgYYLMOXY9qKU/57FAo8F+HA2dGX7bqGc71txDRC1rS4frdFI5R7NhluHxH6M0YItAP0sHB4uqAOcYKxO6uGA==",
+      "license": "MIT",
+      "dependencies": {
+        "bytes": "~3.1.2",
+        "content-type": "~1.0.5",
+        "debug": "2.6.9",
+        "depd": "2.0.0",
+        "destroy": "~1.2.0",
+        "http-errors": "~2.0.1",
+        "iconv-lite": "~0.4.24",
+        "on-finished": "~2.4.1",
+        "qs": "~6.14.0",
+        "raw-body": "~2.5.3",
+        "type-is": "~1.6.18",
+        "unpipe": "~1.0.0"
+      },
+      "engines": {
+        "node": ">= 0.8",
+        "npm": "1.2.8000 || >= 1.4.16"
+      }
+    },
+    "node_modules/bytes": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
+      "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.8"
+      }
+    },
+    "node_modules/call-bind-apply-helpers": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
+      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
+      "license": "MIT",
+      "dependencies": {
+        "es-errors": "^1.3.0",
+        "function-bind": "^1.1.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
+    "node_modules/call-bound": {
+      "version": "1.0.4",
+      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz",
+      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bind-apply-helpers": "^1.0.2",
+        "get-intrinsic": "^1.3.0"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/content-disposition": {
+      "version": "0.5.4",
+      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-0.5.4.tgz",
+      "integrity": "sha512-FveZTNuGw04cxlAiWbzi6zTAL/lhehaWbTtgluJh4/E95DqMwTmha3KZN1aAWA8cFIhHzMZUvLevkw5Rqk+tSQ==",
+      "license": "MIT",
+      "dependencies": {
+        "safe-buffer": "5.2.1"
+      },
+      "engines": {
+        "node": ">= 0.6"
+      }
+    },
+    "node_modules/content-type": {
+      "version": "1.0.5",
+      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz",
+      "integrity": "sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.6"
+      }
+    },
+    "node_modules/cookie": {
+      "version": "0.7.2",
+      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.2.tgz",
+      "integrity": "sha512-yki5XnKuf750l50uGTllt6kKILY4nQ1eNIQatoXEByZ5dWgnKqbnqmTrBE5B4N7lrMJKQ2ytWMiTO2o0v6Ew/w==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.6"
+      }
+    },
+    "node_modules/cookie-signature": {
+      "version": "1.0.7",
+      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.0.7.tgz",
+      "integrity": "sha512-NXdYc3dLr47pBkpUCHtKSwIOQXLVn8dZEuywboCOJY/osA0wFSLlSawr3KN8qXJEyX66FcONTH8EIlVuK0yyFA==",
+      "license": "MIT"
+    },
+    "node_modules/cors": {
+      "version": "2.8.6",
+      "resolved": "https://registry.npmjs.org/cors/-/cors-2.8.6.tgz",
+      "integrity": "sha512-tJtZBBHA6vjIAaF6EnIaq6laBBP9aq/Y3ouVJjEfoHbRBcHBAHYcMh/w8LDrk2PvIMMq8gmopa5D4V8RmbrxGw==",
+      "license": "MIT",
+      "dependencies": {
+        "object-assign": "^4",
+        "vary": "^1"
+      },
+      "engines": {
+        "node": ">= 0.10"
+      },
+      "funding": {
+        "type": "opencollective",
+        "url": "https://opencollective.com/express"
+      }
+    },
+    "node_modules/create-require": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/create-require/-/create-require-1.1.1.tgz",
+      "integrity": "sha512-dcKFX3jn0MpIaXjisoRvexIJVEKzaq7z2rZKxf+MSr9TkdmHmsU4m2lcLojrj/FHl8mk5VxMmYA+ftRkP/3oKQ==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/debug": {
+      "version": "2.6.9",
+      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
+      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
+      "license": "MIT",
+      "dependencies": {
+        "ms": "2.0.0"
+      }
+    },
+    "node_modules/depd": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
+      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.8"
+      }
+    },
+    "node_modules/destroy": {
+      "version": "1.2.0",
+      "resolved": "https://registry.npmjs.org/destroy/-/destroy-1.2.0.tgz",
+      "integrity": "sha512-2sJGJTaXIIaR1w4iJSNoN0hnMY7Gpc/n8D4qSCJw8QqFWXf7cuAgnEHxBpweaVcPevC2l3KpjYCx3NypQQgaJg==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.8",
+        "npm": "1.2.8000 || >= 1.4.16"
+      }
+    },
+    "node_modules/diff": {
+      "version": "4.0.4",
+      "resolved": "https://registry.npmjs.org/diff/-/diff-4.0.4.tgz",
+      "integrity": "sha512-X07nttJQkwkfKfvTPG/KSnE2OMdcUCao6+eXF3wmnIQRn2aPAHH3VxDbDOdegkd6JbPsXqShpvEOHfAT+nCNwQ==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "engines": {
+        "node": ">=0.3.1"
+      }
+    },
+    "node_modules/dunder-proto": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
+      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bind-apply-helpers": "^1.0.1",
+        "es-errors": "^1.3.0",
+        "gopd": "^1.2.0"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
+    "node_modules/ee-first": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
+      "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
+      "license": "MIT"
+    },
+    "node_modules/encodeurl": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
+      "integrity": "sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.8"
+      }
+    },
+    "node_modules/engine.io": {
+      "version": "6.6.5",
+      "resolved": "https://registry.npmjs.org/engine.io/-/engine.io-6.6.5.tgz",
+      "integrity": "sha512-2RZdgEbXmp5+dVbRm0P7HQUImZpICccJy7rN7Tv+SFa55pH+lxnuw6/K1ZxxBfHoYpSkHLAO92oa8O4SwFXA2A==",
+      "license": "MIT",
+      "dependencies": {
+        "@types/cors": "^2.8.12",
+        "@types/node": ">=10.0.0",
+        "accepts": "~1.3.4",
+        "base64id": "2.0.0",
+        "cookie": "~0.7.2",
+        "cors": "~2.8.5",
+        "debug": "~4.4.1",
+        "engine.io-parser": "~5.2.1",
+        "ws": "~8.18.3"
+      },
+      "engines": {
+        "node": ">=10.2.0"
+      }
+    },
+    "node_modules/engine.io-parser": {
+      "version": "5.2.3",
+      "resolved": "https://registry.npmjs.org/engine.io-parser/-/engine.io-parser-5.2.3.tgz",
+      "integrity": "sha512-HqD3yTBfnBxIrbnM1DoD6Pcq8NECnh8d4As1Qgh0z5Gg3jRRIqijury0CL3ghu/edArpUYiYqQiDUQBIs4np3Q==",
+      "license": "MIT",
+      "engines": {
+        "node": ">=10.0.0"
+      }
+    },
+    "node_modules/engine.io/node_modules/debug": {
+      "version": "4.4.3",
+      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
+      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
+      "license": "MIT",
+      "dependencies": {
+        "ms": "^2.1.3"
+      },
+      "engines": {
+        "node": ">=6.0"
+      },
+      "peerDependenciesMeta": {
+        "supports-color": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/engine.io/node_modules/ms": {
+      "version": "2.1.3",
+      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
+      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
+      "license": "MIT"
+    },
+    "node_modules/es-define-property": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
+      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
+    "node_modules/es-errors": {
+      "version": "1.3.0",
+      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
+      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
+    "node_modules/es-object-atoms": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
+      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
+      "license": "MIT",
+      "dependencies": {
+        "es-errors": "^1.3.0"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
+    "node_modules/escape-html": {
+      "version": "1.0.3",
+      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
+      "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==",
+      "license": "MIT"
+    },
+    "node_modules/etag": {
+      "version": "1.8.1",
+      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
+      "integrity": "sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.6"
+      }
+    },
+    "node_modules/express": {
+      "version": "4.22.1",
+      "resolved": "https://registry.npmjs.org/express/-/express-4.22.1.tgz",
+      "integrity": "sha512-F2X8g9P1X7uCPZMA3MVf9wcTqlyNp7IhH5qPCI0izhaOIYXaW9L535tGA3qmjRzpH+bZczqq7hVKxTR4NWnu+g==",
+      "license": "MIT",
+      "dependencies": {
+        "accepts": "~1.3.8",
+        "array-flatten": "1.1.1",
+        "body-parser": "~1.20.3",
+        "content-disposition": "~0.5.4",
+        "content-type": "~1.0.4",
+        "cookie": "~0.7.1",
+        "cookie-signature": "~1.0.6",
+        "debug": "2.6.9",
+        "depd": "2.0.0",
+        "encodeurl": "~2.0.0",
+        "escape-html": "~1.0.3",
+        "etag": "~1.8.1",
+        "finalhandler": "~1.3.1",
+        "fresh": "~0.5.2",
+        "http-errors": "~2.0.0",
+        "merge-descriptors": "1.0.3",
+        "methods": "~1.1.2",
+        "on-finished": "~2.4.1",
+        "parseurl": "~1.3.3",
+        "path-to-regexp": "~0.1.12",
+        "proxy-addr": "~2.0.7",
+        "qs": "~6.14.0",
+        "range-parser": "~1.2.1",
+        "safe-buffer": "5.2.1",
+        "send": "~0.19.0",
+        "serve-static": "~1.16.2",
+        "setprototypeof": "1.2.0",
+        "statuses": "~2.0.1",
+        "type-is": "~1.6.18",
+        "utils-merge": "1.0.1",
+        "vary": "~1.1.2"
+      },
+      "engines": {
+        "node": ">= 0.10.0"
+      },
+      "funding": {
+        "type": "opencollective",
+        "url": "https://opencollective.com/express"
+      }
+    },
+    "node_modules/finalhandler": {
+      "version": "1.3.2",
+      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.3.2.tgz",
+      "integrity": "sha512-aA4RyPcd3badbdABGDuTXCMTtOneUCAYH/gxoYRTZlIJdF0YPWuGqiAsIrhNnnqdXGswYk6dGujem4w80UJFhg==",
+      "license": "MIT",
+      "dependencies": {
+        "debug": "2.6.9",
+        "encodeurl": "~2.0.0",
+        "escape-html": "~1.0.3",
+        "on-finished": "~2.4.1",
+        "parseurl": "~1.3.3",
+        "statuses": "~2.0.2",
+        "unpipe": "~1.0.0"
+      },
+      "engines": {
+        "node": ">= 0.8"
+      }
+    },
+    "node_modules/forwarded": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
+      "integrity": "sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.6"
+      }
+    },
+    "node_modules/fresh": {
+      "version": "0.5.2",
+      "resolved": "https://registry.npmjs.org/fresh/-/fresh-0.5.2.tgz",
+      "integrity": "sha512-zJ2mQYM18rEFOudeV4GShTGIQ7RbzA7ozbU9I/XBpm7kqgMywgmylMwXHxZJmkVoYkna9d2pVXVXPdYTP9ej8Q==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.6"
+      }
+    },
+    "node_modules/function-bind": {
+      "version": "1.1.2",
+      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
+      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
+      "license": "MIT",
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/get-intrinsic": {
+      "version": "1.3.0",
+      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
+      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bind-apply-helpers": "^1.0.2",
+        "es-define-property": "^1.0.1",
+        "es-errors": "^1.3.0",
+        "es-object-atoms": "^1.1.1",
+        "function-bind": "^1.1.2",
+        "get-proto": "^1.0.1",
+        "gopd": "^1.2.0",
+        "has-symbols": "^1.1.0",
+        "hasown": "^2.0.2",
+        "math-intrinsics": "^1.1.0"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/get-proto": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
+      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
+      "license": "MIT",
+      "dependencies": {
+        "dunder-proto": "^1.0.1",
+        "es-object-atoms": "^1.0.0"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
+    "node_modules/gopd": {
+      "version": "1.2.0",
+      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
+      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/has-symbols": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
+      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/hasown": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
+      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
+      "license": "MIT",
+      "dependencies": {
+        "function-bind": "^1.1.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
+    "node_modules/http-errors": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.1.tgz",
+      "integrity": "sha512-4FbRdAX+bSdmo4AUFuS0WNiPz8NgFt+r8ThgNWmlrjQjt1Q7ZR9+zTlce2859x4KSXrwIsaeTqDoKQmtP8pLmQ==",
+      "license": "MIT",
+      "dependencies": {
+        "depd": "~2.0.0",
+        "inherits": "~2.0.4",
+        "setprototypeof": "~1.2.0",
+        "statuses": "~2.0.2",
+        "toidentifier": "~1.0.1"
+      },
+      "engines": {
+        "node": ">= 0.8"
+      },
+      "funding": {
+        "type": "opencollective",
+        "url": "https://opencollective.com/express"
+      }
+    },
+    "node_modules/iconv-lite": {
+      "version": "0.4.24",
+      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz",
+      "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
+      "license": "MIT",
+      "dependencies": {
+        "safer-buffer": ">= 2.1.2 < 3"
+      },
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/inherits": {
+      "version": "2.0.4",
+      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
+      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
+      "license": "ISC"
+    },
+    "node_modules/ipaddr.js": {
+      "version": "1.9.1",
+      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
+      "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.10"
+      }
+    },
+    "node_modules/make-error": {
+      "version": "1.3.6",
+      "resolved": "https://registry.npmjs.org/make-error/-/make-error-1.3.6.tgz",
+      "integrity": "sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==",
+      "dev": true,
+      "license": "ISC"
+    },
+    "node_modules/math-intrinsics": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
+      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
+    "node_modules/media-typer": {
+      "version": "0.3.0",
+      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-0.3.0.tgz",
+      "integrity": "sha512-dq+qelQ9akHpcOl/gUVRTxVIOkAJ1wR3QAvb4RsVjS8oVoFjDGTc679wJYmUmknUF5HwMLOgb5O+a3KxfWapPQ==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.6"
+      }
+    },
+    "node_modules/merge-descriptors": {
+      "version": "1.0.3",
+      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-1.0.3.tgz",
+      "integrity": "sha512-gaNvAS7TZ897/rVaZ0nMtAyxNyi/pdbjbAwUpFQpN70GqnVfOiXpeUUMKRBmzXaSQ8DdTX4/0ms62r2K+hE6mQ==",
+      "license": "MIT",
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/methods": {
+      "version": "1.1.2",
+      "resolved": "https://registry.npmjs.org/methods/-/methods-1.1.2.tgz",
+      "integrity": "sha512-iclAHeNqNm68zFtnZ0e+1L2yUIdvzNoauKU4WBA3VvH/vPFieF7qfRlwUZU+DA9P9bPXIS90ulxoUoCH23sV2w==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.6"
+      }
+    },
+    "node_modules/mime": {
+      "version": "1.6.0",
+      "resolved": "https://registry.npmjs.org/mime/-/mime-1.6.0.tgz",
+      "integrity": "sha512-x0Vn8spI+wuJ1O6S7gnbaQg8Pxh4NNHb7KSINmEWKiPE4RKOplvijn+NkmYmmRgP68mc70j2EbeTFRsrswaQeg==",
+      "license": "MIT",
+      "bin": {
+        "mime": "cli.js"
+      },
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/mime-db": {
+      "version": "1.52.0",
+      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
+      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.6"
+      }
+    },
+    "node_modules/mime-types": {
+      "version": "2.1.35",
+      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
+      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
+      "license": "MIT",
+      "dependencies": {
+        "mime-db": "1.52.0"
+      },
+      "engines": {
+        "node": ">= 0.6"
+      }
+    },
+    "node_modules/ms": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
+      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
+      "license": "MIT"
+    },
+    "node_modules/negotiator": {
+      "version": "0.6.3",
+      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-0.6.3.tgz",
+      "integrity": "sha512-+EUsqGPLsM+j/zdChZjsnX51g4XrHFOIXwfnCVPGlQk/k5giakcKsuxCObBRu6DSm9opw/O6slWbJdghQM4bBg==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.6"
+      }
+    },
+    "node_modules/object-assign": {
+      "version": "4.1.1",
+      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
+      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
+      "license": "MIT",
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/object-inspect": {
+      "version": "1.13.4",
+      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz",
+      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/on-finished": {
+      "version": "2.4.1",
+      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
+      "integrity": "sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==",
+      "license": "MIT",
+      "dependencies": {
+        "ee-first": "1.1.1"
+      },
+      "engines": {
+        "node": ">= 0.8"
+      }
+    },
+    "node_modules/parseurl": {
+      "version": "1.3.3",
+      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
+      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.8"
+      }
+    },
+    "node_modules/path-to-regexp": {
+      "version": "0.1.12",
+      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.12.tgz",
+      "integrity": "sha512-RA1GjUVMnvYFxuqovrEqZoxxW5NUZqbwKtYz/Tt7nXerk0LbLblQmrsgdeOxV5SFHf0UDggjS/bSeOZwt1pmEQ==",
+      "license": "MIT"
+    },
+    "node_modules/proxy-addr": {
+      "version": "2.0.7",
+      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
+      "integrity": "sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==",
+      "license": "MIT",
+      "dependencies": {
+        "forwarded": "0.2.0",
+        "ipaddr.js": "1.9.1"
+      },
+      "engines": {
+        "node": ">= 0.10"
+      }
+    },
+    "node_modules/qs": {
+      "version": "6.14.2",
+      "resolved": "https://registry.npmjs.org/qs/-/qs-6.14.2.tgz",
+      "integrity": "sha512-V/yCWTTF7VJ9hIh18Ugr2zhJMP01MY7c5kh4J870L7imm6/DIzBsNLTXzMwUA3yZ5b/KBqLx8Kp3uRvd7xSe3Q==",
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "side-channel": "^1.1.0"
+      },
+      "engines": {
+        "node": ">=0.6"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/range-parser": {
+      "version": "1.2.1",
+      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
+      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.6"
+      }
+    },
+    "node_modules/raw-body": {
+      "version": "2.5.3",
+      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-2.5.3.tgz",
+      "integrity": "sha512-s4VSOf6yN0rvbRZGxs8Om5CWj6seneMwK3oDb4lWDH0UPhWcxwOWw5+qk24bxq87szX1ydrwylIOp2uG1ojUpA==",
+      "license": "MIT",
+      "dependencies": {
+        "bytes": "~3.1.2",
+        "http-errors": "~2.0.1",
+        "iconv-lite": "~0.4.24",
+        "unpipe": "~1.0.0"
+      },
+      "engines": {
+        "node": ">= 0.8"
+      }
+    },
+    "node_modules/safe-buffer": {
+      "version": "5.2.1",
+      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
+      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
+      "funding": [
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/feross"
+        },
+        {
+          "type": "patreon",
+          "url": "https://www.patreon.com/feross"
+        },
+        {
+          "type": "consulting",
+          "url": "https://feross.org/support"
+        }
+      ],
+      "license": "MIT"
+    },
+    "node_modules/safer-buffer": {
+      "version": "2.1.2",
+      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
+      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==",
+      "license": "MIT"
+    },
+    "node_modules/send": {
+      "version": "0.19.2",
+      "resolved": "https://registry.npmjs.org/send/-/send-0.19.2.tgz",
+      "integrity": "sha512-VMbMxbDeehAxpOtWJXlcUS5E8iXh6QmN+BkRX1GARS3wRaXEEgzCcB10gTQazO42tpNIya8xIyNx8fll1OFPrg==",
+      "license": "MIT",
+      "dependencies": {
+        "debug": "2.6.9",
+        "depd": "2.0.0",
+        "destroy": "1.2.0",
+        "encodeurl": "~2.0.0",
+        "escape-html": "~1.0.3",
+        "etag": "~1.8.1",
+        "fresh": "~0.5.2",
+        "http-errors": "~2.0.1",
+        "mime": "1.6.0",
+        "ms": "2.1.3",
+        "on-finished": "~2.4.1",
+        "range-parser": "~1.2.1",
+        "statuses": "~2.0.2"
+      },
+      "engines": {
+        "node": ">= 0.8.0"
+      }
+    },
+    "node_modules/send/node_modules/ms": {
+      "version": "2.1.3",
+      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
+      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
+      "license": "MIT"
+    },
+    "node_modules/serve-static": {
+      "version": "1.16.3",
+      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-1.16.3.tgz",
+      "integrity": "sha512-x0RTqQel6g5SY7Lg6ZreMmsOzncHFU7nhnRWkKgWuMTu5NN0DR5oruckMqRvacAN9d5w6ARnRBXl9xhDCgfMeA==",
+      "license": "MIT",
+      "dependencies": {
+        "encodeurl": "~2.0.0",
+        "escape-html": "~1.0.3",
+        "parseurl": "~1.3.3",
+        "send": "~0.19.1"
+      },
+      "engines": {
+        "node": ">= 0.8.0"
+      }
+    },
+    "node_modules/setprototypeof": {
+      "version": "1.2.0",
+      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
+      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==",
+      "license": "ISC"
+    },
+    "node_modules/side-channel": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
+      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
+      "license": "MIT",
+      "dependencies": {
+        "es-errors": "^1.3.0",
+        "object-inspect": "^1.13.3",
+        "side-channel-list": "^1.0.0",
+        "side-channel-map": "^1.0.1",
+        "side-channel-weakmap": "^1.0.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/side-channel-list": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz",
+      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
+      "license": "MIT",
+      "dependencies": {
+        "es-errors": "^1.3.0",
+        "object-inspect": "^1.13.3"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/side-channel-map": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz",
+      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bound": "^1.0.2",
+        "es-errors": "^1.3.0",
+        "get-intrinsic": "^1.2.5",
+        "object-inspect": "^1.13.3"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/side-channel-weakmap": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
+      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bound": "^1.0.2",
+        "es-errors": "^1.3.0",
+        "get-intrinsic": "^1.2.5",
+        "object-inspect": "^1.13.3",
+        "side-channel-map": "^1.0.1"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/socket.io": {
+      "version": "4.8.3",
+      "resolved": "https://registry.npmjs.org/socket.io/-/socket.io-4.8.3.tgz",
+      "integrity": "sha512-2Dd78bqzzjE6KPkD5fHZmDAKRNe3J15q+YHDrIsy9WEkqttc7GY+kT9OBLSMaPbQaEd0x1BjcmtMtXkfpc+T5A==",
+      "license": "MIT",
+      "dependencies": {
+        "accepts": "~1.3.4",
+        "base64id": "~2.0.0",
+        "cors": "~2.8.5",
+        "debug": "~4.4.1",
+        "engine.io": "~6.6.0",
+        "socket.io-adapter": "~2.5.2",
+        "socket.io-parser": "~4.2.4"
+      },
+      "engines": {
+        "node": ">=10.2.0"
+      }
+    },
+    "node_modules/socket.io-adapter": {
+      "version": "2.5.6",
+      "resolved": "https://registry.npmjs.org/socket.io-adapter/-/socket.io-adapter-2.5.6.tgz",
+      "integrity": "sha512-DkkO/dz7MGln0dHn5bmN3pPy+JmywNICWrJqVWiVOyvXjWQFIv9c2h24JrQLLFJ2aQVQf/Cvl1vblnd4r2apLQ==",
+      "license": "MIT",
+      "dependencies": {
+        "debug": "~4.4.1",
+        "ws": "~8.18.3"
+      }
+    },
+    "node_modules/socket.io-adapter/node_modules/debug": {
+      "version": "4.4.3",
+      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
+      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
+      "license": "MIT",
+      "dependencies": {
+        "ms": "^2.1.3"
+      },
+      "engines": {
+        "node": ">=6.0"
+      },
+      "peerDependenciesMeta": {
+        "supports-color": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/socket.io-adapter/node_modules/ms": {
+      "version": "2.1.3",
+      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
+      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
+      "license": "MIT"
+    },
+    "node_modules/socket.io-parser": {
+      "version": "4.2.5",
+      "resolved": "https://registry.npmjs.org/socket.io-parser/-/socket.io-parser-4.2.5.tgz",
+      "integrity": "sha512-bPMmpy/5WWKHea5Y/jYAP6k74A+hvmRCQaJuJB6I/ML5JZq/KfNieUVo/3Mh7SAqn7TyFdIo6wqYHInG1MU1bQ==",
+      "license": "MIT",
+      "dependencies": {
+        "@socket.io/component-emitter": "~3.1.0",
+        "debug": "~4.4.1"
+      },
+      "engines": {
+        "node": ">=10.0.0"
+      }
+    },
+    "node_modules/socket.io-parser/node_modules/debug": {
+      "version": "4.4.3",
+      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
+      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
+      "license": "MIT",
+      "dependencies": {
+        "ms": "^2.1.3"
+      },
+      "engines": {
+        "node": ">=6.0"
+      },
+      "peerDependenciesMeta": {
+        "supports-color": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/socket.io-parser/node_modules/ms": {
+      "version": "2.1.3",
+      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
+      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
+      "license": "MIT"
+    },
+    "node_modules/socket.io/node_modules/debug": {
+      "version": "4.4.3",
+      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
+      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
+      "license": "MIT",
+      "dependencies": {
+        "ms": "^2.1.3"
+      },
+      "engines": {
+        "node": ">=6.0"
+      },
+      "peerDependenciesMeta": {
+        "supports-color": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/socket.io/node_modules/ms": {
+      "version": "2.1.3",
+      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
+      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
+      "license": "MIT"
+    },
+    "node_modules/statuses": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.2.tgz",
+      "integrity": "sha512-DvEy55V3DB7uknRo+4iOGT5fP1slR8wQohVdknigZPMpMstaKJQWhwiYBACJE3Ul2pTnATihhBYnRhZQHGBiRw==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.8"
+      }
+    },
+    "node_modules/tail": {
+      "version": "2.2.6",
+      "resolved": "https://registry.npmjs.org/tail/-/tail-2.2.6.tgz",
+      "integrity": "sha512-IQ6G4wK/t8VBauYiGPLx+d3fA5XjSVagjWV5SIYzvEvglbQjwEcukeYI68JOPpdydjxhZ9sIgzRlSmwSpphHyw==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 6.0.0"
+      }
+    },
+    "node_modules/toidentifier": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
+      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
+      "license": "MIT",
+      "engines": {
+        "node": ">=0.6"
+      }
+    },
+    "node_modules/ts-node": {
+      "version": "10.9.2",
+      "resolved": "https://registry.npmjs.org/ts-node/-/ts-node-10.9.2.tgz",
+      "integrity": "sha512-f0FFpIdcHgn8zcPSbf1dRevwt047YMnaiJM3u2w2RewrB+fob/zePZcrOyQoLMMO7aBIddLcQIEK5dYjkLnGrQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@cspotcode/source-map-support": "^0.8.0",
+        "@tsconfig/node10": "^1.0.7",
+        "@tsconfig/node12": "^1.0.7",
+        "@tsconfig/node14": "^1.0.0",
+        "@tsconfig/node16": "^1.0.2",
+        "acorn": "^8.4.1",
+        "acorn-walk": "^8.1.1",
+        "arg": "^4.1.0",
+        "create-require": "^1.1.0",
+        "diff": "^4.0.1",
+        "make-error": "^1.1.1",
+        "v8-compile-cache-lib": "^3.0.1",
+        "yn": "3.1.1"
+      },
+      "bin": {
+        "ts-node": "dist/bin.js",
+        "ts-node-cwd": "dist/bin-cwd.js",
+        "ts-node-esm": "dist/bin-esm.js",
+        "ts-node-script": "dist/bin-script.js",
+        "ts-node-transpile-only": "dist/bin-transpile.js",
+        "ts-script": "dist/bin-script-deprecated.js"
+      },
+      "peerDependencies": {
+        "@swc/core": ">=1.2.50",
+        "@swc/wasm": ">=1.2.50",
+        "@types/node": "*",
+        "typescript": ">=2.7"
+      },
+      "peerDependenciesMeta": {
+        "@swc/core": {
+          "optional": true
+        },
+        "@swc/wasm": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/type-is": {
+      "version": "1.6.18",
+      "resolved": "https://registry.npmjs.org/type-is/-/type-is-1.6.18.tgz",
+      "integrity": "sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==",
+      "license": "MIT",
+      "dependencies": {
+        "media-typer": "0.3.0",
+        "mime-types": "~2.1.24"
+      },
+      "engines": {
+        "node": ">= 0.6"
+      }
+    },
+    "node_modules/typescript": {
+      "version": "5.9.3",
+      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.9.3.tgz",
+      "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "bin": {
+        "tsc": "bin/tsc",
+        "tsserver": "bin/tsserver"
+      },
+      "engines": {
+        "node": ">=14.17"
+      }
+    },
+    "node_modules/undici-types": {
+      "version": "6.21.0",
+      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz",
+      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==",
+      "license": "MIT"
+    },
+    "node_modules/unpipe": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
+      "integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.8"
+      }
+    },
+    "node_modules/utils-merge": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
+      "integrity": "sha512-pMZTvIkT1d+TFGvDOqodOclx0QWkkgi6Tdoa8gC8ffGAAqz9pzPTZWAybbsHHoED/ztMtkv/VoYTYyShUn81hA==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.4.0"
+      }
+    },
+    "node_modules/v8-compile-cache-lib": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/v8-compile-cache-lib/-/v8-compile-cache-lib-3.0.1.tgz",
+      "integrity": "sha512-wa7YjyUGfNZngI/vtK0UHAN+lgDCxBPCylVXGp0zu59Fz5aiGtNXaq3DhIov063MorB+VfufLh3JlF2KdTK3xg==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/vary": {
+      "version": "1.1.2",
+      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
+      "integrity": "sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.8"
+      }
+    },
+    "node_modules/ws": {
+      "version": "8.18.3",
+      "resolved": "https://registry.npmjs.org/ws/-/ws-8.18.3.tgz",
+      "integrity": "sha512-PEIGCY5tSlUt50cqyMXfCzX+oOPqN0vuGqWzbcJ2xvnkzkq46oOpz7dQaTDBdfICb4N14+GARUDw2XV2N4tvzg==",
+      "license": "MIT",
+      "engines": {
+        "node": ">=10.0.0"
+      },
+      "peerDependencies": {
+        "bufferutil": "^4.0.1",
+        "utf-8-validate": ">=5.0.2"
+      },
+      "peerDependenciesMeta": {
+        "bufferutil": {
+          "optional": true
+        },
+        "utf-8-validate": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/yn": {
+      "version": "3.1.1",
+      "resolved": "https://registry.npmjs.org/yn/-/yn-3.1.1.tgz",
+      "integrity": "sha512-Ux4ygGWsu2c7isFWe8Yu1YluJmqVhxqK2cLXNQA5AcC3QfbGNpM7fu0Y8b/z16pXLnFxZYvWhd3fhBY9DLmC6Q==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6"
+      }
+    }
+  }
+}
diff --git a/log-viewer-app/backend/package.json b/log-viewer-app/backend/package.json
new file mode 100644
index 0000000..be25e99
--- /dev/null
+++ b/log-viewer-app/backend/package.json
@@ -0,0 +1,25 @@
+
+{
+  "name": "log-viewer-backend",
+  "version": "1.0.0",
+  "description": "Backend for live log streaming",
+  "main": "dist/server.js",
+  "scripts": {
+    "start": "ts-node server.ts",
+    "build": "tsc",
+    "serve": "node dist/server.js"
+  },
+  "dependencies": {
+    "cors": "^2.8.5",
+    "express": "^4.18.2",
+    "socket.io": "^4.7.2",
+    "tail": "^2.2.6"
+  },
+  "devDependencies": {
+    "@types/cors": "^2.8.13",
+    "@types/express": "^4.17.17",
+    "@types/node": "^20.5.0",
+    "ts-node": "^10.9.1",
+    "typescript": "^5.1.6"
+  }
+}
diff --git a/log-viewer-app/backend/server.ts b/log-viewer-app/backend/server.ts
new file mode 100644
index 0000000..38edba9
--- /dev/null
+++ b/log-viewer-app/backend/server.ts
@@ -0,0 +1,58 @@
+
+import express from 'express';
+import { createServer } from 'http';
+import { Server } from 'socket.io';
+import { Tail } from 'tail';
+import cors from 'cors';
+import fs from 'fs';
+import path from 'path';
+
+const app = express();
+app.use(cors());
+
+const httpServer = createServer(app);
+const io = new Server(httpServer, {
+  cors: {
+    origin: "*",
+    methods: ["GET", "POST"]
+  }
+});
+
+const LOG_FILE_PATH = 'D:\\DedicatedServerLauncher\\VRisingServer\\BepInEx\\LogOutput.log';
+const PORT = 3001;
+
+// Ensure log file exists or handle missing file
+if (!fs.existsSync(LOG_FILE_PATH)) {
+  console.error(`Log file not found: ${LOG_FILE_PATH}`);
+  // In a real scenario, we might want to wait or exit. 
+  // For now, let's just log it.
+} else {
+    console.log(`Watching log file: ${LOG_FILE_PATH}`);
+    const tail = new Tail(LOG_FILE_PATH);
+
+    tail.on("line", (data) => {
+      io.emit('log-line', {
+        timestamp: new Date().toISOString(),
+        message: data
+      });
+    });
+
+    tail.on("error", (error) => {
+      console.error('Tail Error:', error);
+    });
+}
+
+io.on('connection', (socket) => {
+  console.log('Client connected:', socket.id);
+  
+  // Send a greeting or some initial data if needed
+  socket.emit('status', 'Connected to log stream');
+
+  socket.on('disconnect', () => {
+    console.log('Client disconnected:', socket.id);
+  });
+});
+
+httpServer.listen(PORT, () => {
+  console.log(`Server running on http://localhost:${PORT}`);
+});
diff --git a/log-viewer-app/backend/tsconfig.json b/log-viewer-app/backend/tsconfig.json
new file mode 100644
index 0000000..fad4bcd
--- /dev/null
+++ b/log-viewer-app/backend/tsconfig.json
@@ -0,0 +1,14 @@
+
+{
+  "compilerOptions": {
+    "target": "ESNext",
+    "module": "CommonJS",
+    "outDir": "./dist",
+    "rootDir": "./",
+    "strict": true,
+    "esModuleInterop": true,
+    "skipLibCheck": true,
+    "forceConsistentCasingInFileNames": true
+  },
+  "include": ["server.ts"]
+}
diff --git a/log-viewer-app/frontend/index.html b/log-viewer-app/frontend/index.html
new file mode 100644
index 0000000..bee3d7d
--- /dev/null
+++ b/log-viewer-app/frontend/index.html
@@ -0,0 +1,14 @@
+
+<!doctype html>
+<html lang="en">
+  <head>
+    <meta charset="UTF-8" />
+    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
+    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
+    <title>V-Automation Dashboard</title>
+  </head>
+  <body>
+    <div id="root"></div>
+    <script type="module" src="/src/main.tsx"></script>
+  </body>
+</html>
diff --git a/log-viewer-app/frontend/package-lock.json b/log-viewer-app/frontend/package-lock.json
new file mode 100644
index 0000000..dbfcea3
--- /dev/null
+++ b/log-viewer-app/frontend/package-lock.json
@@ -0,0 +1,2397 @@
+{
+  "name": "log-viewer-frontend",
+  "version": "0.0.0",
+  "lockfileVersion": 3,
+  "requires": true,
+  "packages": {
+    "": {
+      "name": "log-viewer-frontend",
+      "version": "0.0.0",
+      "dependencies": {
+        "clsx": "^2.0.0",
+        "date-fns": "^2.30.0",
+        "lucide-react": "^0.263.1",
+        "react": "^18.2.0",
+        "react-dom": "^18.2.0",
+        "socket.io-client": "^4.7.2",
+        "tailwind-merge": "^1.14.0"
+      },
+      "devDependencies": {
+        "@types/react": "^18.2.15",
+        "@types/react-dom": "^18.2.7",
+        "@vitejs/plugin-react": "^4.0.3",
+        "autoprefixer": "^10.4.14",
+        "postcss": "^8.4.27",
+        "tailwindcss": "^3.3.3",
+        "typescript": "^5.0.2",
+        "vite": "^4.4.5"
+      }
+    },
+    "node_modules/@alloc/quick-lru": {
+      "version": "5.2.0",
+      "resolved": "https://registry.npmjs.org/@alloc/quick-lru/-/quick-lru-5.2.0.tgz",
+      "integrity": "sha512-UrcABB+4bUrFABwbluTIBErXwvbsU/V7TZWfmbgJfbkwiBuziS9gxdODUyuiecfdGQ85jglMW6juS3+z5TsKLw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/@babel/code-frame": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.29.0.tgz",
+      "integrity": "sha512-9NhCeYjq9+3uxgdtp20LSiJXJvN0FeCtNGpJxuMFZ1Kv3cWUNb6DOhJwUvcVCzKGR66cw4njwM6hrJLqgOwbcw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-validator-identifier": "^7.28.5",
+        "js-tokens": "^4.0.0",
+        "picocolors": "^1.1.1"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/compat-data": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.29.0.tgz",
+      "integrity": "sha512-T1NCJqT/j9+cn8fvkt7jtwbLBfLC/1y1c7NtCeXFRgzGTsafi68MRv8yzkYSapBnFA6L3U2VSc02ciDzoAJhJg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/core": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.29.0.tgz",
+      "integrity": "sha512-CGOfOJqWjg2qW/Mb6zNsDm+u5vFQ8DxXfbM09z69p5Z6+mE1ikP2jUXw+j42Pf1XTYED2Rni5f95npYeuwMDQA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/code-frame": "^7.29.0",
+        "@babel/generator": "^7.29.0",
+        "@babel/helper-compilation-targets": "^7.28.6",
+        "@babel/helper-module-transforms": "^7.28.6",
+        "@babel/helpers": "^7.28.6",
+        "@babel/parser": "^7.29.0",
+        "@babel/template": "^7.28.6",
+        "@babel/traverse": "^7.29.0",
+        "@babel/types": "^7.29.0",
+        "@jridgewell/remapping": "^2.3.5",
+        "convert-source-map": "^2.0.0",
+        "debug": "^4.1.0",
+        "gensync": "^1.0.0-beta.2",
+        "json5": "^2.2.3",
+        "semver": "^6.3.1"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "funding": {
+        "type": "opencollective",
+        "url": "https://opencollective.com/babel"
+      }
+    },
+    "node_modules/@babel/generator": {
+      "version": "7.29.1",
+      "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.29.1.tgz",
+      "integrity": "sha512-qsaF+9Qcm2Qv8SRIMMscAvG4O3lJ0F1GuMo5HR/Bp02LopNgnZBC/EkbevHFeGs4ls/oPz9v+Bsmzbkbe+0dUw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/parser": "^7.29.0",
+        "@babel/types": "^7.29.0",
+        "@jridgewell/gen-mapping": "^0.3.12",
+        "@jridgewell/trace-mapping": "^0.3.28",
+        "jsesc": "^3.0.2"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-compilation-targets": {
+      "version": "7.28.6",
+      "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.28.6.tgz",
+      "integrity": "sha512-JYtls3hqi15fcx5GaSNL7SCTJ2MNmjrkHXg4FSpOA/grxK8KwyZ5bubHsCq8FXCkua6xhuaaBit+3b7+VZRfcA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/compat-data": "^7.28.6",
+        "@babel/helper-validator-option": "^7.27.1",
+        "browserslist": "^4.24.0",
+        "lru-cache": "^5.1.1",
+        "semver": "^6.3.1"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-globals": {
+      "version": "7.28.0",
+      "resolved": "https://registry.npmjs.org/@babel/helper-globals/-/helper-globals-7.28.0.tgz",
+      "integrity": "sha512-+W6cISkXFa1jXsDEdYA8HeevQT/FULhxzR99pxphltZcVaugps53THCeiWA8SguxxpSp3gKPiuYfSWopkLQ4hw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-module-imports": {
+      "version": "7.28.6",
+      "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.28.6.tgz",
+      "integrity": "sha512-l5XkZK7r7wa9LucGw9LwZyyCUscb4x37JWTPz7swwFE/0FMQAGpiWUZn8u9DzkSBWEcK25jmvubfpw2dnAMdbw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/traverse": "^7.28.6",
+        "@babel/types": "^7.28.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-module-transforms": {
+      "version": "7.28.6",
+      "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.28.6.tgz",
+      "integrity": "sha512-67oXFAYr2cDLDVGLXTEABjdBJZ6drElUSI7WKp70NrpyISso3plG9SAGEF6y7zbha/wOzUByWWTJvEDVNIUGcA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-module-imports": "^7.28.6",
+        "@babel/helper-validator-identifier": "^7.28.5",
+        "@babel/traverse": "^7.28.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0"
+      }
+    },
+    "node_modules/@babel/helper-plugin-utils": {
+      "version": "7.28.6",
+      "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.28.6.tgz",
+      "integrity": "sha512-S9gzZ/bz83GRysI7gAD4wPT/AI3uCnY+9xn+Mx/KPs2JwHJIz1W8PZkg2cqyt3RNOBM8ejcXhV6y8Og7ly/Dug==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-string-parser": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
+      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-validator-identifier": {
+      "version": "7.28.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
+      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-validator-option": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.27.1.tgz",
+      "integrity": "sha512-YvjJow9FxbhFFKDSuFnVCe2WxXk1zWc22fFePVNEaWJEu8IrZVlda6N0uHwzZrUM1il7NC9Mlp4MaJYbYd9JSg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helpers": {
+      "version": "7.28.6",
+      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.28.6.tgz",
+      "integrity": "sha512-xOBvwq86HHdB7WUDTfKfT/Vuxh7gElQ+Sfti2Cy6yIWNW05P8iUslOVcZ4/sKbE+/jQaukQAdz/gf3724kYdqw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/template": "^7.28.6",
+        "@babel/types": "^7.28.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/parser": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
+      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/types": "^7.29.0"
+      },
+      "bin": {
+        "parser": "bin/babel-parser.js"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-react-jsx-self": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-self/-/plugin-transform-react-jsx-self-7.27.1.tgz",
+      "integrity": "sha512-6UzkCs+ejGdZ5mFFC/OCUrv028ab2fp1znZmCZjAOBKiBK2jXD1O+BPSfX8X2qjJ75fZBMSnQn3Rq2mrBJK2mw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.27.1"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-react-jsx-source": {
+      "version": "7.27.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-source/-/plugin-transform-react-jsx-source-7.27.1.tgz",
+      "integrity": "sha512-zbwoTsBruTeKB9hSq73ha66iFeJHuaFkUbwvqElnygoNbj/jHRsSeokowZFN3CZ64IvEqcmmkVe89OPXc7ldAw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.27.1"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/runtime": {
+      "version": "7.28.6",
+      "resolved": "https://registry.npmjs.org/@babel/runtime/-/runtime-7.28.6.tgz",
+      "integrity": "sha512-05WQkdpL9COIMz4LjTxGpPNCdlpyimKppYNoJ5Di5EUObifl8t4tuLuUBBZEpoLYOmfvIWrsp9fCl0HoPRVTdA==",
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/template": {
+      "version": "7.28.6",
+      "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.28.6.tgz",
+      "integrity": "sha512-YA6Ma2KsCdGb+WC6UpBVFJGXL58MDA6oyONbjyF/+5sBgxY/dwkhLogbMT2GXXyU84/IhRw/2D1Os1B/giz+BQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/code-frame": "^7.28.6",
+        "@babel/parser": "^7.28.6",
+        "@babel/types": "^7.28.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/traverse": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.29.0.tgz",
+      "integrity": "sha512-4HPiQr0X7+waHfyXPZpWPfWL/J7dcN1mx9gL6WdQVMbPnF3+ZhSMs8tCxN7oHddJE9fhNE7+lxdnlyemKfJRuA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/code-frame": "^7.29.0",
+        "@babel/generator": "^7.29.0",
+        "@babel/helper-globals": "^7.28.0",
+        "@babel/parser": "^7.29.0",
+        "@babel/template": "^7.28.6",
+        "@babel/types": "^7.29.0",
+        "debug": "^4.3.1"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/types": {
+      "version": "7.29.0",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
+      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/helper-string-parser": "^7.27.1",
+        "@babel/helper-validator-identifier": "^7.28.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@esbuild/android-arm": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.18.20.tgz",
+      "integrity": "sha512-fyi7TDI/ijKKNZTUJAQqiG5T7YjJXgnzkURqmGj13C6dCqckZBLdl4h7bkhHt/t0WP+zO9/zwroDvANaOqO5Sw==",
+      "cpu": [
+        "arm"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "android"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/android-arm64": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.18.20.tgz",
+      "integrity": "sha512-Nz4rJcchGDtENV0eMKUNa6L12zz2zBDXuhj/Vjh18zGqB44Bi7MBMSXjgunJgjRhCmKOjnPuZp4Mb6OKqtMHLQ==",
+      "cpu": [
+        "arm64"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "android"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/android-x64": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.18.20.tgz",
+      "integrity": "sha512-8GDdlePJA8D6zlZYJV/jnrRAi6rOiNaCC/JclcXpB+KIuvfBN4owLtgzY2bsxnx666XjJx2kDPUmnTtR8qKQUg==",
+      "cpu": [
+        "x64"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "android"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/darwin-arm64": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.18.20.tgz",
+      "integrity": "sha512-bxRHW5kHU38zS2lPTPOyuyTm+S+eobPUnTNkdJEfAddYgEcll4xkT8DB9d2008DtTbl7uJag2HuE5NZAZgnNEA==",
+      "cpu": [
+        "arm64"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "darwin"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/darwin-x64": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.18.20.tgz",
+      "integrity": "sha512-pc5gxlMDxzm513qPGbCbDukOdsGtKhfxD1zJKXjCCcU7ju50O7MeAZ8c4krSJcOIJGFR+qx21yMMVYwiQvyTyQ==",
+      "cpu": [
+        "x64"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "darwin"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/freebsd-arm64": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.18.20.tgz",
+      "integrity": "sha512-yqDQHy4QHevpMAaxhhIwYPMv1NECwOvIpGCZkECn8w2WFHXjEwrBn3CeNIYsibZ/iZEUemj++M26W3cNR5h+Tw==",
+      "cpu": [
+        "arm64"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "freebsd"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/freebsd-x64": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.18.20.tgz",
+      "integrity": "sha512-tgWRPPuQsd3RmBZwarGVHZQvtzfEBOreNuxEMKFcd5DaDn2PbBxfwLcj4+aenoh7ctXcbXmOQIn8HI6mCSw5MQ==",
+      "cpu": [
+        "x64"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "freebsd"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/linux-arm": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.18.20.tgz",
+      "integrity": "sha512-/5bHkMWnq1EgKr1V+Ybz3s1hWXok7mDFUMQ4cG10AfW3wL02PSZi5kFpYKrptDsgb2WAJIvRcDm+qIvXf/apvg==",
+      "cpu": [
+        "arm"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "linux"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/linux-arm64": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.18.20.tgz",
+      "integrity": "sha512-2YbscF+UL7SQAVIpnWvYwM+3LskyDmPhe31pE7/aoTMFKKzIc9lLbyGUpmmb8a8AixOL61sQ/mFh3jEjHYFvdA==",
+      "cpu": [
+        "arm64"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "linux"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/linux-ia32": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.18.20.tgz",
+      "integrity": "sha512-P4etWwq6IsReT0E1KHU40bOnzMHoH73aXp96Fs8TIT6z9Hu8G6+0SHSw9i2isWrD2nbx2qo5yUqACgdfVGx7TA==",
+      "cpu": [
+        "ia32"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "linux"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/linux-loong64": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.18.20.tgz",
+      "integrity": "sha512-nXW8nqBTrOpDLPgPY9uV+/1DjxoQ7DoB2N8eocyq8I9XuqJ7BiAMDMf9n1xZM9TgW0J8zrquIb/A7s3BJv7rjg==",
+      "cpu": [
+        "loong64"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "linux"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/linux-mips64el": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.18.20.tgz",
+      "integrity": "sha512-d5NeaXZcHp8PzYy5VnXV3VSd2D328Zb+9dEq5HE6bw6+N86JVPExrA6O68OPwobntbNJ0pzCpUFZTo3w0GyetQ==",
+      "cpu": [
+        "mips64el"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "linux"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/linux-ppc64": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.18.20.tgz",
+      "integrity": "sha512-WHPyeScRNcmANnLQkq6AfyXRFr5D6N2sKgkFo2FqguP44Nw2eyDlbTdZwd9GYk98DZG9QItIiTlFLHJHjxP3FA==",
+      "cpu": [
+        "ppc64"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "linux"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/linux-riscv64": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.18.20.tgz",
+      "integrity": "sha512-WSxo6h5ecI5XH34KC7w5veNnKkju3zBRLEQNY7mv5mtBmrP/MjNBCAlsM2u5hDBlS3NGcTQpoBvRzqBcRtpq1A==",
+      "cpu": [
+        "riscv64"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "linux"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/linux-s390x": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.18.20.tgz",
+      "integrity": "sha512-+8231GMs3mAEth6Ja1iK0a1sQ3ohfcpzpRLH8uuc5/KVDFneH6jtAJLFGafpzpMRO6DzJ6AvXKze9LfFMrIHVQ==",
+      "cpu": [
+        "s390x"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "linux"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/linux-x64": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.18.20.tgz",
+      "integrity": "sha512-UYqiqemphJcNsFEskc73jQ7B9jgwjWrSayxawS6UVFZGWrAAtkzjxSqnoclCXxWtfwLdzU+vTpcNYhpn43uP1w==",
+      "cpu": [
+        "x64"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "linux"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/netbsd-x64": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.18.20.tgz",
+      "integrity": "sha512-iO1c++VP6xUBUmltHZoMtCUdPlnPGdBom6IrO4gyKPFFVBKioIImVooR5I83nTew5UOYrk3gIJhbZh8X44y06A==",
+      "cpu": [
+        "x64"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "netbsd"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/openbsd-x64": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.18.20.tgz",
+      "integrity": "sha512-e5e4YSsuQfX4cxcygw/UCPIEP6wbIL+se3sxPdCiMbFLBWu0eiZOJ7WoD+ptCLrmjZBK1Wk7I6D/I3NglUGOxg==",
+      "cpu": [
+        "x64"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "openbsd"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/sunos-x64": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.18.20.tgz",
+      "integrity": "sha512-kDbFRFp0YpTQVVrqUd5FTYmWo45zGaXe0X8E1G/LKFC0v8x0vWrhOWSLITcCn63lmZIxfOMXtCfti/RxN/0wnQ==",
+      "cpu": [
+        "x64"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "sunos"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/win32-arm64": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.18.20.tgz",
+      "integrity": "sha512-ddYFR6ItYgoaq4v4JmQQaAI5s7npztfV4Ag6NrhiaW0RrnOXqBkgwZLofVTlq1daVTQNhtI5oieTvkRPfZrePg==",
+      "cpu": [
+        "arm64"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "win32"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/win32-ia32": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.18.20.tgz",
+      "integrity": "sha512-Wv7QBi3ID/rROT08SABTS7eV4hX26sVduqDOTe1MvGMjNd3EjOz4b7zeexIR62GTIEKrfJXKL9LFxTYgkyeu7g==",
+      "cpu": [
+        "ia32"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "win32"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@esbuild/win32-x64": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.18.20.tgz",
+      "integrity": "sha512-kTdfRcSiDfQca/y9QIkng02avJ+NCaQvrMejlsB3RRv5sE9rRoeBPISaZpKxHELzRxZyLvNts1P27W3wV+8geQ==",
+      "cpu": [
+        "x64"
+      ],
+      "dev": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "win32"
+      ],
+      "engines": {
+        "node": ">=12"
+      }
+    },
+    "node_modules/@jridgewell/gen-mapping": {
+      "version": "0.3.13",
+      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
+      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/sourcemap-codec": "^1.5.0",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      }
+    },
+    "node_modules/@jridgewell/remapping": {
+      "version": "2.3.5",
+      "resolved": "https://registry.npmjs.org/@jridgewell/remapping/-/remapping-2.3.5.tgz",
+      "integrity": "sha512-LI9u/+laYG4Ds1TDKSJW2YPrIlcVYOwi2fUC6xB43lueCjgxV4lffOCZCtYFiH6TNOX+tQKXx97T4IKHbhyHEQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.5",
+        "@jridgewell/trace-mapping": "^0.3.24"
+      }
+    },
+    "node_modules/@jridgewell/resolve-uri": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
+      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@jridgewell/sourcemap-codec": {
+      "version": "1.5.5",
+      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
+      "integrity": "sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/@jridgewell/trace-mapping": {
+      "version": "0.3.31",
+      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
+      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/resolve-uri": "^3.1.0",
+        "@jridgewell/sourcemap-codec": "^1.4.14"
+      }
+    },
+    "node_modules/@nodelib/fs.scandir": {
+      "version": "2.1.5",
+      "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
+      "integrity": "sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@nodelib/fs.stat": "2.0.5",
+        "run-parallel": "^1.1.9"
+      },
+      "engines": {
+        "node": ">= 8"
+      }
+    },
+    "node_modules/@nodelib/fs.stat": {
+      "version": "2.0.5",
+      "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz",
+      "integrity": "sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">= 8"
+      }
+    },
+    "node_modules/@nodelib/fs.walk": {
+      "version": "1.2.8",
+      "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz",
+      "integrity": "sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@nodelib/fs.scandir": "2.1.5",
+        "fastq": "^1.6.0"
+      },
+      "engines": {
+        "node": ">= 8"
+      }
+    },
+    "node_modules/@rolldown/pluginutils": {
+      "version": "1.0.0-beta.27",
+      "resolved": "https://registry.npmjs.org/@rolldown/pluginutils/-/pluginutils-1.0.0-beta.27.tgz",
+      "integrity": "sha512-+d0F4MKMCbeVUJwG96uQ4SgAznZNSq93I3V+9NHA4OpvqG8mRCpGdKmK8l/dl02h2CCDHwW2FqilnTyDcAnqjA==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/@socket.io/component-emitter": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/@socket.io/component-emitter/-/component-emitter-3.1.2.tgz",
+      "integrity": "sha512-9BCxFwvbGg/RsZK9tjXd8s4UcwR0MWeFQ1XEKIQVVvAGJyINdrqKMcTRyLoK8Rse1GjzLV9cwjWV1olXRWEXVA==",
+      "license": "MIT"
+    },
+    "node_modules/@types/babel__core": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@types/babel__core/-/babel__core-7.20.5.tgz",
+      "integrity": "sha512-qoQprZvz5wQFJwMDqeseRXWv3rqMvhgpbXFfVyWhbx9X47POIA6i/+dXefEmZKoAgOaTdaIgNSMqMIU61yRyzA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/parser": "^7.20.7",
+        "@babel/types": "^7.20.7",
+        "@types/babel__generator": "*",
+        "@types/babel__template": "*",
+        "@types/babel__traverse": "*"
+      }
+    },
+    "node_modules/@types/babel__generator": {
+      "version": "7.27.0",
+      "resolved": "https://registry.npmjs.org/@types/babel__generator/-/babel__generator-7.27.0.tgz",
+      "integrity": "sha512-ufFd2Xi92OAVPYsy+P4n7/U7e68fex0+Ee8gSG9KX7eo084CWiQ4sdxktvdl0bOPupXtVJPY19zk6EwWqUQ8lg==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/types": "^7.0.0"
+      }
+    },
+    "node_modules/@types/babel__template": {
+      "version": "7.4.4",
+      "resolved": "https://registry.npmjs.org/@types/babel__template/-/babel__template-7.4.4.tgz",
+      "integrity": "sha512-h/NUaSyG5EyxBIp8YRxo4RMe2/qQgvyowRwVMzhYhBCONbW8PUsg4lkFMrhgZhUe5z3L3MiLDuvyJ/CaPa2A8A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/parser": "^7.1.0",
+        "@babel/types": "^7.0.0"
+      }
+    },
+    "node_modules/@types/babel__traverse": {
+      "version": "7.28.0",
+      "resolved": "https://registry.npmjs.org/@types/babel__traverse/-/babel__traverse-7.28.0.tgz",
+      "integrity": "sha512-8PvcXf70gTDZBgt9ptxJ8elBeBjcLOAcOtoO/mPJjtji1+CdGbHgm77om1GrsPxsiE+uXIpNSK64UYaIwQXd4Q==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/types": "^7.28.2"
+      }
+    },
+    "node_modules/@types/prop-types": {
+      "version": "15.7.15",
+      "resolved": "https://registry.npmjs.org/@types/prop-types/-/prop-types-15.7.15.tgz",
+      "integrity": "sha512-F6bEyamV9jKGAFBEmlQnesRPGOQqS2+Uwi0Em15xenOxHaf2hv6L8YCVn3rPdPJOiJfPiCnLIRyvwVaqMY3MIw==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/@types/react": {
+      "version": "18.3.28",
+      "resolved": "https://registry.npmjs.org/@types/react/-/react-18.3.28.tgz",
+      "integrity": "sha512-z9VXpC7MWrhfWipitjNdgCauoMLRdIILQsAEV+ZesIzBq/oUlxk0m3ApZuMFCXdnS4U7KrI+l3WRUEGQ8K1QKw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@types/prop-types": "*",
+        "csstype": "^3.2.2"
+      }
+    },
+    "node_modules/@types/react-dom": {
+      "version": "18.3.7",
+      "resolved": "https://registry.npmjs.org/@types/react-dom/-/react-dom-18.3.7.tgz",
+      "integrity": "sha512-MEe3UeoENYVFXzoXEWsvcpg6ZvlrFNlOQ7EOsvhI3CfAXwzPfO8Qwuxd40nepsYKqyyVQnTdEfv68q91yLcKrQ==",
+      "dev": true,
+      "license": "MIT",
+      "peerDependencies": {
+        "@types/react": "^18.0.0"
+      }
+    },
+    "node_modules/@vitejs/plugin-react": {
+      "version": "4.7.0",
+      "resolved": "https://registry.npmjs.org/@vitejs/plugin-react/-/plugin-react-4.7.0.tgz",
+      "integrity": "sha512-gUu9hwfWvvEDBBmgtAowQCojwZmJ5mcLn3aufeCsitijs3+f2NsrPtlAWIR6OPiqljl96GVCUbLe0HyqIpVaoA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@babel/core": "^7.28.0",
+        "@babel/plugin-transform-react-jsx-self": "^7.27.1",
+        "@babel/plugin-transform-react-jsx-source": "^7.27.1",
+        "@rolldown/pluginutils": "1.0.0-beta.27",
+        "@types/babel__core": "^7.20.5",
+        "react-refresh": "^0.17.0"
+      },
+      "engines": {
+        "node": "^14.18.0 || >=16.0.0"
+      },
+      "peerDependencies": {
+        "vite": "^4.2.0 || ^5.0.0 || ^6.0.0 || ^7.0.0"
+      }
+    },
+    "node_modules/any-promise": {
+      "version": "1.3.0",
+      "resolved": "https://registry.npmjs.org/any-promise/-/any-promise-1.3.0.tgz",
+      "integrity": "sha512-7UvmKalWRt1wgjL1RrGxoSJW/0QZFIegpeGvZG9kjp8vrRu55XTHbwnqq2GpXm9uLbcuhxm3IqX9OB4MZR1b2A==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/anymatch": {
+      "version": "3.1.3",
+      "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.3.tgz",
+      "integrity": "sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "normalize-path": "^3.0.0",
+        "picomatch": "^2.0.4"
+      },
+      "engines": {
+        "node": ">= 8"
+      }
+    },
+    "node_modules/arg": {
+      "version": "5.0.2",
+      "resolved": "https://registry.npmjs.org/arg/-/arg-5.0.2.tgz",
+      "integrity": "sha512-PYjyFOLKQ9y57JvQ6QLo8dAgNqswh8M1RMJYdQduT6xbWSgK36P/Z/v+p888pM69jMMfS8Xd8F6I1kQ/I9HUGg==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/autoprefixer": {
+      "version": "10.4.24",
+      "resolved": "https://registry.npmjs.org/autoprefixer/-/autoprefixer-10.4.24.tgz",
+      "integrity": "sha512-uHZg7N9ULTVbutaIsDRoUkoS8/h3bdsmVJYZ5l3wv8Cp/6UIIoRDm90hZ+BwxUj/hGBEzLxdHNSKuFpn8WOyZw==",
+      "dev": true,
+      "funding": [
+        {
+          "type": "opencollective",
+          "url": "https://opencollective.com/postcss/"
+        },
+        {
+          "type": "tidelift",
+          "url": "https://tidelift.com/funding/github/npm/autoprefixer"
+        },
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/ai"
+        }
+      ],
+      "license": "MIT",
+      "dependencies": {
+        "browserslist": "^4.28.1",
+        "caniuse-lite": "^1.0.30001766",
+        "fraction.js": "^5.3.4",
+        "picocolors": "^1.1.1",
+        "postcss-value-parser": "^4.2.0"
+      },
+      "bin": {
+        "autoprefixer": "bin/autoprefixer"
+      },
+      "engines": {
+        "node": "^10 || ^12 || >=14"
+      },
+      "peerDependencies": {
+        "postcss": "^8.1.0"
+      }
+    },
+    "node_modules/baseline-browser-mapping": {
+      "version": "2.9.19",
+      "resolved": "https://registry.npmjs.org/baseline-browser-mapping/-/baseline-browser-mapping-2.9.19.tgz",
+      "integrity": "sha512-ipDqC8FrAl/76p2SSWKSI+H9tFwm7vYqXQrItCuiVPt26Km0jS+NzSsBWAaBusvSbQcfJG+JitdMm+wZAgTYqg==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "bin": {
+        "baseline-browser-mapping": "dist/cli.js"
+      }
+    },
+    "node_modules/binary-extensions": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.3.0.tgz",
+      "integrity": "sha512-Ceh+7ox5qe7LJuLHoY0feh3pHuUDHAcRUeyL2VYghZwfpkNIy/+8Ocg0a3UuSoYzavmylwuLWQOf3hl0jjMMIw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/braces": {
+      "version": "3.0.3",
+      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
+      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "fill-range": "^7.1.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/browserslist": {
+      "version": "4.28.1",
+      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.28.1.tgz",
+      "integrity": "sha512-ZC5Bd0LgJXgwGqUknZY/vkUQ04r8NXnJZ3yYi4vDmSiZmC/pdSN0NbNRPxZpbtO4uAfDUAFffO8IZoM3Gj8IkA==",
+      "dev": true,
+      "funding": [
+        {
+          "type": "opencollective",
+          "url": "https://opencollective.com/browserslist"
+        },
+        {
+          "type": "tidelift",
+          "url": "https://tidelift.com/funding/github/npm/browserslist"
+        },
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/ai"
+        }
+      ],
+      "license": "MIT",
+      "dependencies": {
+        "baseline-browser-mapping": "^2.9.0",
+        "caniuse-lite": "^1.0.30001759",
+        "electron-to-chromium": "^1.5.263",
+        "node-releases": "^2.0.27",
+        "update-browserslist-db": "^1.2.0"
+      },
+      "bin": {
+        "browserslist": "cli.js"
+      },
+      "engines": {
+        "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
+      }
+    },
+    "node_modules/camelcase-css": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/camelcase-css/-/camelcase-css-2.0.1.tgz",
+      "integrity": "sha512-QOSvevhslijgYwRx6Rv7zKdMF8lbRmx+uQGx2+vDc+KI/eBnsy9kit5aj23AgGu3pa4t9AgwbnXWqS+iOY+2aA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">= 6"
+      }
+    },
+    "node_modules/caniuse-lite": {
+      "version": "1.0.30001770",
+      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001770.tgz",
+      "integrity": "sha512-x/2CLQ1jHENRbHg5PSId2sXq1CIO1CISvwWAj027ltMVG2UNgW+w9oH2+HzgEIRFembL8bUlXtfbBHR1fCg2xw==",
+      "dev": true,
+      "funding": [
+        {
+          "type": "opencollective",
+          "url": "https://opencollective.com/browserslist"
+        },
+        {
+          "type": "tidelift",
+          "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
+        },
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/ai"
+        }
+      ],
+      "license": "CC-BY-4.0"
+    },
+    "node_modules/chokidar": {
+      "version": "3.6.0",
+      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.6.0.tgz",
+      "integrity": "sha512-7VT13fmjotKpGipCW9JEQAusEPE+Ei8nl6/g4FBAmIm0GOOLMua9NDDo/DWp0ZAxCr3cPq5ZpBqmPAQgDda2Pw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "anymatch": "~3.1.2",
+        "braces": "~3.0.2",
+        "glob-parent": "~5.1.2",
+        "is-binary-path": "~2.1.0",
+        "is-glob": "~4.0.1",
+        "normalize-path": "~3.0.0",
+        "readdirp": "~3.6.0"
+      },
+      "engines": {
+        "node": ">= 8.10.0"
+      },
+      "funding": {
+        "url": "https://paulmillr.com/funding/"
+      },
+      "optionalDependencies": {
+        "fsevents": "~2.3.2"
+      }
+    },
+    "node_modules/chokidar/node_modules/glob-parent": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
+      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "is-glob": "^4.0.1"
+      },
+      "engines": {
+        "node": ">= 6"
+      }
+    },
+    "node_modules/clsx": {
+      "version": "2.1.1",
+      "resolved": "https://registry.npmjs.org/clsx/-/clsx-2.1.1.tgz",
+      "integrity": "sha512-eYm0QWBtUrBWZWG0d386OGAw16Z995PiOVo2B7bjWSbHedGl5e0ZWaq65kOGgUSNesEIDkB9ISbTg/JK9dhCZA==",
+      "license": "MIT",
+      "engines": {
+        "node": ">=6"
+      }
+    },
+    "node_modules/commander": {
+      "version": "4.1.1",
+      "resolved": "https://registry.npmjs.org/commander/-/commander-4.1.1.tgz",
+      "integrity": "sha512-NOKm8xhkzAjzFx8B2v5OAHT+u5pRQc2UCa2Vq9jYL/31o2wi9mxBA7LIFs3sV5VSC49z6pEhfbMULvShKj26WA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">= 6"
+      }
+    },
+    "node_modules/convert-source-map": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-2.0.0.tgz",
+      "integrity": "sha512-Kvp459HrV2FEJ1CAsi1Ku+MY3kasH19TFykTz2xWmMeq6bk2NU3XXvfJ+Q61m0xktWwt+1HSYf3JZsTms3aRJg==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/cssesc": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/cssesc/-/cssesc-3.0.0.tgz",
+      "integrity": "sha512-/Tb/JcjK111nNScGob5MNtsntNM1aCNUDipB/TkwZFhyDrrE47SOx/18wF2bbjgc3ZzCSKW1T5nt5EbFoAz/Vg==",
+      "dev": true,
+      "license": "MIT",
+      "bin": {
+        "cssesc": "bin/cssesc"
+      },
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/csstype": {
+      "version": "3.2.3",
+      "resolved": "https://registry.npmjs.org/csstype/-/csstype-3.2.3.tgz",
+      "integrity": "sha512-z1HGKcYy2xA8AGQfwrn0PAy+PB7X/GSj3UVJW9qKyn43xWa+gl5nXmU4qqLMRzWVLFC8KusUX8T/0kCiOYpAIQ==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/date-fns": {
+      "version": "2.30.0",
+      "resolved": "https://registry.npmjs.org/date-fns/-/date-fns-2.30.0.tgz",
+      "integrity": "sha512-fnULvOpxnC5/Vg3NCiWelDsLiUc9bRwAPs/+LfTLNvetFCtCTN+yQz15C/fs4AwX1R9K5GLtLfn8QW+dWisaAw==",
+      "license": "MIT",
+      "dependencies": {
+        "@babel/runtime": "^7.21.0"
+      },
+      "engines": {
+        "node": ">=0.11"
+      },
+      "funding": {
+        "type": "opencollective",
+        "url": "https://opencollective.com/date-fns"
+      }
+    },
+    "node_modules/debug": {
+      "version": "4.4.3",
+      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
+      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
+      "license": "MIT",
+      "dependencies": {
+        "ms": "^2.1.3"
+      },
+      "engines": {
+        "node": ">=6.0"
+      },
+      "peerDependenciesMeta": {
+        "supports-color": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/didyoumean": {
+      "version": "1.2.2",
+      "resolved": "https://registry.npmjs.org/didyoumean/-/didyoumean-1.2.2.tgz",
+      "integrity": "sha512-gxtyfqMg7GKyhQmb056K7M3xszy/myH8w+B4RT+QXBQsvAOdc3XymqDDPHx1BgPgsdAA5SIifona89YtRATDzw==",
+      "dev": true,
+      "license": "Apache-2.0"
+    },
+    "node_modules/dlv": {
+      "version": "1.1.3",
+      "resolved": "https://registry.npmjs.org/dlv/-/dlv-1.1.3.tgz",
+      "integrity": "sha512-+HlytyjlPKnIG8XuRG8WvmBP8xs8P71y+SKKS6ZXWoEgLuePxtDoUEiH7WkdePWrQ5JBpE6aoVqfZfJUQkjXwA==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/electron-to-chromium": {
+      "version": "1.5.286",
+      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.286.tgz",
+      "integrity": "sha512-9tfDXhJ4RKFNerfjdCcZfufu49vg620741MNs26a9+bhLThdB+plgMeou98CAaHu/WATj2iHOOHTp1hWtABj2A==",
+      "dev": true,
+      "license": "ISC"
+    },
+    "node_modules/engine.io-client": {
+      "version": "6.6.4",
+      "resolved": "https://registry.npmjs.org/engine.io-client/-/engine.io-client-6.6.4.tgz",
+      "integrity": "sha512-+kjUJnZGwzewFDw951CDWcwj35vMNf2fcj7xQWOctq1F2i1jkDdVvdFG9kM/BEChymCH36KgjnW0NsL58JYRxw==",
+      "license": "MIT",
+      "dependencies": {
+        "@socket.io/component-emitter": "~3.1.0",
+        "debug": "~4.4.1",
+        "engine.io-parser": "~5.2.1",
+        "ws": "~8.18.3",
+        "xmlhttprequest-ssl": "~2.1.1"
+      }
+    },
+    "node_modules/engine.io-parser": {
+      "version": "5.2.3",
+      "resolved": "https://registry.npmjs.org/engine.io-parser/-/engine.io-parser-5.2.3.tgz",
+      "integrity": "sha512-HqD3yTBfnBxIrbnM1DoD6Pcq8NECnh8d4As1Qgh0z5Gg3jRRIqijury0CL3ghu/edArpUYiYqQiDUQBIs4np3Q==",
+      "license": "MIT",
+      "engines": {
+        "node": ">=10.0.0"
+      }
+    },
+    "node_modules/esbuild": {
+      "version": "0.18.20",
+      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.18.20.tgz",
+      "integrity": "sha512-ceqxoedUrcayh7Y7ZX6NdbbDzGROiyVBgC4PriJThBKSVPWnnFHZAkfI1lJT8QFkOwH4qOS2SJkS4wvpGl8BpA==",
+      "dev": true,
+      "hasInstallScript": true,
+      "license": "MIT",
+      "bin": {
+        "esbuild": "bin/esbuild"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "optionalDependencies": {
+        "@esbuild/android-arm": "0.18.20",
+        "@esbuild/android-arm64": "0.18.20",
+        "@esbuild/android-x64": "0.18.20",
+        "@esbuild/darwin-arm64": "0.18.20",
+        "@esbuild/darwin-x64": "0.18.20",
+        "@esbuild/freebsd-arm64": "0.18.20",
+        "@esbuild/freebsd-x64": "0.18.20",
+        "@esbuild/linux-arm": "0.18.20",
+        "@esbuild/linux-arm64": "0.18.20",
+        "@esbuild/linux-ia32": "0.18.20",
+        "@esbuild/linux-loong64": "0.18.20",
+        "@esbuild/linux-mips64el": "0.18.20",
+        "@esbuild/linux-ppc64": "0.18.20",
+        "@esbuild/linux-riscv64": "0.18.20",
+        "@esbuild/linux-s390x": "0.18.20",
+        "@esbuild/linux-x64": "0.18.20",
+        "@esbuild/netbsd-x64": "0.18.20",
+        "@esbuild/openbsd-x64": "0.18.20",
+        "@esbuild/sunos-x64": "0.18.20",
+        "@esbuild/win32-arm64": "0.18.20",
+        "@esbuild/win32-ia32": "0.18.20",
+        "@esbuild/win32-x64": "0.18.20"
+      }
+    },
+    "node_modules/escalade": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
+      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6"
+      }
+    },
+    "node_modules/fast-glob": {
+      "version": "3.3.3",
+      "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.3.3.tgz",
+      "integrity": "sha512-7MptL8U0cqcFdzIzwOTHoilX9x5BrNqye7Z/LuC7kCMRio1EMSyqRK3BEAUD7sXRq4iT4AzTVuZdhgQ2TCvYLg==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@nodelib/fs.stat": "^2.0.2",
+        "@nodelib/fs.walk": "^1.2.3",
+        "glob-parent": "^5.1.2",
+        "merge2": "^1.3.0",
+        "micromatch": "^4.0.8"
+      },
+      "engines": {
+        "node": ">=8.6.0"
+      }
+    },
+    "node_modules/fast-glob/node_modules/glob-parent": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
+      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "is-glob": "^4.0.1"
+      },
+      "engines": {
+        "node": ">= 6"
+      }
+    },
+    "node_modules/fastq": {
+      "version": "1.20.1",
+      "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.20.1.tgz",
+      "integrity": "sha512-GGToxJ/w1x32s/D2EKND7kTil4n8OVk/9mycTc4VDza13lOvpUZTGX3mFSCtV9ksdGBVzvsyAVLM6mHFThxXxw==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "reusify": "^1.0.4"
+      }
+    },
+    "node_modules/fill-range": {
+      "version": "7.1.1",
+      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
+      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "to-regex-range": "^5.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/fraction.js": {
+      "version": "5.3.4",
+      "resolved": "https://registry.npmjs.org/fraction.js/-/fraction.js-5.3.4.tgz",
+      "integrity": "sha512-1X1NTtiJphryn/uLQz3whtY6jK3fTqoE3ohKs0tT+Ujr1W59oopxmoEh7Lu5p6vBaPbgoM0bzveAW4Qi5RyWDQ==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": "*"
+      },
+      "funding": {
+        "type": "github",
+        "url": "https://github.com/sponsors/rawify"
+      }
+    },
+    "node_modules/fsevents": {
+      "version": "2.3.3",
+      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
+      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
+      "dev": true,
+      "hasInstallScript": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "darwin"
+      ],
+      "engines": {
+        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
+      }
+    },
+    "node_modules/function-bind": {
+      "version": "1.1.2",
+      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
+      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
+      "dev": true,
+      "license": "MIT",
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/gensync": {
+      "version": "1.0.0-beta.2",
+      "resolved": "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz",
+      "integrity": "sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/glob-parent": {
+      "version": "6.0.2",
+      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz",
+      "integrity": "sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "is-glob": "^4.0.3"
+      },
+      "engines": {
+        "node": ">=10.13.0"
+      }
+    },
+    "node_modules/hasown": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
+      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "function-bind": "^1.1.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
+    "node_modules/is-binary-path": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
+      "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "binary-extensions": "^2.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/is-core-module": {
+      "version": "2.16.1",
+      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.16.1.tgz",
+      "integrity": "sha512-UfoeMA6fIJ8wTYFEUjelnaGI67v6+N7qXJEvQuIGa99l4xsCruSYOVSQ0uPANn4dAzm8lkYPaKLrrijLq7x23w==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "hasown": "^2.0.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-extglob": {
+      "version": "2.1.1",
+      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
+      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/is-glob": {
+      "version": "4.0.3",
+      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
+      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "is-extglob": "^2.1.1"
+      },
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/is-number": {
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
+      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=0.12.0"
+      }
+    },
+    "node_modules/jiti": {
+      "version": "1.21.7",
+      "resolved": "https://registry.npmjs.org/jiti/-/jiti-1.21.7.tgz",
+      "integrity": "sha512-/imKNG4EbWNrVjoNC/1H5/9GFy+tqjGBHCaSsN+P2RnPqjsLmv6UD3Ej+Kj8nBWaRAwyk7kK5ZUc+OEatnTR3A==",
+      "dev": true,
+      "license": "MIT",
+      "bin": {
+        "jiti": "bin/jiti.js"
+      }
+    },
+    "node_modules/js-tokens": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
+      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
+      "license": "MIT"
+    },
+    "node_modules/jsesc": {
+      "version": "3.1.0",
+      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-3.1.0.tgz",
+      "integrity": "sha512-/sM3dO2FOzXjKQhJuo0Q173wf2KOo8t4I8vHy6lF9poUp7bKT0/NHE8fPX23PwfhnykfqnC2xRxOnVw5XuGIaA==",
+      "dev": true,
+      "license": "MIT",
+      "bin": {
+        "jsesc": "bin/jsesc"
+      },
+      "engines": {
+        "node": ">=6"
+      }
+    },
+    "node_modules/json5": {
+      "version": "2.2.3",
+      "resolved": "https://registry.npmjs.org/json5/-/json5-2.2.3.tgz",
+      "integrity": "sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==",
+      "dev": true,
+      "license": "MIT",
+      "bin": {
+        "json5": "lib/cli.js"
+      },
+      "engines": {
+        "node": ">=6"
+      }
+    },
+    "node_modules/lilconfig": {
+      "version": "3.1.3",
+      "resolved": "https://registry.npmjs.org/lilconfig/-/lilconfig-3.1.3.tgz",
+      "integrity": "sha512-/vlFKAoH5Cgt3Ie+JLhRbwOsCQePABiU3tJ1egGvyQ+33R/vcwM2Zl2QR/LzjsBeItPt3oSVXapn+m4nQDvpzw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/antonk52"
+      }
+    },
+    "node_modules/lines-and-columns": {
+      "version": "1.2.4",
+      "resolved": "https://registry.npmjs.org/lines-and-columns/-/lines-and-columns-1.2.4.tgz",
+      "integrity": "sha512-7ylylesZQ/PV29jhEDl3Ufjo6ZX7gCqJr5F7PKrqc93v7fzSymt1BpwEU8nAUXs8qzzvqhbjhK5QZg6Mt/HkBg==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/loose-envify": {
+      "version": "1.4.0",
+      "resolved": "https://registry.npmjs.org/loose-envify/-/loose-envify-1.4.0.tgz",
+      "integrity": "sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==",
+      "license": "MIT",
+      "dependencies": {
+        "js-tokens": "^3.0.0 || ^4.0.0"
+      },
+      "bin": {
+        "loose-envify": "cli.js"
+      }
+    },
+    "node_modules/lru-cache": {
+      "version": "5.1.1",
+      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz",
+      "integrity": "sha512-KpNARQA3Iwv+jTA0utUVVbrh+Jlrr1Fv0e56GGzAFOXN7dk/FviaDW8LHmK52DlcH4WP2n6gI8vN1aesBFgo9w==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "yallist": "^3.0.2"
+      }
+    },
+    "node_modules/lucide-react": {
+      "version": "0.263.1",
+      "resolved": "https://registry.npmjs.org/lucide-react/-/lucide-react-0.263.1.tgz",
+      "integrity": "sha512-keqxAx97PlaEN89PXZ6ki1N8nRjGWtDa4021GFYLNj0RgruM5odbpl8GHTExj0hhPq3sF6Up0gnxt6TSHu+ovw==",
+      "license": "ISC",
+      "peerDependencies": {
+        "react": "^16.5.1 || ^17.0.0 || ^18.0.0"
+      }
+    },
+    "node_modules/merge2": {
+      "version": "1.4.1",
+      "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
+      "integrity": "sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">= 8"
+      }
+    },
+    "node_modules/micromatch": {
+      "version": "4.0.8",
+      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.8.tgz",
+      "integrity": "sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "braces": "^3.0.3",
+        "picomatch": "^2.3.1"
+      },
+      "engines": {
+        "node": ">=8.6"
+      }
+    },
+    "node_modules/ms": {
+      "version": "2.1.3",
+      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
+      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
+      "license": "MIT"
+    },
+    "node_modules/mz": {
+      "version": "2.7.0",
+      "resolved": "https://registry.npmjs.org/mz/-/mz-2.7.0.tgz",
+      "integrity": "sha512-z81GNO7nnYMEhrGh9LeymoE4+Yr0Wn5McHIZMK5cfQCl+NDX08sCZgUc9/6MHni9IWuFLm1Z3HTCXu2z9fN62Q==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "any-promise": "^1.0.0",
+        "object-assign": "^4.0.1",
+        "thenify-all": "^1.0.0"
+      }
+    },
+    "node_modules/nanoid": {
+      "version": "3.3.11",
+      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
+      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
+      "dev": true,
+      "funding": [
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/ai"
+        }
+      ],
+      "license": "MIT",
+      "bin": {
+        "nanoid": "bin/nanoid.cjs"
+      },
+      "engines": {
+        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
+      }
+    },
+    "node_modules/node-releases": {
+      "version": "2.0.27",
+      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.27.tgz",
+      "integrity": "sha512-nmh3lCkYZ3grZvqcCH+fjmQ7X+H0OeZgP40OierEaAptX4XofMh5kwNbWh7lBduUzCcV/8kZ+NDLCwm2iorIlA==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/normalize-path": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
+      "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/object-assign": {
+      "version": "4.1.1",
+      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
+      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/object-hash": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/object-hash/-/object-hash-3.0.0.tgz",
+      "integrity": "sha512-RSn9F68PjH9HqtltsSnqYC1XXoWe9Bju5+213R98cNGttag9q9yAOTzdbsqvIa7aNm5WffBZFpWYr2aWrklWAw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">= 6"
+      }
+    },
+    "node_modules/path-parse": {
+      "version": "1.0.7",
+      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz",
+      "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/picocolors": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
+      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
+      "dev": true,
+      "license": "ISC"
+    },
+    "node_modules/picomatch": {
+      "version": "2.3.1",
+      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
+      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8.6"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/jonschlinkert"
+      }
+    },
+    "node_modules/pify": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/pify/-/pify-2.3.0.tgz",
+      "integrity": "sha512-udgsAY+fTnvv7kI7aaxbqwWNb0AHiB0qBO89PZKPkoTmGOgdbrHDKD+0B2X4uTfJ/FT1R09r9gTsjUjNJotuog==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/pirates": {
+      "version": "4.0.7",
+      "resolved": "https://registry.npmjs.org/pirates/-/pirates-4.0.7.tgz",
+      "integrity": "sha512-TfySrs/5nm8fQJDcBDuUng3VOUKsd7S+zqvbOTiGXHfxX4wK31ard+hoNuvkicM/2YFzlpDgABOevKSsB4G/FA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">= 6"
+      }
+    },
+    "node_modules/postcss": {
+      "version": "8.5.6",
+      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.6.tgz",
+      "integrity": "sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==",
+      "dev": true,
+      "funding": [
+        {
+          "type": "opencollective",
+          "url": "https://opencollective.com/postcss/"
+        },
+        {
+          "type": "tidelift",
+          "url": "https://tidelift.com/funding/github/npm/postcss"
+        },
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/ai"
+        }
+      ],
+      "license": "MIT",
+      "dependencies": {
+        "nanoid": "^3.3.11",
+        "picocolors": "^1.1.1",
+        "source-map-js": "^1.2.1"
+      },
+      "engines": {
+        "node": "^10 || ^12 || >=14"
+      }
+    },
+    "node_modules/postcss-import": {
+      "version": "15.1.0",
+      "resolved": "https://registry.npmjs.org/postcss-import/-/postcss-import-15.1.0.tgz",
+      "integrity": "sha512-hpr+J05B2FVYUAXHeK1YyI267J/dDDhMU6B6civm8hSY1jYJnBXxzKDKDswzJmtLHryrjhnDjqqp/49t8FALew==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "postcss-value-parser": "^4.0.0",
+        "read-cache": "^1.0.0",
+        "resolve": "^1.1.7"
+      },
+      "engines": {
+        "node": ">=14.0.0"
+      },
+      "peerDependencies": {
+        "postcss": "^8.0.0"
+      }
+    },
+    "node_modules/postcss-js": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/postcss-js/-/postcss-js-4.1.0.tgz",
+      "integrity": "sha512-oIAOTqgIo7q2EOwbhb8UalYePMvYoIeRY2YKntdpFQXNosSu3vLrniGgmH9OKs/qAkfoj5oB3le/7mINW1LCfw==",
+      "dev": true,
+      "funding": [
+        {
+          "type": "opencollective",
+          "url": "https://opencollective.com/postcss/"
+        },
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/ai"
+        }
+      ],
+      "license": "MIT",
+      "dependencies": {
+        "camelcase-css": "^2.0.1"
+      },
+      "engines": {
+        "node": "^12 || ^14 || >= 16"
+      },
+      "peerDependencies": {
+        "postcss": "^8.4.21"
+      }
+    },
+    "node_modules/postcss-load-config": {
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/postcss-load-config/-/postcss-load-config-6.0.1.tgz",
+      "integrity": "sha512-oPtTM4oerL+UXmx+93ytZVN82RrlY/wPUV8IeDxFrzIjXOLF1pN+EmKPLbubvKHT2HC20xXsCAH2Z+CKV6Oz/g==",
+      "dev": true,
+      "funding": [
+        {
+          "type": "opencollective",
+          "url": "https://opencollective.com/postcss/"
+        },
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/ai"
+        }
+      ],
+      "license": "MIT",
+      "dependencies": {
+        "lilconfig": "^3.1.1"
+      },
+      "engines": {
+        "node": ">= 18"
+      },
+      "peerDependencies": {
+        "jiti": ">=1.21.0",
+        "postcss": ">=8.0.9",
+        "tsx": "^4.8.1",
+        "yaml": "^2.4.2"
+      },
+      "peerDependenciesMeta": {
+        "jiti": {
+          "optional": true
+        },
+        "postcss": {
+          "optional": true
+        },
+        "tsx": {
+          "optional": true
+        },
+        "yaml": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/postcss-nested": {
+      "version": "6.2.0",
+      "resolved": "https://registry.npmjs.org/postcss-nested/-/postcss-nested-6.2.0.tgz",
+      "integrity": "sha512-HQbt28KulC5AJzG+cZtj9kvKB93CFCdLvog1WFLf1D+xmMvPGlBstkpTEZfK5+AN9hfJocyBFCNiqyS48bpgzQ==",
+      "dev": true,
+      "funding": [
+        {
+          "type": "opencollective",
+          "url": "https://opencollective.com/postcss/"
+        },
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/ai"
+        }
+      ],
+      "license": "MIT",
+      "dependencies": {
+        "postcss-selector-parser": "^6.1.1"
+      },
+      "engines": {
+        "node": ">=12.0"
+      },
+      "peerDependencies": {
+        "postcss": "^8.2.14"
+      }
+    },
+    "node_modules/postcss-selector-parser": {
+      "version": "6.1.2",
+      "resolved": "https://registry.npmjs.org/postcss-selector-parser/-/postcss-selector-parser-6.1.2.tgz",
+      "integrity": "sha512-Q8qQfPiZ+THO/3ZrOrO0cJJKfpYCagtMUkXbnEfmgUjwXg6z/WBeOyS9APBBPCTSiDV+s4SwQGu8yFsiMRIudg==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "cssesc": "^3.0.0",
+        "util-deprecate": "^1.0.2"
+      },
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/postcss-value-parser": {
+      "version": "4.2.0",
+      "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-4.2.0.tgz",
+      "integrity": "sha512-1NNCs6uurfkVbeXG4S8JFT9t19m45ICnif8zWLd5oPSZ50QnwMfK+H3jv408d4jw/7Bttv5axS5IiHoLaVNHeQ==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/queue-microtask": {
+      "version": "1.2.3",
+      "resolved": "https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz",
+      "integrity": "sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==",
+      "dev": true,
+      "funding": [
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/feross"
+        },
+        {
+          "type": "patreon",
+          "url": "https://www.patreon.com/feross"
+        },
+        {
+          "type": "consulting",
+          "url": "https://feross.org/support"
+        }
+      ],
+      "license": "MIT"
+    },
+    "node_modules/react": {
+      "version": "18.3.1",
+      "resolved": "https://registry.npmjs.org/react/-/react-18.3.1.tgz",
+      "integrity": "sha512-wS+hAgJShR0KhEvPJArfuPVN1+Hz1t0Y6n5jLrGQbkb4urgPE/0Rve+1kMB1v/oWgHgm4WIcV+i7F2pTVj+2iQ==",
+      "license": "MIT",
+      "dependencies": {
+        "loose-envify": "^1.1.0"
+      },
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/react-dom": {
+      "version": "18.3.1",
+      "resolved": "https://registry.npmjs.org/react-dom/-/react-dom-18.3.1.tgz",
+      "integrity": "sha512-5m4nQKp+rZRb09LNH59GM4BxTh9251/ylbKIbpe7TpGxfJ+9kv6BLkLBXIjjspbgbnIBNqlI23tRnTWT0snUIw==",
+      "license": "MIT",
+      "dependencies": {
+        "loose-envify": "^1.1.0",
+        "scheduler": "^0.23.2"
+      },
+      "peerDependencies": {
+        "react": "^18.3.1"
+      }
+    },
+    "node_modules/react-refresh": {
+      "version": "0.17.0",
+      "resolved": "https://registry.npmjs.org/react-refresh/-/react-refresh-0.17.0.tgz",
+      "integrity": "sha512-z6F7K9bV85EfseRCp2bzrpyQ0Gkw1uLoCel9XBVWPg/TjRj94SkJzUTGfOa4bs7iJvBWtQG0Wq7wnI0syw3EBQ==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/read-cache": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/read-cache/-/read-cache-1.0.0.tgz",
+      "integrity": "sha512-Owdv/Ft7IjOgm/i0xvNDZ1LrRANRfew4b2prF3OWMQLxLfu3bS8FVhCsrSCMK4lR56Y9ya+AThoTpDCTxCmpRA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "pify": "^2.3.0"
+      }
+    },
+    "node_modules/readdirp": {
+      "version": "3.6.0",
+      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz",
+      "integrity": "sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "picomatch": "^2.2.1"
+      },
+      "engines": {
+        "node": ">=8.10.0"
+      }
+    },
+    "node_modules/resolve": {
+      "version": "1.22.11",
+      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.11.tgz",
+      "integrity": "sha512-RfqAvLnMl313r7c9oclB1HhUEAezcpLjz95wFH4LVuhk9JF/r22qmVP9AMmOU4vMX7Q8pN8jwNg/CSpdFnMjTQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "is-core-module": "^2.16.1",
+        "path-parse": "^1.0.7",
+        "supports-preserve-symlinks-flag": "^1.0.0"
+      },
+      "bin": {
+        "resolve": "bin/resolve"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/reusify": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/reusify/-/reusify-1.1.0.tgz",
+      "integrity": "sha512-g6QUff04oZpHs0eG5p83rFLhHeV00ug/Yf9nZM6fLeUrPguBTkTQOdpAWWspMh55TZfVQDPaN3NQJfbVRAxdIw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "iojs": ">=1.0.0",
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/rollup": {
+      "version": "3.29.5",
+      "resolved": "https://registry.npmjs.org/rollup/-/rollup-3.29.5.tgz",
+      "integrity": "sha512-GVsDdsbJzzy4S/v3dqWPJ7EfvZJfCHiDqe80IyrF59LYuP+e6U1LJoUqeuqRbwAWoMNoXivMNeNAOf5E22VA1w==",
+      "dev": true,
+      "license": "MIT",
+      "bin": {
+        "rollup": "dist/bin/rollup"
+      },
+      "engines": {
+        "node": ">=14.18.0",
+        "npm": ">=8.0.0"
+      },
+      "optionalDependencies": {
+        "fsevents": "~2.3.2"
+      }
+    },
+    "node_modules/run-parallel": {
+      "version": "1.2.0",
+      "resolved": "https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz",
+      "integrity": "sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==",
+      "dev": true,
+      "funding": [
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/feross"
+        },
+        {
+          "type": "patreon",
+          "url": "https://www.patreon.com/feross"
+        },
+        {
+          "type": "consulting",
+          "url": "https://feross.org/support"
+        }
+      ],
+      "license": "MIT",
+      "dependencies": {
+        "queue-microtask": "^1.2.2"
+      }
+    },
+    "node_modules/scheduler": {
+      "version": "0.23.2",
+      "resolved": "https://registry.npmjs.org/scheduler/-/scheduler-0.23.2.tgz",
+      "integrity": "sha512-UOShsPwz7NrMUqhR6t0hWjFduvOzbtv7toDH1/hIrfRNIDBnnBWd0CwJTGvTpngVlmwGCdP9/Zl/tVrDqcuYzQ==",
+      "license": "MIT",
+      "dependencies": {
+        "loose-envify": "^1.1.0"
+      }
+    },
+    "node_modules/semver": {
+      "version": "6.3.1",
+      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
+      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
+      "dev": true,
+      "license": "ISC",
+      "bin": {
+        "semver": "bin/semver.js"
+      }
+    },
+    "node_modules/socket.io-client": {
+      "version": "4.8.3",
+      "resolved": "https://registry.npmjs.org/socket.io-client/-/socket.io-client-4.8.3.tgz",
+      "integrity": "sha512-uP0bpjWrjQmUt5DTHq9RuoCBdFJF10cdX9X+a368j/Ft0wmaVgxlrjvK3kjvgCODOMMOz9lcaRzxmso0bTWZ/g==",
+      "license": "MIT",
+      "dependencies": {
+        "@socket.io/component-emitter": "~3.1.0",
+        "debug": "~4.4.1",
+        "engine.io-client": "~6.6.1",
+        "socket.io-parser": "~4.2.4"
+      },
+      "engines": {
+        "node": ">=10.0.0"
+      }
+    },
+    "node_modules/socket.io-parser": {
+      "version": "4.2.5",
+      "resolved": "https://registry.npmjs.org/socket.io-parser/-/socket.io-parser-4.2.5.tgz",
+      "integrity": "sha512-bPMmpy/5WWKHea5Y/jYAP6k74A+hvmRCQaJuJB6I/ML5JZq/KfNieUVo/3Mh7SAqn7TyFdIo6wqYHInG1MU1bQ==",
+      "license": "MIT",
+      "dependencies": {
+        "@socket.io/component-emitter": "~3.1.0",
+        "debug": "~4.4.1"
+      },
+      "engines": {
+        "node": ">=10.0.0"
+      }
+    },
+    "node_modules/source-map-js": {
+      "version": "1.2.1",
+      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
+      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/sucrase": {
+      "version": "3.35.1",
+      "resolved": "https://registry.npmjs.org/sucrase/-/sucrase-3.35.1.tgz",
+      "integrity": "sha512-DhuTmvZWux4H1UOnWMB3sk0sbaCVOoQZjv8u1rDoTV0HTdGem9hkAZtl4JZy8P2z4Bg0nT+YMeOFyVr4zcG5Tw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.2",
+        "commander": "^4.0.0",
+        "lines-and-columns": "^1.1.6",
+        "mz": "^2.7.0",
+        "pirates": "^4.0.1",
+        "tinyglobby": "^0.2.11",
+        "ts-interface-checker": "^0.1.9"
+      },
+      "bin": {
+        "sucrase": "bin/sucrase",
+        "sucrase-node": "bin/sucrase-node"
+      },
+      "engines": {
+        "node": ">=16 || 14 >=14.17"
+      }
+    },
+    "node_modules/supports-preserve-symlinks-flag": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz",
+      "integrity": "sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/tailwind-merge": {
+      "version": "1.14.0",
+      "resolved": "https://registry.npmjs.org/tailwind-merge/-/tailwind-merge-1.14.0.tgz",
+      "integrity": "sha512-3mFKyCo/MBcgyOTlrY8T7odzZFx+w+qKSMAmdFzRvqBfLlSigU6TZnlFHK0lkMwj9Bj8OYU+9yW9lmGuS0QEnQ==",
+      "license": "MIT",
+      "funding": {
+        "type": "github",
+        "url": "https://github.com/sponsors/dcastil"
+      }
+    },
+    "node_modules/tailwindcss": {
+      "version": "3.4.19",
+      "resolved": "https://registry.npmjs.org/tailwindcss/-/tailwindcss-3.4.19.tgz",
+      "integrity": "sha512-3ofp+LL8E+pK/JuPLPggVAIaEuhvIz4qNcf3nA1Xn2o/7fb7s/TYpHhwGDv1ZU3PkBluUVaF8PyCHcm48cKLWQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@alloc/quick-lru": "^5.2.0",
+        "arg": "^5.0.2",
+        "chokidar": "^3.6.0",
+        "didyoumean": "^1.2.2",
+        "dlv": "^1.1.3",
+        "fast-glob": "^3.3.2",
+        "glob-parent": "^6.0.2",
+        "is-glob": "^4.0.3",
+        "jiti": "^1.21.7",
+        "lilconfig": "^3.1.3",
+        "micromatch": "^4.0.8",
+        "normalize-path": "^3.0.0",
+        "object-hash": "^3.0.0",
+        "picocolors": "^1.1.1",
+        "postcss": "^8.4.47",
+        "postcss-import": "^15.1.0",
+        "postcss-js": "^4.0.1",
+        "postcss-load-config": "^4.0.2 || ^5.0 || ^6.0",
+        "postcss-nested": "^6.2.0",
+        "postcss-selector-parser": "^6.1.2",
+        "resolve": "^1.22.8",
+        "sucrase": "^3.35.0"
+      },
+      "bin": {
+        "tailwind": "lib/cli.js",
+        "tailwindcss": "lib/cli.js"
+      },
+      "engines": {
+        "node": ">=14.0.0"
+      }
+    },
+    "node_modules/thenify": {
+      "version": "3.3.1",
+      "resolved": "https://registry.npmjs.org/thenify/-/thenify-3.3.1.tgz",
+      "integrity": "sha512-RVZSIV5IG10Hk3enotrhvz0T9em6cyHBLkH/YAZuKqd8hRkKhSfCGIcP2KUY0EPxndzANBmNllzWPwak+bheSw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "any-promise": "^1.0.0"
+      }
+    },
+    "node_modules/thenify-all": {
+      "version": "1.6.0",
+      "resolved": "https://registry.npmjs.org/thenify-all/-/thenify-all-1.6.0.tgz",
+      "integrity": "sha512-RNxQH/qI8/t3thXJDwcstUO4zeqo64+Uy/+sNVRBx4Xn2OX+OZ9oP+iJnNFqplFra2ZUVeKCSa2oVWi3T4uVmA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "thenify": ">= 3.1.0 < 4"
+      },
+      "engines": {
+        "node": ">=0.8"
+      }
+    },
+    "node_modules/tinyglobby": {
+      "version": "0.2.15",
+      "resolved": "https://registry.npmjs.org/tinyglobby/-/tinyglobby-0.2.15.tgz",
+      "integrity": "sha512-j2Zq4NyQYG5XMST4cbs02Ak8iJUdxRM0XI5QyxXuZOzKOINmWurp3smXu3y5wDcJrptwpSjgXHzIQxR0omXljQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "fdir": "^6.5.0",
+        "picomatch": "^4.0.3"
+      },
+      "engines": {
+        "node": ">=12.0.0"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/SuperchupuDev"
+      }
+    },
+    "node_modules/tinyglobby/node_modules/fdir": {
+      "version": "6.5.0",
+      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.5.0.tgz",
+      "integrity": "sha512-tIbYtZbucOs0BRGqPJkshJUYdL+SDH7dVM8gjy+ERp3WAUjLEFJE+02kanyHtwjWOnwrKYBiwAmM0p4kLJAnXg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12.0.0"
+      },
+      "peerDependencies": {
+        "picomatch": "^3 || ^4"
+      },
+      "peerDependenciesMeta": {
+        "picomatch": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/tinyglobby/node_modules/picomatch": {
+      "version": "4.0.3",
+      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
+      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/jonschlinkert"
+      }
+    },
+    "node_modules/to-regex-range": {
+      "version": "5.0.1",
+      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
+      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "is-number": "^7.0.0"
+      },
+      "engines": {
+        "node": ">=8.0"
+      }
+    },
+    "node_modules/ts-interface-checker": {
+      "version": "0.1.13",
+      "resolved": "https://registry.npmjs.org/ts-interface-checker/-/ts-interface-checker-0.1.13.tgz",
+      "integrity": "sha512-Y/arvbn+rrz3JCKl9C4kVNfTfSm2/mEp5FSz5EsZSANGPSlQrpRI5M4PKF+mJnE52jOO90PnPSc3Ur3bTQw0gA==",
+      "dev": true,
+      "license": "Apache-2.0"
+    },
+    "node_modules/typescript": {
+      "version": "5.9.3",
+      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.9.3.tgz",
+      "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "bin": {
+        "tsc": "bin/tsc",
+        "tsserver": "bin/tsserver"
+      },
+      "engines": {
+        "node": ">=14.17"
+      }
+    },
+    "node_modules/update-browserslist-db": {
+      "version": "1.2.3",
+      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.2.3.tgz",
+      "integrity": "sha512-Js0m9cx+qOgDxo0eMiFGEueWztz+d4+M3rGlmKPT+T4IS/jP4ylw3Nwpu6cpTTP8R1MAC1kF4VbdLt3ARf209w==",
+      "dev": true,
+      "funding": [
+        {
+          "type": "opencollective",
+          "url": "https://opencollective.com/browserslist"
+        },
+        {
+          "type": "tidelift",
+          "url": "https://tidelift.com/funding/github/npm/browserslist"
+        },
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/ai"
+        }
+      ],
+      "license": "MIT",
+      "dependencies": {
+        "escalade": "^3.2.0",
+        "picocolors": "^1.1.1"
+      },
+      "bin": {
+        "update-browserslist-db": "cli.js"
+      },
+      "peerDependencies": {
+        "browserslist": ">= 4.21.0"
+      }
+    },
+    "node_modules/util-deprecate": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
+      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/vite": {
+      "version": "4.5.14",
+      "resolved": "https://registry.npmjs.org/vite/-/vite-4.5.14.tgz",
+      "integrity": "sha512-+v57oAaoYNnO3hIu5Z/tJRZjq5aHM2zDve9YZ8HngVHbhk66RStobhb1sqPMIPEleV6cNKYK4eGrAbE9Ulbl2g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "esbuild": "^0.18.10",
+        "postcss": "^8.4.27",
+        "rollup": "^3.27.1"
+      },
+      "bin": {
+        "vite": "bin/vite.js"
+      },
+      "engines": {
+        "node": "^14.18.0 || >=16.0.0"
+      },
+      "funding": {
+        "url": "https://github.com/vitejs/vite?sponsor=1"
+      },
+      "optionalDependencies": {
+        "fsevents": "~2.3.2"
+      },
+      "peerDependencies": {
+        "@types/node": ">= 14",
+        "less": "*",
+        "lightningcss": "^1.21.0",
+        "sass": "*",
+        "stylus": "*",
+        "sugarss": "*",
+        "terser": "^5.4.0"
+      },
+      "peerDependenciesMeta": {
+        "@types/node": {
+          "optional": true
+        },
+        "less": {
+          "optional": true
+        },
+        "lightningcss": {
+          "optional": true
+        },
+        "sass": {
+          "optional": true
+        },
+        "stylus": {
+          "optional": true
+        },
+        "sugarss": {
+          "optional": true
+        },
+        "terser": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/ws": {
+      "version": "8.18.3",
+      "resolved": "https://registry.npmjs.org/ws/-/ws-8.18.3.tgz",
+      "integrity": "sha512-PEIGCY5tSlUt50cqyMXfCzX+oOPqN0vuGqWzbcJ2xvnkzkq46oOpz7dQaTDBdfICb4N14+GARUDw2XV2N4tvzg==",
+      "license": "MIT",
+      "engines": {
+        "node": ">=10.0.0"
+      },
+      "peerDependencies": {
+        "bufferutil": "^4.0.1",
+        "utf-8-validate": ">=5.0.2"
+      },
+      "peerDependenciesMeta": {
+        "bufferutil": {
+          "optional": true
+        },
+        "utf-8-validate": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/xmlhttprequest-ssl": {
+      "version": "2.1.2",
+      "resolved": "https://registry.npmjs.org/xmlhttprequest-ssl/-/xmlhttprequest-ssl-2.1.2.tgz",
+      "integrity": "sha512-TEU+nJVUUnA4CYJFLvK5X9AOeH4KvDvhIfm0vV1GaQRtchnG0hgK5p8hw/xjv8cunWYCsiPCSDzObPyhEwq3KQ==",
+      "engines": {
+        "node": ">=0.4.0"
+      }
+    },
+    "node_modules/yallist": {
+      "version": "3.1.1",
+      "resolved": "https://registry.npmjs.org/yallist/-/yallist-3.1.1.tgz",
+      "integrity": "sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g==",
+      "dev": true,
+      "license": "ISC"
+    }
+  }
+}
diff --git a/log-viewer-app/frontend/package.json b/log-viewer-app/frontend/package.json
new file mode 100644
index 0000000..e2ea4e6
--- /dev/null
+++ b/log-viewer-app/frontend/package.json
@@ -0,0 +1,31 @@
+
+{
+  "name": "log-viewer-frontend",
+  "private": true,
+  "version": "0.0.0",
+  "type": "module",
+  "scripts": {
+    "dev": "vite",
+    "build": "tsc && vite build",
+    "preview": "vite preview"
+  },
+  "dependencies": {
+    "react": "^18.2.0",
+    "react-dom": "^18.2.0",
+    "socket.io-client": "^4.7.2",
+    "lucide-react": "^0.263.1",
+    "date-fns": "^2.30.0",
+    "clsx": "^2.0.0",
+    "tailwind-merge": "^1.14.0"
+  },
+  "devDependencies": {
+    "@types/react": "^18.2.15",
+    "@types/react-dom": "^18.2.7",
+    "@vitejs/plugin-react": "^4.0.3",
+    "autoprefixer": "^10.4.14",
+    "postcss": "^8.4.27",
+    "tailwindcss": "^3.3.3",
+    "typescript": "^5.0.2",
+    "vite": "^4.4.5"
+  }
+}
diff --git a/log-viewer-app/frontend/postcss.config.js b/log-viewer-app/frontend/postcss.config.js
new file mode 100644
index 0000000..7608c65
--- /dev/null
+++ b/log-viewer-app/frontend/postcss.config.js
@@ -0,0 +1,7 @@
+
+export default {
+  plugins: {
+    tailwindcss: {},
+    autoprefixer: {},
+  },
+}
diff --git a/log-viewer-app/frontend/src/App.tsx b/log-viewer-app/frontend/src/App.tsx
new file mode 100644
index 0000000..6c7ca67
--- /dev/null
+++ b/log-viewer-app/frontend/src/App.tsx
@@ -0,0 +1,32 @@
+
+import React from 'react';
+import LogViewer from './components/LogViewer';
+import TaskManager from './components/TaskManager';
+import { Activity } from 'lucide-react';
+
+function App() {
+  return (
+    <div className="min-h-screen bg-slate-100 text-slate-900 font-sans p-4 md:p-6 lg:p-8">
+      <header className="max-w-7xl mx-auto mb-8 flex items-center gap-3">
+        <div className="bg-blue-600 p-2 rounded-lg shadow-lg">
+          <Activity className="text-white" size={28} />
+        </div>
+        <div>
+          <h1 className="text-2xl font-black tracking-tight">V-AUTOMATION DASHBOARD</h1>
+          <p className="text-slate-500 text-sm font-medium">Live Server Monitoring & Task Management</p>
+        </div>
+      </header>
+
+      <main className="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-2 gap-8 h-[calc(100vh-160px)]">
+        <section className="h-full min-h-[400px]">
+          <LogViewer />
+        </section>
+        <section className="h-full min-h-[400px]">
+          <TaskManager />
+        </section>
+      </main>
+    </div>
+  );
+}
+
+export default App;
diff --git a/log-viewer-app/frontend/src/components/LogViewer.tsx b/log-viewer-app/frontend/src/components/LogViewer.tsx
new file mode 100644
index 0000000..8f1df82
--- /dev/null
+++ b/log-viewer-app/frontend/src/components/LogViewer.tsx
@@ -0,0 +1,84 @@
+
+import React, { useEffect, useState, useRef } from 'react';
+import { io, Socket } from 'socket.io-client';
+import { LogEntry } from '../types';
+import { Terminal, Trash2, Play, Pause } from 'lucide-react';
+
+const LogViewer: React.FC = () => {
+  const [logs, setLogs] = useState<LogEntry[]>([]);
+  const [isConnected, setIsConnected] = useState(false);
+  const [isPaused, setIsPaused] = useState(false);
+  const scrollRef = useRef<HTMLDivElement>(null);
+  const socketRef = useRef<Socket | null>(null);
+
+  useEffect(() => {
+    socketRef.current = io('http://localhost:3001');
+
+    socketRef.current.on('connect', () => setIsConnected(true));
+    socketRef.current.on('disconnect', () => setIsConnected(false));
+
+    socketRef.current.on('log-line', (log: LogEntry) => {
+      if (!isPaused) {
+        setLogs((prev) => [...prev.slice(-499), log]);
+      }
+    });
+
+    return () => {
+      socketRef.current?.disconnect();
+    };
+  }, [isPaused]);
+
+  useEffect(() => {
+    if (scrollRef.current && !isPaused) {
+      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
+    }
+  }, [logs, isPaused]);
+
+  const clearLogs = () => setLogs([]);
+
+  return (
+    <div className="flex flex-col h-full bg-slate-900 text-slate-100 rounded-lg overflow-hidden border border-slate-700 shadow-xl">
+      <div className="flex items-center justify-between px-4 py-2 bg-slate-800 border-b border-slate-700">
+        <div className="flex items-center gap-2">
+          <Terminal size={18} className="text-emerald-400" />
+          <h2 className="font-semibold">Live Server Logs</h2>
+          <span className={`w-2 h-2 rounded-full ${isConnected ? 'bg-emerald-500 animate-pulse' : 'bg-red-500'}`} />
+        </div>
+        <div className="flex gap-2">
+          <button 
+            onClick={() => setIsPaused(!isPaused)}
+            className="p-1 hover:bg-slate-700 rounded transition-colors"
+            title={isPaused ? "Resume" : "Pause"}
+          >
+            {isPaused ? <Play size={16} /> : <Pause size={16} />}
+          </button>
+          <button 
+            onClick={clearLogs}
+            className="p-1 hover:bg-slate-700 rounded transition-colors"
+            title="Clear Logs"
+          >
+            <Trash2 size={16} />
+          </button>
+        </div>
+      </div>
+      <div 
+        ref={scrollRef}
+        className="flex-1 overflow-y-auto p-4 font-mono text-sm space-y-1 scrollbar-thin scrollbar-thumb-slate-700"
+      >
+        {logs.map((log, i) => (
+          <div key={i} className="flex gap-4 hover:bg-slate-800/50 rounded px-1 group">
+            <span className="text-slate-500 select-none whitespace-nowrap">
+              {new Date(log.timestamp).toLocaleTimeString()}
+            </span>
+            <span className="text-slate-300 break-all">{log.message}</span>
+          </div>
+        ))}
+        {logs.length === 0 && (
+          <div className="text-slate-500 italic">Waiting for logs...</div>
+        )}
+      </div>
+    </div>
+  );
+};
+
+export default LogViewer;
diff --git a/log-viewer-app/frontend/src/components/TaskManager.tsx b/log-viewer-app/frontend/src/components/TaskManager.tsx
new file mode 100644
index 0000000..7d756b6
--- /dev/null
+++ b/log-viewer-app/frontend/src/components/TaskManager.tsx
@@ -0,0 +1,151 @@
+
+import React, { useState, useEffect } from 'react';
+import { Task, Priority, TaskCategory } from '../types';
+import { Plus, Trash2, CheckCircle, Circle, Calendar, AlertCircle } from 'lucide-react';
+import { format } from 'date-fns';
+
+const TaskManager: React.FC = () => {
+  const [tasks, setTasks] = useState<Task[]>([]);
+  const [title, setTitle] = useState('');
+  const [category, setCategory] = useState<TaskCategory>('Other');
+  const [priority, setPriority] = useState<Priority>('medium');
+  const [dueDate, setDueDate] = useState(format(new Date(), 'yyyy-MM-dd'));
+
+  useEffect(() => {
+    const saved = localStorage.getItem('v-logs-tasks');
+    if (saved) setTasks(JSON.parse(saved));
+  }, []);
+
+  useEffect(() => {
+    localStorage.setItem('v-logs-tasks', JSON.stringify(tasks));
+  }, [tasks]);
+
+  const addTask = (e: React.FormEvent) => {
+    e.preventDefault();
+    if (!title.trim()) return;
+
+    const newTask: Task = {
+      id: crypto.randomUUID(),
+      title,
+      description: '',
+      category,
+      priority,
+      dueDate,
+      completed: false,
+      createdAt: new Date().toISOString()
+    };
+
+    setTasks([newTask, ...tasks]);
+    setTitle('');
+  };
+
+  const toggleTask = (id: string) => {
+    setTasks(tasks.map(t => t.id === id ? { ...t, completed: !t.completed } : t));
+  };
+
+  const deleteTask = (id: string) => {
+    setTasks(tasks.filter(t => t.id !== id));
+  };
+
+  const getPriorityColor = (p: Priority) => {
+    switch (p) {
+      case 'high': return 'text-red-400';
+      case 'medium': return 'text-amber-400';
+      case 'low': return 'text-emerald-400';
+    }
+  };
+
+  return (
+    <div className="flex flex-col h-full bg-slate-50 rounded-lg overflow-hidden border border-slate-200 shadow-sm">
+      <div className="p-4 bg-white border-b border-slate-200">
+        <h2 className="text-lg font-bold text-slate-800 mb-4">Task Management</h2>
+        <form onSubmit={addTask} className="space-y-3">
+          <input
+            type="text"
+            value={title}
+            onChange={(e) => setTitle(e.target.value)}
+            placeholder="What needs to be done?"
+            className="w-full px-3 py-2 border border-slate-300 rounded focus:ring-2 focus:ring-blue-500 outline-none"
+          />
+          <div className="flex flex-wrap gap-2">
+            <select 
+              value={category} 
+              onChange={(e) => setCategory(e.target.value as TaskCategory)}
+              className="px-2 py-1 border rounded text-sm"
+            >
+              <option>Bugs</option>
+              <option>Features</option>
+              <option>Maintenance</option>
+              <option>Other</option>
+            </select>
+            <select 
+              value={priority} 
+              onChange={(e) => setPriority(e.target.value as Priority)}
+              className="px-2 py-1 border rounded text-sm"
+            >
+              <option value="low">Low</option>
+              <option value="medium">Medium</option>
+              <option value="high">High</option>
+            </select>
+            <input 
+              type="date" 
+              value={dueDate}
+              onChange={(e) => setDueDate(e.target.value)}
+              className="px-2 py-1 border rounded text-sm"
+            />
+            <button 
+              type="submit"
+              className="ml-auto bg-blue-600 text-white px-4 py-1 rounded hover:bg-blue-700 transition-colors flex items-center gap-1"
+            >
+              <Plus size={16} /> Add
+            </button>
+          </div>
+        </form>
+      </div>
+
+      <div className="flex-1 overflow-y-auto p-4 space-y-3">
+        {tasks.map(task => (
+          <div 
+            key={task.id} 
+            className={`flex items-center gap-3 p-3 bg-white border rounded-lg shadow-sm group transition-all ${task.completed ? 'opacity-60' : ''}`}
+          >
+            <button onClick={() => toggleTask(task.id)} className="text-slate-400 hover:text-blue-500 transition-colors">
+              {task.completed ? <CheckCircle className="text-emerald-500" size={20} /> : <Circle size={20} />}
+            </button>
+            <div className="flex-1">
+              <h3 className={`font-medium ${task.completed ? 'line-through text-slate-500' : 'text-slate-800'}`}>
+                {task.title}
+              </h3>
+              <div className="flex gap-3 mt-1 text-xs text-slate-500">
+                <span className="flex items-center gap-1">
+                  <AlertCircle size={12} className={getPriorityColor(task.priority)} />
+                  {task.priority.toUpperCase()}
+                </span>
+                <span className="flex items-center gap-1">
+                  <Calendar size={12} />
+                  {task.dueDate}
+                </span>
+                <span className="bg-slate-100 px-1.5 py-0.5 rounded uppercase font-semibold text-[10px]">
+                  {task.category}
+                </span>
+              </div>
+            </div>
+            <button 
+              onClick={() => deleteTask(task.id)}
+              className="text-slate-300 hover:text-red-500 opacity-0 group-hover:opacity-100 transition-all"
+            >
+              <Trash2 size={18} />
+            </button>
+          </div>
+        ))}
+        {tasks.length === 0 && (
+          <div className="text-center py-10 text-slate-400">
+            <p>No tasks yet. Start by adding one above!</p>
+          </div>
+        )}
+      </div>
+    </div>
+  );
+};
+
+export default TaskManager;
diff --git a/log-viewer-app/frontend/src/index.css b/log-viewer-app/frontend/src/index.css
new file mode 100644
index 0000000..0a2f762
--- /dev/null
+++ b/log-viewer-app/frontend/src/index.css
@@ -0,0 +1,30 @@
+
+@tailwind base;
+@tailwind components;
+@tailwind utilities;
+
+:root {
+  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
+}
+
+body {
+  margin: 0;
+  overflow: hidden;
+}
+
+::-webkit-scrollbar {
+  width: 8px;
+}
+
+::-webkit-scrollbar-track {
+  background: transparent;
+}
+
+::-webkit-scrollbar-thumb {
+  background: #cbd5e1;
+  border-radius: 4px;
+}
+
+::-webkit-scrollbar-thumb:hover {
+  background: #94a3b8;
+}
diff --git a/log-viewer-app/frontend/src/main.tsx b/log-viewer-app/frontend/src/main.tsx
new file mode 100644
index 0000000..b0445ae
--- /dev/null
+++ b/log-viewer-app/frontend/src/main.tsx
@@ -0,0 +1,11 @@
+
+import React from 'react'
+import ReactDOM from 'react-dom/client'
+import App from './App.tsx'
+import './index.css'
+
+ReactDOM.createRoot(document.getElementById('root')!).render(
+  <React.StrictMode>
+    <App />
+  </React.StrictMode>,
+)
diff --git a/log-viewer-app/frontend/src/types.ts b/log-viewer-app/frontend/src/types.ts
new file mode 100644
index 0000000..97f2005
--- /dev/null
+++ b/log-viewer-app/frontend/src/types.ts
@@ -0,0 +1,20 @@
+
+export interface LogEntry {
+  timestamp: string;
+  message: string;
+}
+
+export type Priority = 'low' | 'medium' | 'high';
+
+export interface Task {
+  id: string;
+  title: string;
+  description: string;
+  category: string;
+  dueDate: string;
+  priority: Priority;
+  completed: boolean;
+  createdAt: string;
+}
+
+export type TaskCategory = 'Bugs' | 'Features' | 'Maintenance' | 'Other';
diff --git a/log-viewer-app/frontend/tailwind.config.js b/log-viewer-app/frontend/tailwind.config.js
new file mode 100644
index 0000000..c82f10a
--- /dev/null
+++ b/log-viewer-app/frontend/tailwind.config.js
@@ -0,0 +1,12 @@
+
+/** @type {import('tailwindcss').Config} */
+export default {
+  content: [
+    "./index.html",
+    "./src/**/*.{js,ts,jsx,tsx}",
+  ],
+  theme: {
+    extend: {},
+  },
+  plugins: [],
+}
diff --git a/plans/consolidate-all-patches-to-core.md b/plans/consolidate-all-patches-to-core.md
deleted file mode 100644
index 188e5d0..0000000
--- a/plans/consolidate-all-patches-to-core.md
+++ /dev/null
@@ -1,123 +0,0 @@
-# Consolidate All Patches to Core
-
-## Overview
-Move ALL Harmony patches from all mods (Bluelock, CycleBorn, root Patches) to a centralized `Core/Patches` directory. This reduces file count in mod directories and centralizes patch logic for better maintainability.
-
-## Current Patch Locations
-
-### 1. Root Patches/ (4 files)
-| File | Purpose | Target Systems |
-|------|---------|----------------|
-| `BuffSpawnServerPatch.cs` | Buff spawn/destroy events | `Buff.Initialize`, `Buff.Destroy` |
-| `DeathEventSystemPatch.cs` | Death event handling | `DeathEventListenerSystem.OnUpdate` |
-| `ServerBootstrapSystemPatch.cs` | Server bootstrap events | `ServerBootstrapSystem.OnUpdate`, `WorldBootstrapSystem.Initialize` |
-| `UnitSpawnerSystemPatch.cs` | Unit spawning events | `UnitSpawnerSystem.OnUpdate`, `SpawnTravelBuffSystem.OnUpdate` |
-
-### 2. Bluelock/Patches/ (3 files)
-| File | Purpose | Target Systems |
-|------|---------|----------------|
-| `AbilityRunScriptsSystemPatch.cs` | Ability cast events | `AbilityRunScriptsSystem.OnUpdate` |
-| `ReplaceAbilityOnSlotSystemPatch.cs` | Ability slot replacement | `ReplaceAbilityOnSlotSystem.OnUpdate` |
-| `DropInventorySystemPatch.cs` | Inventory drop handling | `DropInventorySystem.DropItem` |
-
-### 3. CycleBorn/Services/Lifecycle/ (3 files)
-| File | Purpose | Target Systems |
-|------|---------|----------------|
-| `ConnectionEventPatches.cs` | Player connect/disconnect | `ServerBootstrapSystem.OnUserConnected`, `OnUserDisconnected` |
-| `InputSystemUpdatePatch.cs` | ZUI input blocking | `ClientBootstrapSystem.OnUpdate` |
-| `Handlers/PatchBuffSystemSpawnServer.cs` | VBlood feed suppression | `BuffSystem_Spawn_Server.OnUpdate` |
-
-### 4. Bluelock/Plugin.cs Inline Patches (8 patches)
-| Line | Target System | Purpose |
-|------|---------------|---------|
-| 3432 | `BacktraceSystem.OnUpdate` | Error tracking |
-| 3821 | `PlaceTileModelSystem.OnUpdate` | Building restrictions |
-| 3884 | `InitializeNewSpawnChainSystem.OnUpdate` | Spawn initialization |
-| 3897 | `AbilityRunScriptsSystem.OnUpdate` | **DUPLICATE** - Already in patches |
-| 3940 | `ServerBootstrapSystem.OnUpdate` | Server lifecycle |
-| 3950 | `TriggerPersistenceSaveSystem.TriggerSave` | Save events |
-| 3973 | `ServerBootstrapSystem.OnUserConnected` | User connection |
-| 4004 | `DownedEventSystem.OnUpdate` | Downed state handling |
-
-## Proposed Structure
-
-```
-Core/
-├── Patches/
-│   ├── Ability/
-│   │   ├── AbilityRunScriptsSystemPatch.cs
-│   │   └── ReplaceAbilityOnSlotSystemPatch.cs
-│   ├── Bootstrap/
-│   │   ├── ServerBootstrapSystemPatch.cs
-│   │   └── ConnectionEventPatches.cs
-│   ├── Buffs/
-│   │   ├── BuffSpawnServerPatch.cs
-│   │   └── BuffSystemSpawnServerPatch.cs
-│   ├── Combat/
-│   │   ├── DeathEventSystemPatch.cs
-│   │   └── DownedEventSystemPatch.cs
-│   ├── Inventory/
-│   │   └── DropInventorySystemPatch.cs
-│   ├── Spawning/
-│   │   ├── UnitSpawnerSystemPatch.cs
-│   │   └── InitializeNewSpawnChainSystemPatch.cs
-│   ├── Building/
-│   │   └── PlaceTileModelSystemPatch.cs
-│   ├── Persistence/
-│   │   └── TriggerPersistenceSaveSystemPatch.cs
-│   ├── Input/
-│   │   └── InputSystemUpdatePatch.cs
-│   └── Debug/
-│       └── BacktraceSystemPatch.cs
-└── Events/
-    └── PatchEvents.cs (already exists)
-```
-
-## Migration Strategy
-
-### Phase 1: Create Core/Patches Structure
-1. Create subdirectories under `Core/Patches/` for organization
-2. Each subdirectory groups related patches by functionality
-
-### Phase 2: Move Existing Patches
-1. Move root `Patches/` files to `Core/Patches/`
-2. Move `Bluelock/Patches/` files to `Core/Patches/Ability/`
-3. Move `CycleBorn/Services/Lifecycle/` patches to appropriate subdirectories
-
-### Phase 3: Extract Inline Patches from Plugin.cs
-1. Extract inline patches from `Bluelock/Plugin.cs` to separate files
-2. Remove duplicate `AbilityRunScriptsSystem` patch (line 3897)
-3. Consolidate with existing patches where applicable
-
-### Phase 4: Update Namespaces
-All patches should use namespace `VAutomationCore.Core.Patches.<Subdirectory>`
-
-### Phase 5: Clean Up
-1. Delete old patch directories:
-   - `Patches/` (root)
-   - `Bluelock/Patches/`
-   - `CycleBorn/Services/Lifecycle/` (patch files only)
-2. Update any direct references in mod code
-
-## Benefits
-1. **Single source of truth** for all Harmony patches
-2. **Reduced file count** in mod directories
-3. **Better organization** by functionality
-4. **Easier maintenance** - all patches in one location
-5. **Event-driven architecture** - mods subscribe to events, don't need their own patches
-6. **No duplicate patches** - consolidate overlapping functionality
-
-## Implementation Order
-1. Create `Core/Patches/` directory structure
-2. Move root `Patches/` files first (simplest)
-3. Move `Bluelock/Patches/` files
-4. Move `CycleBorn/Services/Lifecycle/` patch files
-5. Extract inline patches from `Bluelock/Plugin.cs`
-6. Update all namespaces
-7. Delete old patch directories
-8. Update references in mod code
-
-## Notes
-- Some patches in `CycleBorn/Services/Lifecycle/Handlers/PatchBuffSystemSpawnServer.cs` reference `ArenaTracker` and `SandboxModeTag` which are mod-specific. These need to be refactored to use events instead.
-- The `ConnectionEventPatches.cs` has its own Harmony instance - this should be consolidated with the main plugin's Harmony instance.
-- Inline patches in `Bluelock/Plugin.cs` should be extracted to separate files for better maintainability.
diff --git a/plans/lifecycle-bluelock-separation-strict-plan.md b/plans/lifecycle-bluelock-separation-strict-plan.md
deleted file mode 100644
index cbd5314..0000000
--- a/plans/lifecycle-bluelock-separation-strict-plan.md
+++ /dev/null
@@ -1,164 +0,0 @@
-# Lifecycle and Bluelock Separation Plan v4 Layered Layout
-
-## Architecture Layout You Requested
-
-- Top layer is `CycleBorn` lifecycle orchestration.
-- Middle layer is shared `VAutomationCore` contracts and utilities.
-- Bottom layer is `Bluelock` domain logic and data.
-
-```mermaid
-flowchart TD
-  A[CycleBorn lifecycle orchestration] --> B[VAutomationCore shared contracts and bridges]
-  B --> C[Bluelock domain services and configs]
-```
-
-## Top Layer CycleBorn
-
-Role:
-
-- Own lifecycle stages, flow ordering, action pipeline, startup policy.
-- Never own zone template internals.
-
-Files:
-
-- `CycleBorn/Plugin.cs`
-- `CycleBorn/Cycleborn.lifecycle.json`
-- `CycleBorn/Services/Lifecycle/ArenaLifecycleManager.cs`
-- `CycleBorn/Services/Lifecycle/LifecycleActionHandlers.cs`
-
-Rules:
-
-- Use shared interfaces from middle layer.
-- Dispatch domain tokens down to Bluelock through adapters only.
-
-## Middle Layer Shared VAutomationCore
-
-Role:
-
-- Own reusable contracts, token catalogs, shared bridge utilities, strict migration scanners.
-- Contain no Bluelock feature ownership and no CycleBorn stage policy ownership.
-
-Files:
-
-- `Core/Lifecycle/IZoneLifecycleStepRegistry.cs`
-- `Core/Lifecycle/IZoneLifecycleContext.cs`
-- new `Core/Lifecycle/LifecycleActionTokenCatalog.cs`
-- `Core/Services/DebugEventBridge.cs`
-- new `Core/Config/StrictMigrationKeyScanner.cs`
-- `Configuration/VAutoConfigService.cs`
-
-Rules:
-
-- Canonical token source of truth lives here.
-- Strict scanner utilities live here and are called by CycleBorn startup.
-
-## Bottom Layer Bluelock
-
-Role:
-
-- Own zone template kit ability blood boss and unit domain behavior.
-- Register adapters that implement shared token handlers.
-
-Files:
-
-- `Bluelock/Plugin.cs`
-- new `Bluelock/Services/Lifecycle/BluelockLifecycleAdapterRegistry.cs`
-- `Bluelock/Services/ZoneTemplateService.cs`
-- `Bluelock/Services/KitService.cs`
-- `Bluelock/Services/AbilityService.cs`
-- `config/Bluelock.zones.json`
-- `config/Bluelock.kits.json`
-- `config/Bluelock.ability_zones.json`
-
-Rules:
-
-- Keep all domain internals in Bluelock.
-- Expose behavior through shared interfaces only.
-
-## Data Handling Model
-
-### Domain Data ownership by layer
-
-- `CycleBorn` stores flow-only data such as stage names, ordered action tokens, and runtime orchestration flags.
-- `VAutomationCore` stores shared runtime context contracts and shared bridge payload models.
-- `Bluelock` stores gameplay domain data such as zone definitions, templates, kits, abilities, blood, boss, and unit rules.
-
-### Data flow at runtime
-
-1. `CycleBorn` reads lifecycle stage config and creates execution context.
-2. Context is passed through `VAutomationCore` interfaces and token registry.
-3. `Bluelock` adapter resolves token and executes domain service.
-4. Result status and diagnostics return back to `CycleBorn` stage runner.
-
-### Data boundaries
-
-- No zone template schema fields may be added to lifecycle config.
-- No stage execution policy fields may be added to Bluelock config.
-- Shared context fields must be defined in `VAutomationCore` and consumed by both modules.
-
-## Config Handling Model
-
-### Lifecycle config owned by CycleBorn
-
-File:
-
-- `CycleBorn/Cycleborn.lifecycle.json`
-
-Contains only:
-
-- Stage definitions enter exit in-zone
-- Action token order
-- Strict migration flags and orchestration behavior
-
-### Domain configs owned by Bluelock
-
-Files:
-
-- `config/Bluelock.zones.json`
-- `config/Bluelock.kits.json`
-- `config/Bluelock.ability_zones.json`
-
-Contain only:
-
-- Zone geometry and per-zone domain settings
-- Template references and validation-relevant fields
-- Kit, ability, blood, boss, and unit domain options
-
-### Shared config utilities owned by VAutomationCore
-
-Files:
-
-- `Configuration/VAutoConfigService.cs`
-- new `Core/Config/StrictMigrationKeyScanner.cs`
-
-Responsibilities:
-
-- Shared file loading helpers
-- Ownership-key validation helpers
-- Strict-mode violation reporting helpers
-
-### Strict mode behavior for config violations
-
-- If `strictMigrationEnabled` is true and mixed ownership keys are found, startup fails immediately.
-- Failure output must include module owner expectation, file path, and JSON key path.
-
-## Work Checklist
-
-1. Define canonical token catalog in shared middle layer.
-2. Register Bluelock adapters for domain-owned tokens.
-3. Refactor CycleBorn to dispatch through shared registry only.
-4. Split config ownership by layer.
-5. Enable strict startup gate and fail on mixed keys.
-
-## Strict Migration Gate
-
-- `strictMigrationEnabled` true in lifecycle config causes startup hard fail if mixed ownership keys are detected.
-- Error log must include exact file path and exact key path.
-
-## Acceptance Criteria
-
-- CycleBorn is top orchestration layer only.
-- VAutomationCore is middle shared layer only.
-- Bluelock is bottom domain layer only.
-- Mixed legacy keys fail startup when strict flag is true.
-
diff --git a/plans/move-ability-patches-to-core.md b/plans/move-ability-patches-to-core.md
deleted file mode 100644
index 190ddd8..0000000
--- a/plans/move-ability-patches-to-core.md
+++ /dev/null
@@ -1,67 +0,0 @@
-# Move Ability Patches to Core
-
-## Overview
-Move the ability-related Harmony patches from `Bluelock/Patches` to `Core/Patches` to reduce file count in Bluelock and centralize shared patch logic.
-
-## Files to Move
-
-### Source Files (Delete after move)
-1. `Bluelock/Patches/AbilityRunScriptsSystemPatch.cs`
-2. `Bluelock/Patches/ReplaceAbilityOnSlotSystemPatch.cs`
-
-### Target Files (Create)
-1. `Core/Patches/AbilityRunScriptsSystemPatch.cs`
-2. `Core/Patches/ReplaceAbilityOnSlotSystemPatch.cs`
-
-## Changes Required
-
-### 1. Create Core/Patches Directory
-Create the `Core/Patches` directory if it doesn't exist.
-
-### 2. Move AbilityRunScriptsSystemPatch.cs
-- Change namespace from `VAuto.Zone.Patches` to `VAutomationCore.Core.Patches`
-- Keep all other code the same
-
-### 3. Move ReplaceAbilityOnSlotSystemPatch.cs
-- Change namespace from `VAuto.Zone.Patches` to `VAutomationCore.Core.Patches`
-- Keep all other code the same
-
-### 4. Delete Old Files
-Delete the original files from `Bluelock/Patches/`:
-- `Bluelock/Patches/AbilityRunScriptsSystemPatch.cs`
-- `Bluelock/Patches/ReplaceAbilityOnSlotSystemPatch.cs`
-
-### 5. Update References (if any)
-Check if any files reference these patches directly and update the namespace imports.
-
-## File Structure After Move
-
-```
-Core/
-├── Patches/
-│   ├── AbilityRunScriptsSystemPatch.cs
-│   └── ReplaceAbilityOnSlotSystemPatch.cs
-├── Events/
-│   └── PatchEvents.cs (already updated)
-└── ...
-
-Bluelock/
-├── Patches/
-│   └── DropInventorySystemPatch.cs (kept - Bluelock-specific)
-├── Services/
-│   ├── AbilityService.cs (kept - uses Core patches via events)
-│   └── AbilityZoneService.cs (kept - uses Core patches via events)
-└── ...
-```
-
-## Benefits
-1. Reduces file count in Bluelock
-2. Centralizes shared patch logic in Core
-3. Makes patches reusable by other plugins
-4. Follows the existing architecture pattern (Core contains shared functionality)
-
-## Implementation Order
-1. Create `Core/Patches/AbilityRunScriptsSystemPatch.cs` with updated namespace
-2. Create `Core/Patches/ReplaceAbilityOnSlotSystemPatch.cs` with updated namespace
-3. Delete `Bluelock/Patches/AbilityRunScriptsSystemPatch.cs`
-4. Delete `Bluelock/Patches/ReplaceAbilityOnSlotSystemPatch.cs`
diff --git a/plans/vrising-skill-model-sections.md b/plans/vrising-skill-model-sections.md
deleted file mode 100644
index 938c0a7..0000000
--- a/plans/vrising-skill-model-sections.md
+++ /dev/null
@@ -1,47 +0,0 @@
-# Sections
-
-This file defines V Rising-focused sections, their ordering, impact levels, and descriptions.
-The section ID (in parentheses) is the filename prefix used to group rules.
-
----
-
-## 1. ECS Update Loop Efficiency (ecs)
-
-**Impact:** CRITICAL  
-**Description:** ECS update loops are the primary dedicated-server hotspot. Avoid heavy per-tick work, repeated queries, and avoidable allocations.
-
-## 2. Lifecycle Snapshot Integrity (lifecycle)
-
-**Impact:** CRITICAL  
-**Description:** Zone/arena save-restore behavior must be deterministic and failure-safe for inventory, buffs, blood, spells, and position.
-
-## 3. Prefab and Data Resolution Reliability (data)
-
-**Impact:** HIGH  
-**Description:** Stable prefab GUID/name resolution and strict config validation prevent runtime failures from invalid references and schema drift.
-
-## 4. Command and Permission Safety (commands)
-
-**Impact:** HIGH  
-**Description:** Command surfaces must enforce permissions and predictable argument handling to protect live server state.
-
-## 5. Patch and Interop Stability (patch)
-
-**Impact:** HIGH  
-**Description:** Harmony/IL2CPP integration should be minimal, guarded, and version-tolerant to avoid crashes and patch conflicts.
-
-## 6. Configuration Evolution and Migration (config)
-
-**Impact:** MEDIUM-HIGH  
-**Description:** Schema evolution should support migration, backward compatibility, and safe hot-reload behavior across plugin versions.
-
-## 7. Zone Reassertion and Recovery (zones)
-
-**Impact:** MEDIUM  
-**Description:** Reassert zone invariants and recovery paths under ECS churn to maintain gameplay correctness.
-
-## 8. Diagnostics and Test Guardrails (quality)
-
-**Impact:** MEDIUM  
-**Description:** Structured logs, targeted tests, and guardrails accelerate debugging and reduce regressions in live mods.
-
diff --git a/skills/vrising-runtime-best-practices/rules/_sections.md b/skills/vrising-runtime-best-practices/rules/_sections.md
deleted file mode 100644
index 3ae219e..0000000
--- a/skills/vrising-runtime-best-practices/rules/_sections.md
+++ /dev/null
@@ -1,36 +0,0 @@
-# Sections
-
-This file defines a second V Rising-focused rules model.
-
----
-
-## 1. Runtime Stability (runtime)
-
-**Impact:** CRITICAL  
-**Description:** Prevent hard crashes and invalid ECS state during gameplay updates.
-
-## 2. Lifecycle Correctness (lifecycle)
-
-**Impact:** CRITICAL  
-**Description:** Ensure player snapshot/save/restore flows are deterministic and reversible.
-
-## 3. Patch Guardrails (patch)
-
-**Impact:** HIGH  
-**Description:** Keep Harmony/interop patching minimal, version-aware, and fail-safe.
-
-## 4. Config Safety (config)
-
-**Impact:** HIGH  
-**Description:** Validate and migrate config safely to avoid broken server startup/runtime. also the main settings must thru plugin,cs (cfg) json only data 
-
-## 5. Command Safety (commands)
-
-**Impact:** MEDIUM-HIGH  
-**Description:** Enforce permission boundaries and predictable command behavior.
-
-## 6. Observability (observability)
-
-**Impact:** MEDIUM  
-**Description:** Ensure logs and diagnostics are actionable during live operations.
-
